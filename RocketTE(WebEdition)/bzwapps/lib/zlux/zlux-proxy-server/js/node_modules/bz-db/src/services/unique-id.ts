import lodash_pkg from 'lodash'
const { now } = lodash_pkg
import { CONFIG } from '../constants/config.js'

class UniqueId {

    private _internalSequence: number // sequence num, +1 each time touched. 
    private _ipNum: number // sum of the ip data. 

    constructor(){
        this._internalSequence = 0
        this._ipNum = 0
    }

    /**
     * 
     * @param multiAddr The multiAddr object, it should inludes the ip data as bytes.
     */
    public setIp(multiAddr: any){
        try{
            if (multiAddr && multiAddr.bytes){
                this._ipNum = multiAddr.bytes.reduce((prev:number, curr:number) => {
                    return prev + curr
                })
            }
        } catch(e) {
            // shouldn't happen. keep the ipnum as 0. Do nothing.
        }
    }

    public generate(radix: number = CONFIG.UID_NUMBER_STR_RADIX, level: number = CONFIG.UID_MAX_LEVEL){
        if (radix < 2 || radix > 36) {
            radix = CONFIG.UID_NUMBER_STR_RADIX
        }
        const partsArr = [
            now() - CONFIG.UID_BASE_TIME, // ts
            this._internalSequence ++, // internal sequence
        ]
        if (this._internalSequence >= CONFIG.UID_SEQUENCE_MAX) {
            this._internalSequence = 0
        }
        if (level > 1){
            partsArr.push(Math.floor(Math.random() * CONFIG.UID_RANDOM_RANGE)) // random number
        }
        if (level > 2){
            partsArr.push(process.pid) // process id
        }
        if (level > 3){
            partsArr.push(this._ipNum) // Sum of ip address parts
        }
        let uid = partsArr[0].toString(radix) + CONFIG.UID_SEPRATOR + partsArr[1].toString(radix)
        for (let i = 2; i <= Math.min(level, CONFIG.UID_MAX_LEVEL); i++){
            uid += CONFIG.UID_SEPRATOR + partsArr[i].toString(radix)
        }
        return uid
    }
}

const uid = new UniqueId()

export {
    uid
}