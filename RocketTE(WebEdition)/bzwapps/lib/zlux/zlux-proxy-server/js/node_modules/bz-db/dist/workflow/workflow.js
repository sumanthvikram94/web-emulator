import { Logger, uid } from '../services/index.js';
import { Task } from './task.js';
import { TaskQueue } from './task-queue.js';
import { CONFIG } from '../constants/config.js';
class Workflow {
    constructor() {
        this._queue = new TaskQueue();
        this._tasks = new Map();
        this._timeouts = new Map();
        this._tasksLifeTime = new Map();
        this._groups = new Map();
    }
    createTask(id, options, fun) {
        options['workflow'] = this;
        const t = new Task(id, options, fun);
        const groups = options.groups && options.groups.length > 0 ? options.groups : undefined;
        if (groups) { // The task is in group
            for (const group of groups) {
                let tasksInGroup = this._groups.get(group);
                if (!tasksInGroup) {
                    tasksInGroup = new Map();
                    this._groups.set(group, tasksInGroup);
                }
                tasksInGroup.set(t.id, t); // Records the task into group.
            }
        }
        t.once('finally', () => {
            Logger.logDebug('Finally of task: ' + t.description);
            if (groups) { // The task is in group
                for (const group of groups) {
                    let tasksInGroup = this._groups.get(group);
                    if (tasksInGroup) {
                        tasksInGroup.delete(t.id); // Delete the task from group when it's resolved.
                    }
                }
            }
            t.destroy();
            Logger.logDebug('Task size: ' + this.getTaskSize());
            this.describeTasks(false);
            Logger.logDebug('Queue stats: ' + JSON.stringify(this.getQueueStats()));
        });
        this._tasks.set(id, t);
        Logger.logDebug('Task size: ' + this.getTaskSize());
        this.describeTasks(false);
        return t;
    }
    // Gets all the tasks currently in the group.
    getGroupTasks(groups) {
        const result = {};
        if (groups && groups.length > 0) {
            for (const group in groups) {
                const tasksInGroup = this._groups.get(group);
                if (tasksInGroup) {
                    result[group] = Array.from(tasksInGroup.values());
                }
            }
        }
        return result;
    }
    // Waits for the groups of tasks to finish.
    async waitForTaskGroups(groups) {
        const proms = [];
        let msg = 'Waiting for task groups:';
        for (const group of groups) {
            const tasksInGroup = this._groups.get(group);
            if (tasksInGroup && tasksInGroup.size > 0) {
                msg += ' > ' + group + ' - ' + tasksInGroup.size;
                for (const task of tasksInGroup.values()) {
                    proms.push(task.getPromise());
                }
            }
        }
        if (proms.length > 0) {
            Logger.logInfo(msg);
            await Promise.all(proms);
        }
    }
    /**
     * Generate a new task to run the given function. Use the given ID or otherwise generate an id if it's not provided.
     */
    generateTask(options, fun, id) {
        // let tid = Date.now().toString()
        // while(this.getTask(tid)){ // avoid duplicated id of task
        //     tid += '+'
        // }
        const tid = id ? id : uid.generate(CONFIG.UID_NUMBER_STR_RADIX, 1); // tid is: timestamp + internal sequence
        return this.createTask(tid, options, fun);
    }
    getTask(id) {
        return this._tasks.get(id);
    }
    isOverwhelmed() {
        Logger.logDebug('Tasks size: ' + this._tasks.size);
        return this._tasks.size > CONFIG.TASK_MAX_COUNT;
    }
    describeTasks(isInfo = true) {
        const size = this.getTaskSize();
        const keys = Array.from(this._tasks.keys()).sort();
        let desc = 'Describing tasks: \n';
        desc += 'Count: ' + size;
        keys.forEach(key => {
            desc += '\nTask ID: ' + key + ' - ' + this.getTask(key)?.description;
        });
        if (isInfo) {
            Logger.logInfo(desc);
        }
        else {
            Logger.logDebug(desc);
        }
    }
    existsTaskDesc(desc) {
        for (const t of Array.from(this._tasks.values())) {
            const desct = t.description;
            if (desct.includes(desc)) {
                return true;
            }
        }
        return false;
    }
    searchTaskDesc(desc) {
        const tasksArr = [];
        for (const t of Array.from(this._tasks.values())) {
            const desct = t.description;
            if (desct.includes(desc)) {
                tasksArr.push(t);
            }
        }
        return tasksArr;
    }
    async enqueueTask(task) {
        return await this._queue.push(task);
    }
    async executeTask(task) {
        return await task.execute();
    }
    async bookTask(task, timeout) {
        const tmo = setTimeout(async () => {
            await task.execute();
            task.resolve({ status: true });
        }, timeout);
        this._timeouts.set(task.id, tmo);
        task.once('destroy', () => {
            this._timeouts.delete(task.id);
            clearTimeout(tmo);
        });
    }
    getTaskSize() {
        return this._tasks.size;
    }
    getQueueStats() {
        return this._queue._q.getStats();
    }
    destroy() {
        this._tasks.forEach((task) => {
            task.destroy();
        });
    }
    getPerfRecords() {
        return this._tasksLifeTime;
    }
}
export { Workflow };
