// const fs = require('fs');
import fs from 'fs';
import fse from 'fs-extra';
// const path = require('path');
import path from 'path';
import { Logger } from './index.js';
import { yaml } from './yaml.js'
import { PersistType } from '../main/metadata.js';

interface FileSize {
    fileName: string
    size: number
}


interface FileContent {
    fileName: string
    content: string
}

class FileService{

    _fileStats: Map<string, fs.Stats>;

    constructor(){
        this._fileStats = new Map();
    }

    getFileStat(fileName: string){
        return this._fileStats.get(fileName);
    }

    setFileStat(fileName: string, stat: fs.Stats): void{
        this._fileStats.set(fileName, stat);
    }

    removeFileStat(fileName: string): void {
        this._fileStats.delete(fileName);
    }

    getFiles(dir:string): string[]{
        const dir1 = path.resolve(dir);

        if (fse.existsSync(dir1)) {
            return fse.readdirSync(dir1);
        }

        return [];
    }
    existFileSync(fileName:string){
        const fileName1 = path.resolve(fileName);
        return fse.existsSync(fileName1);
    }  

    async readJSON(fileName: string, encoding = 'utf8'){
        const filePath = path.resolve(fileName);
        if (!fse.existsSync(filePath)){
            return {}
        }
        let dataText:string = await this.readFilePromise(filePath, encoding)
        try{
            if (!dataText) { // Sometimes, the data could be empty file. Return {} in this case.
                return {}
            }
            return JSON.parse(dataText)
        }catch(e){
            return this.convertToJsonWithComment(dataText)
        }
    }
    
    async getData(dir: string, subName: string): Promise<any>{
        let files = this.getFiles(dir) || [];
        let dataArray=[];
        files=files.filter(file => (subName.length && file.indexOf(`${subName}`) > -1));
        if(files.length>0){
            for(let i=0;i<files.length;i++){
                try{
                    const fileName = path.resolve(`${dir}/${files[i]}`);
                    let dataText:string = await this.readFilePromise(fileName, 'utf8');
                    let dataObj
                    try{
                        dataObj = JSON.parse(dataText);
                    }catch(e){
                        dataObj = this.convertToJsonWithComment(dataText);
                    }
                    dataArray.push(dataObj);
                    this._fileStats.set(fileName, fse.statSync(fileName)); // Records the stats of the files read
                }catch(err){
                    // this.logger.severe('Error: getData(); file path is '+path.resolve(`${dir}/${files[i]}`)+'; error is '+err.stack);
                    throw err;
                }
            }
        }
        return dataArray;
    }

    async getFilesAsync(dir:string): Promise<string[]> {
        return new Promise (async (resolve) => {
            try {
                const isDirExists = await fse.pathExists(dir) // If the dir not exists, return empty array
                if (!isDirExists) {
                    Logger.logDebug(`The directory not exists: ${dir}.`);
                    return resolve([])
                }
            } catch(err) {
                Logger.logSevere(`Error while check dir existance for ${dir}. Message: ${err.message}`);
                return resolve([])
            }
            fse.readdir(dir, (err, files) => {
                if (err === null) {
                    resolve(files)
                } else {
                    Logger.logSevere(`Error while reading dir ${dir}. Message: ${err.message}`);
                    resolve([])
                }
            })
        })
    }

    async getFileSize(filePath: string, fileName: string): Promise<FileSize | undefined> {
        const fullPath = path.join(filePath, fileName)
        return new Promise( (resolve) => {
            fse.stat(fullPath, (err, stat) => {
                if (err === null) {
                    if (stat.isFile()) {
                        resolve({fileName, size: stat.size})
                    }
                } else {
                    Logger.logSevere(`Error while fse.state ${fullPath}. Message: ${err.message}`)
                    resolve(undefined)
                }
            })
        })
    }

    async getDirFileSize(dir: string, subName?: string): Promise<FileSize[]> {
        let files = await this.getFilesAsync(dir);
        if (!files || files.length === 0) {
            return []
        }
        return new Promise (async (resolve) => {
            const result = []
            if (subName !== undefined) {
                files=files.filter(file => (subName.length && file.indexOf(`${subName}`) > -1));
            }
            for await (const fileName of files) {
                const fileSize = await this.getFileSize(dir, fileName)
                if (fileSize !== undefined) {
                    result.push(fileSize)
                }
            }
            resolve(result)
        })
    }

    async getDirFileContents(dir: string, subName?: string): Promise<FileContent[]> {
        let files = await this.getFilesAsync(dir);
        if (!files || files.length === 0) {
            return []
        }
        return new Promise (async (resolve) => {
            const result: FileContent[] = []
            if (subName !== undefined) {
                files=files.filter(file => (subName.length && file.indexOf(`${subName}`) > -1));
            }
            for await (const fileName of files) {
                const fullPath = path.join(dir, fileName)
                const content:string = await this.readFileAsync(fullPath, 'utf8')
                result.push({
                    fileName,
                    content
                })
            }
            resolve(result)
        })
    }

    async getDataMap(dir: string, subName: string, isWatchFile = false): Promise<Map<string, any>>{
        let files = this.getFiles(dir) || [];
        let dataMap = new Map();
        files=files.filter(file => (subName.length && file.indexOf(`${subName}`) > -1));
        if(files.length>0){
            for(let i=0;i<files.length;i++){
                try{
                    const fileName = path.resolve(`${dir}/${files[i]}`);
                    // const existFileState = this._fileStats.get(fileName)
                    // if (existFileState) {
                    //     const fileState = fse.statSync(fileName)
                    //     if (existFileState.mtimeMs === fileState.mtimeMs) { // The file to read is unchanged.
                    //         // TBD, Return the existing partition data.
                    //     }
                    // }
                    let dataText:string = await this.readFilePromise(fileName, 'utf8', isWatchFile);
                    let dataObj
                    if (fileName.toLowerCase().endsWith('.yaml')) {
                        try{
                            dataObj = yaml.yamlStrToJson(dataText)
                        }catch(e){
                            Logger.logSevere('Error encountered while parsing yaml to json')
                            Logger.logError(e)
                            dataObj = {}
                        }
                    } else { // json by default
                        try{
                            dataObj = JSON.parse(dataText);
                        }catch(e){
                            dataObj = this.convertToJsonWithComment(dataText);
                        }
                    }
                    dataMap.set(fileName, dataObj);
                    this._fileStats.set(fileName, fse.statSync(fileName)); // Records the stats of the files read
                }catch(err){
                    // this.logger.severe('Error: getData(); file path is '+path.resolve(`${dir}/${files[i]}`)+'; error is '+err.stack);
                    throw err;
                }
            }
        }
        return dataMap;
    }
 
    /**
     * Reads all files in a dir, returns file name and file content as JSON or raw data.
     * @param dir 
     * @param subName file name filter
     * @param isRawData True to return file content without parsing as JSON
     * @param isAllowSubFolder True to include files in sub folder
     * @returns object[]
     */
    async returnDataWithName(dir: string, subName: string, persistType:PersistType = PersistType.PERSIST_TYPE_RAW, isAllowSubFolder:boolean=false): Promise<any>{
        try{
            let files:string[] = []
            const isRawData = persistType === PersistType.PERSIST_TYPE_RAW
            files = ((isRawData && isAllowSubFolder) ? this.getLeafFiles(dir) : this.getFiles(dir)) ||[];
            let dataArray=[];
            if(subName.length>0){ //true 
                files=files.filter(file => (file.indexOf(`${subName}`) > -1));
            }
            if(files.length>0){
                for(let i=0;i<files.length;i++){
                    const fileName = path.resolve(`${dir}/${files[i]}`);
                    let dataObj
                    if(isRawData){
                        let str = await this.readBufferFilePromise(fileName);
                        dataObj=JSON.stringify(str);
                    }else{
                        let str = await this.readFilePromise(fileName, 'utf8');
                        const fileExt = fileName.lastIndexOf('.') > 0? fileName.substring(fileName.lastIndexOf('.')).toLowerCase(): undefined

                        if (persistType === PersistType.PERSIST_TYPE_YAML || fileExt === '.yaml') {
                            try{
                                dataObj = yaml.yamlStrToJson(str)
                            }catch(e){
                                Logger.logSevere('Error encountered while parsing yaml to json')
                                Logger.logError(e)
                                dataObj = str
                            }
                        } else if (fileExt === '.json') {
                            try{
                                dataObj = JSON.parse(str);
                            }catch(e){
                                dataObj = this.convertToJsonWithComment(str);
                            }
                        } else {
                            dataObj=str;
                        }
                    }
                    const entityObj={
                        fileName:files[i],
                        data:dataObj
                    }
                    dataArray.push(entityObj);
                    this._fileStats.set(fileName, fse.statSync(fileName)); // Records the stats of the files read
                }
            }
            return dataArray;
        }catch(e){
            throw e;
        }
    }
    getLeafFiles(dir:string):string[]{
        let filterFilesArray:string[] = [];
        if(!fse.existsSync(dir)){
            return [];
        }
        try{
            let files = fse.readdirSync(dir)
            if(files.length > 0){
                for(const tempFile of files){
                    let tempPath = path.posix.join(dir,tempFile);  // fix file sync issue from Windows to Linux
                    let stat = fse.lstatSync(tempPath);
                    if(stat.isDirectory()){
                        let tempFilesRes = this.getLeafFiles(tempPath);
                        for(const temp of tempFilesRes){
                            filterFilesArray.push(path.posix.join(tempFile, temp));  // fix file sync issue from Windows to Linux
                        }
                    }else if(stat.isFile()){
                        filterFilesArray.push(tempFile);
                    }
                }
            }else{
                return [];
            }
        }catch(e){
            Logger.logSevere(`Exception occurs when getLeafFiles: ${e.message}`);
            throw e;
        }
        return filterFilesArray;

    }

    async readFileAsync(path:string, opts:string = 'utf8'): Promise<string> {
        return new Promise((resolve) => {
            fse.readFile(path, opts, (err: any, data: string) => {
                if (err) {
                    Logger.logSevere('Error while reading file content: ' + path)
                    Logger.logError(err)
                    resolve('')
                }
                else {
                    resolve(data);
                }
            })
        });
    }

    readFilePromise(path:string, opts:string = 'utf8', isWatchFile = false): Promise<any> {
        return new Promise(async (resolve, reject) => {
            if (isWatchFile) { // In watch file mode and NFS, the NFS client might has data cache.
                await this.clearNFSClientCacheAsync(this.getDir(path))
            }
            fse.readFile(path, opts, (err: any, data: any) => {
                if (err) reject(err)
                else {
                    this._fileStats.set(path, fse.statSync(path)); // Records the stats of the files read
                    resolve(data);
                }
            })
        });
    };
    readBufferFilePromise(path:string): Promise<any> {
        return new Promise((resolve, reject) => {
            fse.readFile(path,(err: any, data: any) => {
                if (err) reject(err)
                else {
                    this._fileStats.set(path, fse.statSync(path)); // Records the stats of the files read
                    resolve(data);
                }
            })
        });
    };

    convertToJsonWithComment(fileAsString: string) {
        let cleanJSON = "";
        let pos = 0;
        let done = false;
        while (!done) {
            let newlinePos = fileAsString.indexOf('\n', pos);
            let line = "";
            if (newlinePos != -1) {
                line = fileAsString.substring(pos, newlinePos);
            } else {
                line = fileAsString.substring(pos);
                done = true;
            }
            // console.log("LINE: "+line);
            let inQuote = false;
            let quoteType;
            let ignoreNext = false;
            let len = line.length - 1;
            let slashSlashPos = -1;
            for (let i = 0; i < len; i++) {
                let c = line[i];
                if (c === '"' || c === "'") {
                    if (ignoreNext) {
                        ignoreNext = false;
                        continue;
                    }
                    if (!inQuote) {
                        inQuote = true;
                        quoteType = c;
                    } else if (quoteType === c) {
                        inQuote = false;
                        quoteType = null;
                    }
                } else if (inQuote && c === "\\") {
                    ignoreNext = true;
                } else if (!inQuote && c === '/') {
                    if (line[i + 1] === '/') {
                        slashSlashPos = i;
                        break;
                    }
                }
                if (ignoreNext) {
                    ignoreNext = false;
                }
            }
            if (slashSlashPos != -1) {
                cleanJSON += (line.substring(0, slashSlashPos) + "\n");
            } else {
                cleanJSON += (line + "\n");
            }
            pos = newlinePos + 1;
        }
        let parsedJSON = null;
        try {
            parsedJSON = JSON.parse(cleanJSON);
        }
        catch (e) {
            throw e;
        }
        return parsedJSON;
    };
    
    getDir(filePath: string): string {
        let dirPath = filePath;
        if(dirPath.search(/.json$|.zmd$|.zad$|.zvt$|.zap$|.zmp$/)>0){
            dirPath=path.dirname(dirPath); 
        }
        return dirPath;
    }
    
    clearNFSClientCache(dir: string, callback: Function){
        try{
            fs.readdir(dir, () => { // Read dir to avoid EFS client cache
                callback()
            })
        } catch(e) {
            callback()
        }
    }

    
    async clearNFSClientCacheAsync(dir: string){
        return new Promise((resolve) => {
            try{
                fs.readdir(dir, () => { // Read dir to avoid EFS client cache
                    resolve(true)
                })
            } catch(e) {
                resolve(true)
            }
        })
    }

}

export { FileService, FileContent };