
// const util = require('util')
// const BZDB = require('./');
import * as BZDB from './dist/index.js'
// const path = require('path');
// const fs = require('fs');
const FILE_EXT_JSON = '.json';
const logConfig = {
    type: process.env.BZ_LOGGER_TYPE,
    logLevels: { // -1-SILENT, 0-SEVERE, 1-WARN, 2-INFO, 3-DEBUG
        default: process.env.BZ_LOGGER_LEVEL || 2,
        txn: process.env.BZ_LOGGER_LEVEL || 2,
        metadata: process.env.BZ_LOGGER_LEVEL || 2,
        cluster: process.env.BZ_LOGGER_LEVEL || 3,
        checkin: process.env.BZ_LOGGER_LEVEL || 3,
        pull: process.env.BZ_LOGGER_LEVEL || 3,
        performance: process.env.BZ_LOGGER_LEVEL || 2
    }
}
// if (process.env.BZ_LOGGER_TYPE === 'file'){
//     logConfig.fileName = process.env.BZ_LOGGER_FILE_NAME; // bzdb should write log to the same file as server.
// }

// if run "node test.js 2", will create BZDB in folder `./bzwdata_2`
var argv = (process.argv.slice(2));
console.dir(argv);
let dbPathSuffix = '';
if (argv.length > 0) {
    dbPathSuffix = `_${argv[0]}`;
}
console.log(dbPathSuffix)

const cluster = {
    enabled: true,
    autoScaling: {
        enabled: false,
        nodeType: 'persistent', // 'scalable'
        discovery: 'mdns'
    }
}

// const cluster = {
//     enabled: true,
//     autoScaling: {
//         enabled: true,
//         discovery: 'bootstrap'
//     }
// }

const metadata = {
    appName: 'RTEW 10.1.2',
    storePath: `./bzwdata${dbPathSuffix}/`,
    processPooling: 0, // Multi-process can be controlled by ENV variable now.
    logging: logConfig,
    // hostSpicificIp:'127.0.0.1',
    enableWorkerThread: true,
    cluster,
    //conflictPolicy:1,
    dataEntities: [
        {
            name: 'sessionShared', 
            primaryKeys: ['id']
        },
        {
            name: 'group',
            primaryKeys: ['id'],
            indexes: {groupName: ['groupName']}
        },
        {
            name: 'groupSession', // set candidate group for session
            primaryKeys: ['id'], // session id
            indexes: {gids: ['gids']}
        },
        {
            name: 'groupSetting',
            primaryKeys: ['gid']
        },
        {
            name: 'groupDist',
            primaryKeys: ['gid']
        },
        {
            name: 'userInfo',
            primaryKeys: ['userId']
        },
        {
            name: 'userLogin',
            primaryKeys: ['username']
        },
        {
            name: 'keyboardMappingShared',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            fileNamePrefix: 'K_',
            fileNameSurfix: FILE_EXT_JSON
        },
        {
            name: 'hotspotShared',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            fileNamePrefix: 'H_',
            fileNameSurfix: FILE_EXT_JSON
        },
        {
            name: 'launchpadShared',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            fileNamePrefix: 'L_',
            fileNameSurfix: FILE_EXT_JSON
        },
        {
            name: 'preferenceShared',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            fileNamePrefix: 'P_',
            fileNameSurfix: FILE_EXT_JSON
        },
        {
            name: 'groupId',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: '../../../../groups',
            fileName: 'id_manager.json'
        },
        {
            name: 'keyboardMapping',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,
            filePath: 'keyboardMapping',
            fileName: 'keyboardMapping.json'
        },
        {
            name: 'sessionSettingMapping',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,
            filePath: 'sessionSettingMapping',
            fileName: 'sessionSettingMapping.json'
        },
        {
            name: 'sessionPrivate',
            primaryKeys: ['id'],
            indexes: {userId: ['userId'], TCPHost: ['TCPHost']}
        },
        {
            name: 'scriptPrivate',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
			dataStrategy: BZDB.DataStrategy.NO_CACHE
        },
        {
            name: 'scriptShared',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE
        },
        {
            name: 'keyboardMappingPrivate',
            primaryKeys: ['userId', 'id'],
            indexes: {userId: ['userId']}
        },
        {
            name: 'hotspotPrivate',
            primaryKeys: ['userId', 'id'],
            indexes: {userId: ['userId']}
        },
        {
            name: 'launchpadPrivate',
            primaryKeys: ['userId', 'id'],
            indexes: {userId: ['userId']}
        },
        {
            name: 'preferencePrivate',
            primaryKeys: ['userId', 'id'],
            indexes: {userId: ['userId']}
        },
        {
            name: 'administrator',
            primaryKeys: ['id']
        },
        {
            name: 'userLanguage',
            primaryKeys: ['id']
        },
        {
            name: 'groupUserPrivilege',
            primaryKeys: ['groupId','userId','sessionId']
        },
        {
            name: 'authConfig',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: 'authConfig',
			dataStrategy: BZDB.DataStrategy.NO_CACHE
        },
        {
            name: 'configurations',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: 'configurations',
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            fileNameSurfix: FILE_EXT_JSON
        },
        {
            name: 'w2hLicense',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: BZDB.PersistType.PERSIST_TYPE_RAW,
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            filePath: '../../../../../product/ZLUX/pluginStorage/com.rs.bzw2h',
            fileName: 'bluezone.lic'
        },
        {
            name: 'w2hGroups',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            isAllowSubFolder: true, 
            filePath: '../../../../../instance/ZLUX/pluginStorage/com.rs.bzw2h/groups'
        },
        {
            name: 'apiToken',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE
        },
        {
            name: 'w2hFileDists',
            primaryKeys: ['relative_path'],
            partitions: {
                relative_path: 1   // use single file
            },
            //persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            //persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,  <== Not work well in Cluster mode
            //fileName: 'fileSync.json',
            syncFile4Cluster: true
        },
        {
            name: 'w2hProfiles',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: BZDB.PersistType.PERSIST_TYPE_RAW,
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            filePath: '../../com.rs.bzadm/sessions'
        },
        {
            name: 'upload',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: 'upload',
            backupFilePaths:['../../../../../product/ZLUX/serverConfig'],
            persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
			dataStrategy: BZDB.DataStrategy.NO_CACHE
        },
        {
            name: 'reportConfig',
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: 'userReport',
            backupFilePaths:['../../../../../product/ZLUX/pluginStorage/com.rs.bzadm/configurations'],
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            fileName: 'userReport.json'
        },
        {
            name: 'terminalMfa',
            primaryKeys: ['id'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: './configuration',
            fileName: 'terminalMfa.json'
        },
        {
            name: 'userTerminalMfa',
            primaryKeys: ['id']
        },
        {
            name: 'connLocalData',     // [user report] Save the first startup time(since) and peak users count - ever recorded in local; Not sync to cluster
            primaryKeys: [],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: '/connLocalData',
			dataStrategy: BZDB.DataStrategy.NO_CACHE,
            fileNameSurfix: FILE_EXT_JSON,
            syncMode: BZDB.SyncMode.SYNC_LOCAL
        },
        {
            name: 'connPoolBasic',     // [user report]  For user by server page
            primaryKeys: ['uuid'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_ONLY_MEMORY
        },
        {
            name: 'connPoolGroup',    // [user report]  For user by group page
            primaryKeys: ['uuid'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_ONLY_MEMORY
        },
        // {
        //     name: 'connPeakDay',
        //     primaryKeys: ['sip'],
        //     dataStrategy: BZDB.DataStrategy.NO_CACHE
        // },
        {
            name: 'connTemp',        // [user report]  the temp data for user history
            primaryKeys: ['uuid'],   // unique ID generated from bzdb
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            syncMode: BZDB.SyncMode.SYNC_LOCAL
        },
        {
            name: 'connUserTemp',    // [user report] the temp data for unique user
            primaryKeys: ['uid'],   
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            syncMode: BZDB.SyncMode.SYNC_LOCAL
        },
        {
            name: 'connSampleTemp',    // [user report] the temp data for sample data
            primaryKeys: ['sut'],   
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            syncMode: BZDB.SyncMode.SYNC_LOCAL
        },
        {
            name: '_metadata_upgrade',   // [user report] the server name and localIp map of the previous versions; update when do upgrade
            primaryKeys: ['ip'],
            persistMethod: 1, //PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: 1,  //PersistType.PERSIST_TYPE_ARRAY,
            fileName: 'upgradeIpMap.json',
            filePath: '_metadata_upgrade'
        },
        {
            name: 'fileSync',
            primaryKeys: ['relative_path'],
            partitions: {
                relative_path: 1
            },
            // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            // persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,
            // fileName: 'fileSync.json',
            syncFile4Cluster: true
        },
        // {name: 'testde', primaryKeys:['id'], encryptAttrs:['pwd','secret'],
        // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_COMBINED_FILE},
        {
            name: 'testNoCache', 
            primaryKeys:['id'],
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            encryptAttrs:['pwd','secret']
        },
        {
            name: 'testNoCachePart', 
            primaryKeys:['id1', 'id2'],
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            encryptAttrs:['pwd','secret']
        },
        {
            name: 'testPartCol', 
            primaryKeys:['id1', 'id2'],
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            partitions: {
                partcol1: 30,
                partcol2: 30
            },
            encryptAttrs:['pwd','secret']
        }
    ]
};

// if (zoweService.isOnZowe){ // Zowe plugin spesific logics
//     metadata.dataEntities.push({
//         name: 'defaultGroup',
//         primaryKeys: ['id'],
//         persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
//         filePath: '../../com.rs.bzw/defaults/',
//         fileName: 'defaultGroup.json'
//     });
//     metadata.processPooling = 0;
//     metadata.watchDataChanges = 1;
//     metadata.storePath = path.relative(process.cwd(), path.join(zoweService.zoweInstanceDir, './workspace/app-server/ZLUX/pluginStorage/com.rs.bzshared/'));
// } else {  // Zowe plugin doesn't have superAdmin now.
    metadata.dataEntities.push({
        name: 'superAdmin',
        primaryKeys: ['username'],
        persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
        filePath: 'superAdmin',
        fileName: 'spadmahtctidt.json'
    });

    metadata.dataEntities.push({
        name: 'testde',
        primaryKeys: ['id'],
        dataStrategy: BZDB.DataStrategy.NO_CACHE,
        integratyLevel: 3,
        analyzeMethod: 2,
        encryptAttrs:['pwd','secret']
    });
    
    metadata.dataEntities.push({
        name: 'testCluster',
        primaryKeys: ['sut'],
        dataStrategy: BZDB.DataStrategy.NO_CACHE,
        integratyLevel: 3,
        analyzeMethod: 2,
        encryptAttrs:['pwd','secret'],
        partitions: {
            date: 30
        }
    });
// }

// Slave nodes should run in single process mode
// if (clusterState.getInstance().isRunningCluster) metadata.processPooling = 0;
metadata.processPooling = 0;

const bzdb = BZDB.loadDatabase(new BZDB.DatabaseMetadata(metadata));
bzdb.waitLoadReady().then(async () => {
    console.log('BZDB is loaded. Starts testing.')
    // let result = await bzdb.select('meta_node')
    // console.log(result)
    // result = await bzdb.select('meta_peers')
    // console.log(result)

    // result = bzdb.registerCommand('testcmd', async () => {
    //     return 'see the result'
    // })

    // console.time('reload connHistory')
    // console.log('-------------------------------------------------------')
    // console.log('Read partitions for connHistory_3$c9')
    // const parts = await bzdb.partitions('connHistory_3$c9');
    // console.log('Load partitions for connHistory_3$c9')
    // result = await bzdb.writePartitions(parts);
    // console.log(result)
    // console.timeEnd('reload connHistory')

    // console.time('reload configurations')
    // console.log('Read partitions for configurations')
    // const parts1 = await bzdb.partitions('configurations');
    // console.log('Load partitions for configurations')
    // result = await bzdb.writePartitions(parts1);
    // console.log(result)
    // console.timeEnd('reload configurations')


    /*
    // test concurrent txns
    const nodeId = result.data[0].id
    var now = new Date();
    let counter = 0;
    var millisTill = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 58, 0, 0) - now; // Math.round(Math.random()*10)

    if (millisTill > 0){
        setTimeout(async () => {
            setInterval(async () => { 
                counter += 5
                const result = await bzdb.batchTxn([
                    {dataEntityName:"testPartitionCol", action:"UPDATEORINSERT", value:{id1: nodeId, id2: counter, partcol1: counter, partcol2: counter}},
                    {dataEntityName:"testPartitionCol", action:"UPDATEORINSERT", value:{id1: nodeId, id2: counter + 1, partcol1: counter + 1, partcol2: counter + 1}},
                    {dataEntityName:"testPartitionCol", action:"UPDATEORINSERT", value:{id1: nodeId, id2: counter + 2, partcol1: counter + 2, partcol2: counter + 2}},
                    {dataEntityName:"testPartitionCol", action:"UPDATEORINSERT", value:{id1: nodeId, id2: counter + 3, partcol1: counter + 3, partcol2: counter + 3}},
                    {dataEntityName:"testPartitionCol", action:"UPDATEORINSERT", value:{id1: nodeId, id2: counter + 4, partcol1: counter + 4, partcol2: counter + 4}},
                    {dataEntityName:"testPartMem", action:"UPDATEORINSERT", value:{id: nodeId + (counter + 0), partcol1: (counter + 0), partcol2: (counter + 0)}},
                    {dataEntityName:"testPartMem", action:"UPDATEORINSERT", value:{id: nodeId + (counter + 1), partcol1: (counter + 1), partcol2: (counter + 1)}},
                    {dataEntityName:"testPartMem", action:"UPDATEORINSERT", value:{id: nodeId + (counter + 2), partcol1: (counter + 2), partcol2: (counter + 2)}},
                    {dataEntityName:"testPartMem", action:"UPDATEORINSERT", value:{id: nodeId + (counter + 3), partcol1: (counter + 3), partcol2: (counter + 3)}},
                    {dataEntityName:"testPartMem", action:"UPDATEORINSERT", value:{id: nodeId + (counter + 4), partcol1: (counter + 4), partcol2: (counter + 4)}}
                ])
                // console.log('>>>>>>>>>>>>>>>>> Result: ' + util.inspect(result))
                console.log('>>>>>>>>>>>>>>>>> Result: ' + result.status)
                setTimeout(async () => {
                    console.log('meta_block_testPartitionCol: ' + (await bzdb.count('meta_block_testPartitionCol')).rowCount)
                    console.log('meta_block_testPartMem: ' + (await bzdb.count('meta_block_testPartMem')).rowCount)
                }, 500);
            }, 1000 * 60 * 1)
        }, millisTill)
    }
    
    */

    // let bulkData = []
    // let i = 12000
    // for (; i < 14000; i ++){
    //     const val = {id1: i, id2: i, partcol1: i, partcol2: 2, name: i % 20}
    //     bulkData.push(val)
    //     await bzdb.insert('testPartitionCol', val)
    // }
    // await bzdb.bulkLoad('testPartitionCol', bulkData)

    // await bzdb.delete('testPartition')
    // console.log(await bzdb.insert('testPartNoCache', {id1: 1, id2:1, name:'jerry', age: 1}))
    // await bzdb.bulkLoad('testPartition', [{id: 2, name:'tom', age: 1},{id: 3, name:'nancy', age: 1},{id: 4, name:'hebe', age: 2}, {id: 5, name:'hellen', age: 1}])
    // await bzdb.update('testPartition', {name:'nancy'}, {age:2})
    // await bzdb.updateOrInsert('testPartition', {id: 1, age: 2})
    // await bzdb.delete('testPartition', {name:'tom'})
    
    // const proms1 = [bzdb.insert('testde', {id: '1', name: 'Jerry'}), bzdb.delete('testde')]
    // Promise.all(proms1).then((results) => {
    //     console.log(results)
    // })

    // await bzdb.delete('testde')
    // await bzdb.insert('testde', {id: '0', name: '0000'})
    // await bzdb.updateOrInsert('testde', {id: '0', name: '00001'})
    // await bzdb.update('testde', {id: '0'},{id: '0', name: '00002'})
    // await bzdb.bulkLoad('testde', [{id: '0', name: '0000'}])

    // const batchTxnData1 = [
    //     {dataEntityName:"testde", action:"DELETE"},
    //     {dataEntityName:"testde", action:"INSERT", value:{id: '1', name: 'Jimmy'}},
    //     {dataEntityName:"testde", action:"INSERT", value:{id: '2', name: 'Jerry'}},
    //     {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '3', name: 'Nancy'}},
    //     {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '1', name: 'Tom'}},
    //     {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '4', name: 'Jimmy'}},
    //     {dataEntityName:"testde", action:"DELETE", value:{}, options:{filter:{id: '4'}}}
    // ]
    
    // const batchTxnData2 = [
    //     {dataEntityName:"testde", action:"INSERT", value:{id: '5', name: 'Jimmy'}},
    //     {dataEntityName:"testde", action:"DELETE"}
    // ]
    // const proms2 = [bzdb.batchTxn(batchTxnData1), bzdb.batchTxn(batchTxnData2)]
    // Promise.all(proms2).then((results) => {
    //     console.log(results)
    // })

    // const dt1 = new Date()
    // const dt2 = new Date()
    // dt2.setMilliseconds(0)
    // dt2.setSeconds(0)
    // dt2.setMinutes(dt1.getMinutes()+2)
    // setTimeout(async () => {
    //     setInterval(async () => {
    //         await bzdb.bulkLoad('testde', [{id: '0', name: '0000'}, {id: '1', name: '1111'}, {id: '2', name: '2222'}])
    //         await bzdb.updateOrInsert('testde', {id: '3', name: '3333'})
            
    //         const batchTxnData1 = [
    //             {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde1", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde2", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde3", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde4", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde5", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde6", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde7", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde8", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde9", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde10", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //             {dataEntityName:"testde11", action:"UPDATEORINSERT", value:{id: 'a', name: 'Nancy'}},
    //         ]
    //         await bzdb.batchTxn(batchTxnData1)
    //         console.log(await bzdb.getStatus())
    //     }, 5000)
    // }, dt2.getTime() - dt1.getTime())
})

// batchTxn    [{"dataEntityName":"testde", "action":"INSERT", "value":{"id":2}}]