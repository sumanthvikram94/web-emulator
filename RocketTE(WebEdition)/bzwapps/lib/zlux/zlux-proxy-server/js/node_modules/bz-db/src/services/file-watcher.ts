import EventEmitter from 'events'
import * as fs from 'fs'
import { FileService } from './index.js'
// const logger = Logger.getLogger()

const watchList: Map<string, any> = new Map()

export class FileWatcher extends EventEmitter{

    // private _fs_watcher: fs.FSWatcher
    private _dir: string
    private _dir_stats: fs.Stats
    private _prom: Promise<any>
    private _timeout: NodeJS.Timeout
    private _closed = false
    private _fileService: FileService
    private _isFirst = true

    constructor() {
        super()
        this._fileService = new FileService()
    }

    watchDir(dir: string, options: any) {
        this._dir = dir
        // this._dir_stats = fs.statSync(this._dir)
        this._prom = new Promise(async (resolve) => {
            this._timeout = setTimeout(async () => {
                try{
                    // const timemark = Date.now()
                    await this._fileService.clearNFSClientCacheAsync(this._fileService.getDir(this._dir))
                    fs.stat(this._dir, (err, stats) => {
                        if (err) {
                            // console.error(err) // Should be the file/dir not exist. It doesn't matter.
                            return resolve(false)
                        }
                        if (!this._dir_stats || this._dir_stats.mtimeMs !== stats.mtimeMs) {
                            // Logger.logInfo('>>>>>>>>>>>>>>>>>>>> changed fs.stat took ms: ' + (Date.now() - timemark))
                            if (this._isFirst) {
                                this._isFirst = false
                            } else {
                                this.emit('change', this._dir, stats)
                            }
                            this._dir_stats = stats
                            return resolve(true)
                        } else {
                            // Logger.logInfo('>>>>>>>>>>>>>>>>>>>> unchanged fs.stat took ms: ' + (Date.now() - timemark))
                            return resolve(false)
                        }
                    })
                } catch (e) {
                    console.error(e)
                    return resolve(false)
                }
            }, options.interval)
        })
        this._prom.then(() => {
            if (!this._closed) {
                this.watchDir(dir, options)
            } else {
                clearTimeout(this._timeout)
            }
        }).catch((e) => {
            console.error(e)
            if (!this._closed) {
                this.watchDir(dir, options)
            } else {
                clearTimeout(this._timeout)
            }
        })
    }

    // watchDir(dir: string, options: any) {
    //     this._dir = dir
    //     this._fs_watcher = fs.watch(dir, options, (event, filename) => {
    //         const filepath = path.join(this._dir, filename)
    //         fs.stat(filepath, (err, stats) => {
    //             if (err) {
    //                 console.error(err)
    //                 return
    //             }
    //             this.emit(event, filepath, stats)
    //         })
    //     })
    //     console.log('Watching dir: ' + this._dir)
    // }

    public static watch(dir: string, options: any) {
        if (watchList.has(dir)) {
            return watchList.get(dir)
        }
        const watcher = new FileWatcher()
        watcher.watchDir(dir, options)
        watchList.set(dir, watcher)
        return watcher
    }

    close() {
        this._closed = true
    }

    // close() {
    //     this._fs_watcher.close()
    // }
}

