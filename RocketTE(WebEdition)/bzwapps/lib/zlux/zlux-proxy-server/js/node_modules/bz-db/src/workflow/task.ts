import { EventEmitter } from 'events'
import lodash_pkg from 'lodash'
const { now } = lodash_pkg
import { CONFIG } from '../constants/config.js'
import { Logger } from '../services/index.js'
import { Workflow } from './workflow.js'

enum TaskStatus {
    NOT_STARTED = 0,
    READY,
    EXECUTING,
    RESOLVED,
    REJECTED,
    DESTROYED
}

export interface ITaskOptions {
    timeoutMs?: number
    desc?: string
    workflow: Workflow
    parentId?: string
    groups?: string[]
}

class Task extends EventEmitter{

    _id: string
    _parentId: string
    _promise: Promise<any>
    _resolve: Function
    _reject: Function
    _subtasks: Map<string, Task>
    _readyFlag: boolean = false
    _timeoutMs: number
    _timeout:any
    _properties: Map<string, any>
    _function: Function
    _description: string
    _workflow: Workflow
    _status: TaskStatus
    _ts: number
    _groups: string[]

    constructor(id: string, options: ITaskOptions, fun: Function){
        super()
        if (CONFIG.TASK_TRACK_PERF === true){
            this._ts = now()
        }
        this._id = id
        this._timeoutMs = options.timeoutMs || CONFIG.NO_TIMEOUT
        this._description = options.desc || CONFIG.TASK_DESC + id
        this._workflow = options.workflow
        this._parentId = options.parentId || ''
        this._groups = options.groups || []
        this._subtasks = new Map()
        this._properties = new Map()
        this._function = fun
        this._status = TaskStatus.NOT_STARTED
        const promise = new Promise((resolve, reject) => {
            this._resolve = resolve
            this._reject = reject
        })
        this._promise = promise
        Logger.logDebug('Created task: ' + this.description)
        // if(this.parentId && this.parentId !== '' && this._workflow._tasks.has(this.parentId)) return
    }

    destroy(){ 
        if(this.parentId && this.parentId !== '' && this._workflow._tasks.has(this.parentId)) return // destroying child task might cause issue. Leave the child destroy to when parent destroy triggers
        Logger.logDebug('Destroying task: ' + this.description)
        try{
            this.emit('destroy')
            this._subtasks.forEach((val) => {
                val.parentId = ''
                val.destroy()
            })
            if (this.hasTimeout()){
                clearTimeout(this._timeout)
                this._timeoutMs = -1
            }
            this.properties.clear()
            this._subtasks.clear()
            if (this._workflow){
                this._workflow._tasks.delete(this.id)
            }
            this.removeAllListeners()
            this._status = TaskStatus.DESTROYED
        } catch (e) {
            Logger.logWarn(`Error while destroying task ${this.description}, error: ${e.message}`)
        }
    }

    get description(){
        return this._description
    }

    set id(id: string){
        this._id = id
    }

    get id(){
        return this._id
    }

    set parentId(parentId: string){
        this._parentId = parentId
    }

    get parentId(){
        return this._parentId
    }

    // This runs the task function, but it doesn't resolve the promise.
    async execute(){
        this._status = TaskStatus.EXECUTING
        this.setTimeout()
        const result = await this._function()
        await this.emit('executed', result)
        return result
        // return await this.getPromise()
    }

    // Runs the task, and resolves the promise.
    async executeAndResolve(): Promise<any>{
        const result = await this.execute()
        this.resolve(result)
        return result
    }

    /**
     * Execute an event in async way
     * @param eventName 
     * @param handler 
     */
    onAsync(eventName: string, handler: Function){
        // const _this = this
        this.on(eventName, (...args: any[]) => {
            const result = handler(...args)
            if (result.resolve && result.then && result.catch){
                result.then(()=>{
                    Logger.logDebug('Finished async event: ' + eventName)
                }).catch((e:any) => {
                    Logger.logWarn('Error in async event: ' + eventName)
                    Logger.logError(e)
                })
            }
            // const prom = new Promise(async (resolve) => {
            //     const result = await handler(...args)
            // })
        })

        // const prom = new Promise((resolve) => {
        //     _this.on(eventName, (...args: any[]) => {
                
        //         try{
        //             const result = handler(...args)
        //             if (result.resolve){
        //                 resolve(result.resolve())
        //             }
        //         } catch (e){

        //         }
        //     })
        // })
        // return prom
    }
    
    async execSubTasks(){
        this.ready()
        for (const task of Array.from(this._subtasks.values())){
            task.execute()
        }
    }

    async execSubTasks1by1(){
        this.ready()
        for (const task of Array.from(this._subtasks.values())){
            await task.execute()
        }
    }

    setTimeout() {
        if (this.hasTimeout()){
            this._timeout = setTimeout(() => {
                this.emit('timeout')
                this.reject({message: `Task ${this._id + ' - ' + this.description} timed out`})
            }, this._timeoutMs);
        }
    }

    hasTimeout(){
        return this._timeoutMs >= 0
    }

    setProperty(key: string, value: any){
        this._properties.set(key, value)
    }

    getProperty(key: string){
        return this._properties.get(key)
    }

    get properties(){
        return this._properties
    }

    get status(){
        return this._status
    }

    clearProperties(){
        this._properties = new Map()
    }

    getPromise(){
        return this._promise
    }

    resetReadyFlag(){
        this._readyFlag = false
    }

    addSubTask(task:Task){
        if (!this._readyFlag){
            this._subtasks.set(task._id, task)
            task.parentId = this.id
        }
    }

    addSubTasks(tasks: Task[]){
        if (!this._readyFlag){
            for (const task of tasks){
                this._subtasks.set(task._id, task)
                task.parentId = this.id
            }
        }
    }

    getSubTask(id: string){
        return this._subtasks.get(id)
    }

    clearSubTasks(){
        const tempSubtasks = this._subtasks
        this._subtasks = new Map()
        this.resetReadyFlag()
        tempSubtasks.forEach((subtask) => {
            subtask.parentId = ''
            subtask.destroy()
        })
    }

    ready(){
        const _this = this
        this._readyFlag = true
        this._status = TaskStatus.READY
        const proms: Promise<any>[] = []
        if (this._subtasks.size > 0){
            this._subtasks.forEach((task) => {
                proms.push(task.getPromise())
                // task.execute()
            })
        }
        Promise.all(proms).then((val) => {
            Logger.logDebug('promise.all of task: ' + _this.description)
            _this.emit('subTasksDone', val)
            _this.emit('subTasksClose', val)
        }).catch((err) => {
            Logger.logWarn(`Task ${_this.id} encountered error`)
            Logger.logError(err)
            _this.emit('subTasksErr', err)
            _this.emit('subTasksClose', err)
        })
    }

    resolve(result: any){
        if (this.hasTimeout()){
            clearTimeout(this._timeout)
            this._timeoutMs = -1
        }
        this.emit('beforeResolve')
        // if (onBeforeResolve){
        //     onBeforeResolve()
        // }
        this._resolve(result)
        this._status = TaskStatus.RESOLVED
        this.emit('afterResolve')
        this.recordTaskPerf()
        this.emit('finally')
        // if (onAfterResolve){
        //     onAfterResolve()
        // }
    }

    reject(err: any){
        if (this.hasTimeout()){
            clearTimeout(this._timeout)
        }
        // if (onReject){
        //     onReject()
        // }
        this.emit('beforeReject')
        this._reject(err)
        this._status = TaskStatus.REJECTED
        this.emit('afterReject')
        this.recordTaskPerf()
        this.emit('finally')
    }

    recordTaskPerf(){
        if (this._ts !== undefined){
            this._ts = now() - this._ts
            if (this._workflow){
                this._workflow._tasksLifeTime.set(this.id + ' - ' + this.description, this._ts)
            } else {
                Logger.logDebug(`Task ${this.id + ' - ' + this.description}, life time: ${this._ts}`)
            }
        }
    }

}

export {
    Task, TaskStatus
}