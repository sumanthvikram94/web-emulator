/// <reference types="node" />
import { Block, BlockData } from './block.js';
import { Transaction } from './transaction.js';
import { EventEmitter } from 'events';
interface BlockChainData {
    subject: string;
    chain?: any[];
    size?: number;
    txnSize?: number;
    difficulty?: number;
    rootIndex?: number;
}
interface BlockChainStat {
    subject: string;
    size: number;
    keptSize: number;
    txnSize: number;
    lastIndex: number;
    lastTimeStamp: number;
    lastHash: string;
    firstIndex: number;
    firstTimeStamp: number;
    firstHash: string;
}
/**
 * @class BlockChain
 * @description Chain of cryptographic blocks.
 */
declare class BlockChain {
    _pendingBlocks: Map<number, Block>;
    _latestApprovedIdx: number;
    _txn_redundancy_factor: number;
    _event: EventEmitter;
    constructor(data: BlockChainData, txnRedundancyFactor?: number);
    get txn_redundancy_factor(): number;
    set txn_redundancy_factor(length: number);
    toJSONNoBlock(): any;
    toJSON(): any;
    /**
     * @description Create the first (genesis) block.
     * @param {string} [beneficiaryAddr] Address of the beneficiary
     * @return {Block} Genesis block
     * @memberof Blockchain
     */
    createGenesisBlock(): Block;
    generateBlockCandidate(txns: Transaction[], createdBy: string, batchts?: number, competeFactor?: number): Block;
    /**
     * @description Get the blockchain.
     * @return {Block[]} Chain
     * @memberof Blockchain
     */
    get chain(): Block[];
    set chain(blocks: Block[]);
    /**
     * @description Get the hash difficulty.
     * @return {number} Difficulty
     * @memberof Blockchain
     */
    get difficulty(): any;
    get subject(): any;
    /**
     * @description The accumulated count of blockes that have ever been added to the chain
     * @return {number} Size
     * @memberof Blockchain
     */
    get size(): number;
    set size(s: number);
    /**
     * @description The accumulated count of transactions (records in transactions) that has ever been executed
     * @return {number} Size
     * @memberof Blockchain
     */
    get txnSize(): any;
    /**
     * @description Get a specific block.
     * @param {number} index Index
     * @return {Block} Block
     * @memberof Blockchain
     * @throws {TypeError} Index needs to be an integer
     * @throws {OutOfBoundsError} Index out of bounds
     */
    getBlock(index: any): Block;
    replaceBlock(block: Block): void;
    subChain(start: number, end?: number): any[];
    /**
     * @description Get a block with a specific hash.
     * @param {string} hash Hash
     * @return {Block} Block
     * @memberof Blockchain
     */
    getBlockByHash(hash: any): any;
    /**
     * @description Validates the chain.
     * @return {boolean} Validity
     * @memberof Blockchain
     */
    isValid(): boolean;
    /**
     * @description Add blocks.
     * @param {Block[]} blocks blocks
     * @param {Boolean} keepPendingBlockWithSameIdx: whether to keep the pending block with same index as the incoming block.
     * @memberof Blockchain
     */
    addBlocks(blocks: Block[], keepPendingBlockWithSameIdx?: boolean, txnId?: string): Block[];
    /**
     * @description Add a block.
     * @param {Block} block block
     * @param {Boolean} keepPendingBlockWithSameIdx: whether to keep the pending block with same index as the incoming block.
     * @memberof Blockchain
     */
    addBlock(block: Block, keepPendingBlockWithSameIdx?: boolean, txnId?: string, doWithoutTouch?: boolean): Block | undefined;
    onTouch(callback: Function): void;
    /**
     * Wait for the touch event triggered or until the waitms
     * @param waitms
     * @returns
     */
    touched(waitms?: number, txnId?: string): Promise<any>;
    clearPendingBlock(block: Block): void;
    clearPendingBlocks(blocks: Block[]): void;
    /**
     * clear the old blocks, but keep the chain[0] as the genesis block unchanged
     * @returns
     */
    clearHistory(): boolean | undefined;
    claimBlock(block: Block, peerId: string, txnId?: string): any;
    setApproved(block: Block): void;
    updateBlockIdx(block: Block, includesHash?: boolean): void;
    isNoConflict(peerBCS: BlockChainStat): boolean;
    /**
     * Log invalid block as warning.
     * @param block
     * @param validateResult
     */
    private logInvalidBlock;
    /**
     * Validate block index
     * @param block
     * @param validateResult?
     * @returns {isValidIndex: boolean, blockIdx: number, chainSize: number, isValid: boolean}
     */
    private validateBlockIdx;
    /**
     *
     * @param block
     * @param validateResult
     * @returns {isCorrectLink: boolean, isFutureBlock: boolean, isValid: boolean}
     */
    private validateChainLink;
    /**
     *
     * @param block
     * @param validateResult
     * @returns {isBlockValid: boolean, isValid: boolean}
     */
    private blockSelfValidate;
    /**
     * Validate block with local pending blocks
     * @param block
     * @param validateResult
     * @param isApproved
     * @returns
     */
    private validateWithPending;
    /**
     * Validates the given block with the chain.
     * @param block
     * @param isApproved
     * @returns {isValid: boolean, isBlockValid: boolean, }
     */
    validateBlock(block: Block, isApproved?: boolean, peerId?: string, txnId?: string): any;
    get statistics(): BlockChainStat;
    isExistingBlock(block: Block): boolean;
    isFurtureBlock(block: Block): boolean;
    selfValidate(): {
        status: boolean;
        cleanBlocks: BlockData[];
    } | {
        status: boolean;
        cleanBlocks?: undefined;
    };
}
export { BlockChain, BlockChainData, BlockChainStat };
