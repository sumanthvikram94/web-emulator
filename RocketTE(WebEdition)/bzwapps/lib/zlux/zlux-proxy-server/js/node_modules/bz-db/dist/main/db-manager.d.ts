import { DatabaseMetadata, SelectConstraints, BulkLoadConstraints } from './metadata.js';
import { DatabaseInterface, BatchTxnData } from './db-interface.js';
import { IPeerMeta } from '../distribution/node-metadata.js';
import { ILoggerConfig } from '../services/index.js';
import { FileSyncInfo } from './file-sync.js';
import { DEPartitions } from "../internal-db/data-entity.js";
/**
 * Wrapper of all db functions
 */
declare class DbManager implements DatabaseInterface {
    metadata: DatabaseMetadata;
    _worker: any;
    _times: number;
    _regCmd: Map<string, Function>;
    constructor(metadata: DatabaseMetadata);
    /**
     * Starts the db worker
     */
    startWorker(): Promise<void>;
    /**
     * Stops the db work. Mainly used by automatical UT code
     */
    stop(): Promise<void>;
    insert(dataEntityName: string, value: any, isSilent?: boolean): Promise<any>;
    update(dataEntityName: string, filter: any, value: any, constraints?: SelectConstraints, isSilent?: boolean): Promise<any>;
    delete(dataEntityName: string, filter?: any, constraints?: SelectConstraints, isSilent?: boolean): Promise<any>;
    updateOrInsert(dataEntityName: any, value: any, isSilent?: boolean): Promise<any>;
    bulkLoad(dataEntityName: string, values: any[], constraints?: BulkLoadConstraints, isSilent?: boolean): Promise<any>;
    introduceNode(nodeInfo: IPeerMeta): Promise<any>;
    checkStatus(): Promise<any>;
    batchTxn(batchTxnData: BatchTxnData[]): Promise<any>;
    kickNode(nodeInfo: IPeerMeta): Promise<any>;
    select(dataEntityName: string, filter?: Object, options?: Object): Promise<any>;
    partitions(dataEntityName: string): Promise<any>;
    writePartitions(parts: DEPartitions): Promise<any>;
    selectNoPKData(dataEntityName: string): Promise<any>;
    count(dataEntityName: string): Promise<any>;
    waitStatusReady(): Promise<any>;
    waitLoadReady(): Promise<any>;
    getStatus(): Promise<any>;
    printClusterStatus(): Promise<void>;
    refreshDataEntity(dataEntityName: string): Promise<any>;
    checkin(): Promise<any>;
    checkinAll(): Promise<any>;
    forcePullData(peerId: string): Promise<any>;
    pushToPeers(entities: Array<any>, checkInFlag?: boolean): Promise<void>;
    resolvePeers(peerId: string): Promise<void>;
    onEvent(event: string, cb: Function): void;
    changeLogger(config: ILoggerConfig): Promise<any>;
    getFileSyncInfo(filePath: string, isSync4Add?: boolean): Promise<FileSyncInfo>;
    getUID(radix?: number, level?: number): Promise<any>;
    getUIDSync(radix?: number, level?: number): string;
    /**
     * In case you want to execute a function on other peers, you can register the function as a command, then call it with exec(cmd)
     * @param cmd
     * @param execFunction
     * @returns
     */
    registerCommand(cmd: string, execFunction: Function): Promise<any>;
    exec(cmd: string, parames?: any[], peerId?: string): Promise<any>;
    create(schemType: string, dMetaDataObj: object): Promise<any>;
    drop(schemType: string, entiryName: string): Promise<any>;
    getDbSnapshot(): Promise<any>;
    analyzeDataEntity(de: string, isIncludeRows: boolean, isDoHash: boolean): Promise<any>;
    isBusy(): Promise<any>;
    isCrazyBusy(): Promise<any>;
    getNodeAddrs(): Promise<any>;
    yamlStrToJson(yamlStr: string): Promise<any>;
    jsonToYAMLStr(obj: object): Promise<any>;
    yamlParse(yamlStr: string): Promise<any>;
    yamlStringify(obj: object): Promise<any>;
    /**
     * For manually UT only. Take input into terminal, and do the functions.
     * Use TAB to seperate the commands, e.g.:
     * select   testDE
     */
    private listenToStdin;
}
export { DbManager, BatchTxnData };
