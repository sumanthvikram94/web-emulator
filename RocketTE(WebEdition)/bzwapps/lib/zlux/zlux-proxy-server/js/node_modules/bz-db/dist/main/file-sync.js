// BZ-15355, sync file for cluster
// const { Readable } = require('stream');
import { Readable } from 'stream';
// const fs = require('fs');
// const fse = require('fs-extra');
import fse from 'fs-extra';
// const path = require('path');
import path from 'path';
// const mergeStream = require('merge-stream');
import mergeStream from 'merge-stream';
import Queue from 'better-queue';
import { Logger } from '../services/index.js';
export var FileSyncMsgType;
(function (FileSyncMsgType) {
    FileSyncMsgType[FileSyncMsgType["FST_SEND_FILE"] = 1] = "FST_SEND_FILE";
    FileSyncMsgType[FileSyncMsgType["FST_PULL_DONE"] = 2] = "FST_PULL_DONE";
})(FileSyncMsgType || (FileSyncMsgType = {}));
const HEADER_SIZE = 4;
export class FileSync {
    constructor(basePath, runTask) {
        this._basePath = basePath;
        this._textDecoder = new TextDecoder();
        this._queue = new Queue(async (task, callback) => {
            await runTask(task);
            callback();
        }, { afterProcessDelay: 200 }); // a little delay
    }
    pushSendTask(task) {
        Logger.logInfo(`FileSync::pushSendTask, type[${task.fsm.type}], taskId[${task.fsm.taskId}]`);
        this._queue.push(task);
    }
    getFileSyncInfo(filePath, isSync4Add = true) {
        const fsi = {
            abs_path: filePath,
            relative_path: path.relative(this._basePath, filePath).replace(/\\/g, '/'),
            size: 0,
            mtime: '0',
            removed: !isSync4Add,
            timestamp: Date.now()
        };
        if (!path.isAbsolute(filePath)) {
            const msg = `'${filePath}' is not absolute path`;
            Logger.logSevere(`FileSync::getFileSyncInfo, ${msg}`);
            return fsi;
        }
        if (isSync4Add && !fse.existsSync(filePath)) {
            const msg = `'${filePath}' does not exist`;
            Logger.logSevere(`FileSync::getFileSyncInfo, ${msg}`);
            return fsi;
        }
        let stat = null;
        if (isSync4Add) {
            stat = fse.statSync(filePath);
            if (!stat.isFile()) {
                const msg = `'${filePath}' is not a file`;
                Logger.logSevere(`FileSync::getFileSyncInfo, ${msg}`);
                return fsi;
            }
            fsi.size = stat.size;
            // fsi.mtime = stat.mtime;
            fsi.mtime = stat.mtime.toISOString(); // Upgrading, stat.mtime 's toString() value is changed.
        }
        return fsi;
    }
    static isFileSyncMsg(obj) {
        return ('type' in obj
            && 'taskId' in obj
            && 'error' in obj
            && 'fsi' in obj
            && FileSync.isFileSyncInfo(obj.fsi));
    }
    static isFileSyncInfo(obj) {
        return ('abs_path' in obj
            && 'relative_path' in obj
            && 'size' in obj
            && 'mtime' in obj
            && 'removed' in obj);
    }
    getFileSyncMsg4SendFile(fsi, isPullAll = false) {
        const PREFIX_SIZE = 3;
        const chars = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"];
        const prefix = [...Array(PREFIX_SIZE)].map(() => chars[Math.floor(Math.random() * chars.length)]).join('');
        const fsm = {
            taskId: `${prefix}_${path.basename(fsi.relative_path)}`,
            type: FileSyncMsgType.FST_SEND_FILE,
            error: '',
            fsi: fsi
        };
        if (isPullAll) {
            const filePath = path.join(this._basePath, fsi.relative_path);
            fsm.fsi._fsi_realSize4Check = FileSync.getFileSize(filePath); // for pullAll case
        }
        return fsm;
    }
    getFileSyncMsg4PullAll(taskId) {
        const fsi = {
            abs_path: '',
            relative_path: '',
            size: 0,
            mtime: '0',
            removed: false,
            timestamp: Date.now()
        };
        const fsm = {
            taskId: taskId,
            type: FileSyncMsgType.FST_PULL_DONE,
            error: '',
            fsi: fsi
        };
        return fsm;
    }
    static getFileSize(filePath) {
        if (!fse.existsSync(filePath)) {
            return -1;
        }
        try {
            const stat = fse.statSync(filePath);
            if (stat.isFile()) {
                return stat.size;
            }
            else {
                return -1;
            }
        }
        catch (e) {
            Logger.logWarn(`FileSync::getFileSize, ${e.message}`);
            Logger.logError(e);
            return -1;
        }
    }
    // used for BlueZoneDatabase::analyzeDataEntity
    static getRealFileState(baseDir, obj) {
        if (!FileSync.isFileSyncInfo(obj)) {
            return '';
        }
        let prefix = '_fsi';
        const fsi = obj;
        if (fsi.removed) {
            return `${prefix}_removed`;
        }
        else {
            const fsize = FileSync.getFileSize(path.join(baseDir, fsi.relative_path));
            return `${prefix}_size_${fsize}`;
        }
    }
    /**
     * convert number (0 - 65535) to hex string (length = 4)
     * @param val
     * example:
     *    -1 => "0000"
     *     0 => "0000"
     *    32 => "0020"
     * 65535 => "FFFF"
     * 65536 => "0000"
     */
    numToHexString(val) {
        if (val > 65535 || val < 0) {
            return "0000";
        }
        else {
            const pos = -1 * HEADER_SIZE;
            return (val + 0x10000).toString(16).substr(pos).toUpperCase();
        }
    }
    deleteFile(val) {
        const filePath = path.join(this._basePath, val.relative_path);
        if (fse.existsSync(filePath)) {
            try {
                Logger.logInfo(`FileSync::deleteFile, '${filePath}'`);
                fse.unlinkSync(filePath);
                Logger.logInfo(`FileSync::deleteFile, DONE`);
            }
            catch (e) {
                Logger.logSevere(`FileSync::deleteFile, failed`);
                Logger.logError(e);
            }
        }
    }
    getFileReadStream(taskId, val) {
        let fileStream = null;
        const fsiMsg = {
            type: FileSyncMsgType.FST_SEND_FILE,
            taskId: taskId,
            error: '',
            fsi: val
        };
        const filePath = path.join(this._basePath, val.relative_path);
        const fsize4Req = val._fsi_realSize4Check;
        const fsize4Res = FileSync.getFileSize(filePath);
        fsiMsg.fsi._fsi_realSize4Check = fsize4Res;
        /*!fs.existsSync(filePath)*/
        if (fsize4Res < 0) {
            const msg = `file does not exist`;
            Logger.logSevere(`FileSync::getFileReadStream, ${msg}`);
            fsiMsg.error = msg;
        }
        else {
            try {
                if (typeof (fsize4Req) === typeof (1) && fsize4Res === fsize4Req) {
                    // no need transfer file again if the size is the same for pullAll
                    const msg = `file size is the same: req(${fsize4Req}), res(${fsize4Res})`;
                    Logger.logInfo(`FileSync::getFileReadStream, ${msg}`);
                    fsiMsg.error = msg;
                }
                else {
                    fileStream = fse.createReadStream(filePath);
                }
            }
            catch (e) {
                const msg = `createReadStream failed, ${e.message}`;
                Logger.logSevere(`FileSync::getFileReadStream, ${msg}`);
                Logger.logError(e);
                fsiMsg.error = msg;
            }
        }
        const str = JSON.stringify(fsiMsg);
        const data = '' + this.numToHexString(str.length) + str;
        Logger.logInfo(`FileSync::getFileReadStream, send data is =${data}=`);
        const dataStream = Readable.from([data]);
        if (!fsiMsg.error && fileStream) {
            return mergeStream(dataStream, fileStream);
        }
        else {
            return dataStream;
        }
    }
    async writeFileFromStream(source) {
        let header = '';
        let fsiData = '';
        let fsiDataSize = 0;
        let fsiMsg = {};
        let bHasGotHeader = false;
        let bHasGotFsiData = false;
        let writeStream = null;
        const basePath = this._basePath;
        try {
            Logger.logInfo(`FileSync::writeFileFromStream, ==START==`);
            for await (const msg of source) { // source might throw exception...
                let startPos = 0;
                if (!bHasGotHeader) { // parse header to get data size
                    const tmpSize = header.length;
                    if ((tmpSize + msg.length) < HEADER_SIZE) {
                        header += msg.slice().toString();
                        continue;
                    }
                    else {
                        bHasGotHeader = true;
                        const endPos = HEADER_SIZE - tmpSize;
                        // header += msg.slice(0, endPos).toString();
                        header += this._textDecoder.decode(msg.slice(0, endPos));
                        startPos = endPos;
                        fsiDataSize = parseInt(header, 16);
                        Logger.logInfo(`FileSync::writeFileFromStream, fsiDataSize is =${fsiDataSize}=`);
                    }
                }
                if (!bHasGotFsiData) { // parse FileSyncInfo
                    const tmpSize = fsiData.length;
                    if ((tmpSize + msg.length - startPos) < fsiDataSize) {
                        fsiData += msg.slice(startPos).toString();
                        continue;
                    }
                    else {
                        bHasGotFsiData = true;
                        const endPos = startPos + fsiDataSize - tmpSize;
                        // fsiData += msg.slice(startPos, endPos).toString();
                        fsiData += this._textDecoder.decode(msg.slice(startPos, endPos)); // Unit8array 's toString() doesn't decode it automatically.
                        startPos = endPos;
                        Logger.logInfo(`FileSync::writeFileFromStream, fsiData is ${fsiData}`);
                        try {
                            fsiMsg = JSON.parse(fsiData);
                            if (fsiMsg.error) {
                                Logger.logInfo(`FileSync::writeFileFromStream, ==NO-CONTENT== (${fsiMsg.error})`);
                                const fsize = fsiMsg.fsi._fsi_realSize4Check;
                                if (undefined !== fsize && typeof (fsize) === typeof (1) && fsize < 0) {
                                    Logger.logInfo(`FileSync::writeFileFromStream, ==Delete== (${fsize})`);
                                    this.deleteFile(fsiMsg.fsi); // for pullAll case
                                }
                            }
                            else {
                                const filePath = path.join(basePath, fsiMsg.fsi.relative_path);
                                const dir = path.dirname(filePath);
                                fse.ensureDirSync(dir);
                                if (!fse.existsSync(dir)) {
                                    throw Error(`'${dir}' does not exist`);
                                }
                                writeStream = fse.createWriteStream(filePath);
                                writeStream.on('error', (err) => {
                                    Logger.logSevere(`FileSync::writeFileFromStream, ==ERROR== (writeStream error), ${err}`);
                                });
                                writeStream.on('close', () => {
                                    Logger.logInfo(`FileSync::writeFileFromStream, ==CLOSE== (stream)`);
                                });
                            }
                        }
                        catch (e) {
                            Logger.logSevere(`FileSync::writeFileFromStream, ==EXCEPTION== (unknown error), ${e.message}`);
                            Logger.logError(e);
                        }
                    }
                }
                if (bHasGotFsiData && writeStream) { // write to file
                    writeStream.write(msg.slice(startPos));
                }
            }
        }
        catch (e) {
            Logger.logSevere(`FileSync::writeFileFromStream, ==FAIL== (network error?), ${e.message}`);
            Logger.logError(e);
        }
        Logger.logInfo(`FileSync::writeFileFromStream, ==DONE==, relative_path is '${fsiMsg.fsi.relative_path}'`);
        if (writeStream) {
            writeStream.end();
        }
    }
}
