/**
 * Author:    Jerry Gao (jgao@rocketsoftware.com)
 * Create DT: 2020-01-01
 * Desc:      A simple node.js native database
 */
import path from 'path';
import fs from 'fs';
import fse from 'fs-extra';
// import chokidar from 'chokidar';
import _ from 'lodash';
import { FileService } from '../services/files.service.js';
import { FileSync } from '../main/file-sync.js'; // BZ-15355, sync file for cluster
import { DataEntityMetadata, PersistMethod, PersistType, SelectConstraints, DataStrategy, AnalyzeMethod } from '../main/metadata.js'; // ProcessPooling, 
import Queue from 'better-queue';
import { ChangeStatus } from './data-entity.js';
import { Utils, Encryption, FileWatcher, yaml, loggers, LoggerConfigurer, Logger } from '../services/index.js';
const txnLogger = loggers.txn;
const performanceLogger = loggers.performance;
import { CONFIG } from '../constants/config.js';
// Configuration
// const PERSIST_PARTITION_COUNT = 20;
// Constants
// const EDIT = 'edit';
const KEY_CONNECTOR = String.fromCharCode(0x00ff); // use a char with big code can make sure a right sort order for PK+KEY_CONNECTOR+SUBKEY
// Constraints
// const CONSTRAINT_PK_LOWERCASE = 'CST_PK_LC';
const CONSTRAINT_FILE_NAME_ENCODEURI = 'CST_FILE_ENCURI';
const CONSTRAINT_FILE_NAME_PK_LOWERCASE = 'CST_FILE_NAME_PK_LC';
// Messages
const MSG_DATA_ENTITY_EXIST = 'Data entity already exist';
const MSG_DATA_ENTITY_IS_EMPTY = 'Data entity is empty';
const MSG_DATA_ENTITY_IS_NOCACHE = 'Data entity is no cache';
// const MSG_DATA_ENTITY_IS_LOCKED = 'Data entity is locked';
const MSG_DATA_ENTITY_LOAD_SUCCEED = 'Data entity load succeed';
const MSG_DATA_ENTITY_NOT_EXIST = 'Data entity not exist';
// const MSG_DATA_FILTER_NOT_STRING = 'Data filter must be a string';
// const MSG_INDEX_COLUMN_NOT_STRING = 'Index column must be a string';
// const MSG_INDEX_COLUMN_NOT_PROVIDED = 'Index column must be provided';
// const MSG_INDEX_COLUMN_IS_NULL = 'Index column must exist in data';
// const MSG_PARAMETER_IS_NULL = 'Parameters must be provided';
// const MSG_INDEX_NOT_EXIST = 'Index not exist';
// const MSG_PK_ALREADY_EXIST = 'Primary key already exist';
const MSG_DELETE_DATA_NOT_EXIST = 'The data to delete not exist';
const MSG_UPDATE_DATA_NOT_EXIST = 'The data to update not exist';
const MSG_UPDATE_PK = 'Primary key can not be updated';
const MSG_INSERT_DATA_IS_EMPTY = 'Data can not be empty';
const MSG_INSERT_DATA_HAS_NO_KEY = 'Insert data must contain all primary key fields';
const MSG_INSERT_DATA_DUPLICATED = 'Can not insert duplicated PK';
// const MSG_DELETE_SUCCEED = 'Data delete succeed';
// const MSG_PK_NOT_PROVIDED = 'Primary key value to delete not provided';
// const MSG_FILE_NOT_PROVIDED = 'File to delete not provided';
// const MSG_DATA_ENTITY_HAS_NO_PK = 'The data entity do not have PK';
// const MSG_DATA_ENTITY_TYPE_ERROR = 'Data entity type not correct';
// const MSG_PARAM_TYPE_ARRAY = 'Expecting array as parameter';
// const MSG_DATA_ENTITY_HAS_NO_JOINT_KEY = 'The data entities must have key under same folder';
// const MSG_ERROR_DELETE_DATA = 'Error while delete data';
const MSG_WAIT_DATA_RELOAD = 'Database state is out of date. Wait until it\'s refreshed and try again.';
const MSG_FUN_NOT_IMPLEMENTED = 'Function not implemented';
const MSG_DATA_MISSING_REQUIRED_COL = 'Required column missing from data';
const MSG_PARTITION_LOAD_SUCCESS = 'Partition loading succeed';
const MSG_PARTITION_LOAD_FAIL = 'Partition loading failed';
const WATCH_INTERVAL = 2000; // When watching file with wathFile, this is the interval to check file changes
const DE_LOCK_MAX_AGE = 60000; // If a DE lock exist for longer time than this, it can be removed.
// Symbols
const _logger = Symbol();
const _dataEntities = Symbol();
const _util = Symbol();
const _queue = Symbol();
const _execQueue = Symbol();
// const _processPartitionMap = Symbol();
// const _processPool = Symbol();
// const _isPooledProcess = Symbol();
const _databaseMetadata = Symbol();
const _dataEntityMetadata = Symbol();
const _basePath = Symbol();
// const _onLoadReady = Symbol();
// const _eventEmitter = Symbol();
const _resolveLoadReady = Symbol();
const _promLoadReady = Symbol();
const _dataStrategy = Symbol();
const _changedDataEntities = Symbol();
const _promsReload = Symbol();
const _watchedPaths = Symbol();
const _deAnalysisCache = Symbol();
class BlueZoneDatabase {
    constructor(databaseMetadata, processName) {
        // [_flagWatchFile] = false; // If true, it's using fs.watchFile instead of chokidar.watch
        this.name = 'MainProcess';
        // This increases the limitation of emitter to avoid the EventEmitter memory leak error.
        process.setMaxListeners(0);
        this[_logger] = Logger;
        if (processName) {
            this.name = processName;
        }
        LoggerConfigurer.setProcessName(this.name);
        this[_deAnalysisCache] = new Map();
        this[_logger].logDebug('Database metadata: ' + JSON.stringify(databaseMetadata.getMetaData()));
        // this[_eventEmitter] = new EventEmitter;
        this[_promLoadReady] = new Promise((resolve) => {
            this[_resolveLoadReady] = resolve;
        });
        this[_databaseMetadata] = databaseMetadata;
        this[_dataStrategy] = databaseMetadata.getDataStrategy();
        this[_dataEntityMetadata] = databaseMetadata.getDataEntities();
        this[_changedDataEntities] = new Map();
        this[_watchedPaths] = new Map();
        this._logDebug(`${this.name} databaseMetadata: ${JSON.stringify(databaseMetadata.getMetaData())}`);
        // this[_logger] = this._createLogger();
        this[_dataEntities] = {};
        this[_util] = new FileService();
        // this[_processPartitionMap] = new Map();
        // this[_isPooledProcess] = isPooledProcess? isPooledProcess: false;
        // this[_processPool] = this._initProcessPool();
        this[_basePath] = path.resolve(databaseMetadata.getStorePath());
        this[_promsReload] = [];
        this._createQueue();
        this._createExecQueue();
        this._injectInternalDEs();
        Promise.all(this._loadDataEntitys()).then((results) => {
            this._appendExtend().then(() => {
                this[_resolveLoadReady](results);
                // this[_eventEmitter].emit('loadReady', results);
                this[_databaseMetadata].getOnLoadReady()(results);
            });
        });
        // this[_onLoadReady] = databaseMetadata.getOnLoadReady();
    }
    /**
     * Private functions
     */
    _injectInternalDEs() {
        if (this[_databaseMetadata].getDataStrategy() === DataStrategy.FILE_WATCH) {
            this[_databaseMetadata].setDataEntity(new DataEntityMetadata({
                name: 'internal_de_lock',
                primaryKeys: ['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                dataStrategy: DataStrategy.NO_CACHE,
                filePath: '_metadata/internal_de_lock',
                isInternal: true
            }));
        }
    }
    /**
     * Creates the queue for file system operation
     */
    _createQueue() {
        this[_queue] = new Queue(async (options, cb) => {
            const index = Array.isArray(options) ? Math.max(options.length - 1, 0) : 0;
            const node = Array.isArray(options) ? options[index] : options;
            // this._logInfo('Queue length:' + this[_queue].length); // TBD queue length
            const txnId = node.txnId;
            if (node.type === 'add') {
                txnLogger.logDebug('Start addFile; URL is ' + node.option.path, txnId);
                txnLogger.logDebug('addFile detail; URL is ' + node.option.path + ' Data is' + JSON.stringify(node.option.data), txnId);
                //encrypt
                let cloneNode;
                const metadata = node.option.metadata;
                if (metadata && (!metadata.persistType || metadata.persistType && metadata.persistType === PersistType.PERSIST_TYPE_OBJECT)
                    && metadata.encryptAttrs && metadata.encryptAttrs.length > 0) {
                    cloneNode = _.cloneDeep(node);
                    // TBD encrypt fields are not supported when PersistType.PERSIST_TYPE_ARRAY and  PersistType.PERSIST_TYPE_RAW
                    try {
                        if (metadata && metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_COMBINED_FILE) {
                            if (typeof (cloneNode.option.data) === 'string') {
                                cloneNode.option.isBuffer = false;
                                cloneNode.option.data = JSON.parse(cloneNode.option.data);
                            }
                            const keyArr = Object.keys(cloneNode.option.data);
                            if (keyArr && keyArr.length > 0) {
                                for (let i = 0; i < keyArr.length; i++) {
                                    cloneNode.option.data[keyArr[i]] = await Encryption.encrypt(metadata.encryptAttrs, cloneNode.option.data[keyArr[i]]);
                                }
                            }
                        }
                        else { //PersistMethod.PERSIST_METHOD_LIST_FILE
                            cloneNode.option.data = await Encryption.encrypt(metadata.encryptAttrs, cloneNode.option.data);
                        }
                    }
                    catch (e) {
                        txnLogger.logDebug(JSON.stringify(cloneNode.option?.metadata), txnId);
                        txnLogger.logSevere('Failed to encrypt data ' + JSON.stringify(cloneNode.option?.metadata), txnId);
                        txnLogger.logError(e.stack ? e.stack : e.message, txnId);
                    }
                }
                this._addFile(cloneNode ? cloneNode.option : node.option, txnId).then(() => {
                    if (this[_dataStrategy] === DataStrategy.FILE_WATCH && node.option.metadata.dataStrategy !== DataStrategy.NO_CACHE) { // update the futime only for FILE_WATCH
                        // when a file is changed, change it's parent folder to trigger watch event
                        let fd;
                        // const dir = node.option.metadata.fileName && node.option.metadata.fileName.length > 0? node.option.path: this[_util].getDir(node.option.path);
                        const dir = this[_util].getDir(node.option.path);
                        try {
                            // the r+ flag is different on different OS. z/OS should use r instead.
                            txnLogger.logDebug('Change mtime for data entity: ' + node.option.metadata.name + ', path: ' + dir, txnId);
                            fd = fse.openSync(dir, 'r+');
                        }
                        catch (e) {
                            if (e.code === 'EISDIR') {
                                txnLogger.logDebug('r+ is not allowed, use r intead', txnId);
                                fd = fse.openSync(dir, 'r');
                            }
                            else {
                                txnLogger.logDebug(JSON.stringify(node.option), txnId);
                                txnLogger.logSevere('Failed to changing the folder mtime', txnId);
                                txnLogger.logError(e.stack ? e.stack : e.message);
                                cb(e, node);
                                return;
                            }
                        }
                        txnLogger.logDebug('Changing mtime for dir: ' + dir, txnId);
                        const dt = new Date();
                        fse.futimesSync(fd, dt, dt);
                        // BZ-15480, should call closeSync after openSync!
                        // Otherwise we will got "EPERM: operation not permitted" error in special case.
                        // [Case]: for PERSIST_TYPE_RAW file, the extension is usually not .json, so the function "this[_util].getDir"
                        //         will return the file path, if do not call closeSync, "pull" process will first delete this file
                        //         and then bulkload the entity, then "EPERM: operation not permitted" error occurs.
                        // Refer to https://github.com/nodejs/node-v0.x-archive/issues/7164
                        fse.closeSync(fd);
                    }
                    cb(null, node);
                    txnLogger.logDebug('Success:addFile; URL is ' + node.option.path, txnId);
                }, (err) => {
                    cb(err, node);
                    txnLogger.logSevere('Error:addFile; URL is ' + node.option.path + ' Data is' + JSON.stringify(node.option.data), txnId);
                });
            }
            if (node.type === 'delete') {
                txnLogger.logDebug('Start deleteFile; URL is ' + node.option, txnId);
                this._deleteFile(node.option, txnId).then(() => {
                    if (this[_dataStrategy] === DataStrategy.FILE_WATCH) { // update the futime only for FILE_WATCH
                        // when a file is changed, change it's parent folder to trigger watch event
                        let fd;
                        const dir = this[_util].getDir(node.option);
                        try {
                            // the r+ flag is different on different OS. z/OS should use r instead.
                            fd = fse.openSync(dir, 'r+');
                        }
                        catch (e) {
                            if (e.code === 'EISDIR') {
                                txnLogger.logDebug('r+ is not allowed, use r intead', txnId);
                                fd = fse.openSync(dir, 'r');
                            }
                            else {
                                txnLogger.logSevere('Failed to changing the folder mtime', txnId);
                                txnLogger.logError(e.stack ? e.stack : e.message, txnId);
                                cb(e, node);
                                return;
                            }
                        }
                        txnLogger.logDebug('Changing mtime for dir: ' + dir, txnId);
                        const dt = new Date();
                        fse.futimesSync(fd, dt, dt);
                        fse.closeSync(fd); // BZ-15480, should call closeSync after openSync!
                    }
                    cb(null, node);
                    txnLogger.logInfo('Success:deleteFile; URL is ' + node.option, txnId);
                }, (err) => {
                    cb(err, node);
                    txnLogger.logWarn('Error:deleteFile; URL is ' + node.option, txnId);
                });
            }
            if (node.type === 'deleteDir') {
                // this._logInfo('Start deleteDir; URL is '+node.option);
                this._deleteDir(node.option, txnId).then(() => {
                    cb(null, node);
                    // this._logInfo('Success:deleteDir; URL is '+node.option);
                }, (err) => {
                    if (err && err.message === 'dir not eixists.') {
                        cb(null, node);
                    }
                    else {
                        cb(err, node);
                        txnLogger.logSevere('Error:deleteDir; URL is ' + node.option, txnId);
                    }
                });
            }
            // if (node.type === 'sync') {
            //     this._logInfo('Start syncFile; URL is '+node.option.url+'; Method is ' +node.option.method);
            //     this._logDebug('syncFile detail; URL is '+node.option.url+' Data is ' +JSON.stringify(node.option.body));
            //     this._syncFile(node.option).then(() => {
            //         cb(null, node);
            //         this._logInfo('Success:syncFile; URL is '+node.option.url+'; Method is ' +node.option.method);
            //     }, (err:any) => {
            //         cb(err,node);
            //         this._logSevere('Error: syncFile; URL is '+node.option.url+'; Method is ' +node.option.method+' Body is' +JSON.stringify(node.option.body));
            //     });
            // }
        }, { maxRetries: 0, retryDelay: 1000 });
    }
    /**
     * Writes a file
     * @param option : Object includes {path: file path, data: file content}
     * @param isIni
     */
    _addFile(option, txnId) {
        return new Promise((resolve, reject) => {
            try {
                txnLogger.logDebug('addFile detail; URL is ' + option.path + ' Data is' + JSON.stringify(option.data), txnId);
                let str;
                if (option.metadata.persistType === PersistType.PERSIST_TYPE_YAML) {
                    str = yaml.jsonToYAMLStr(option.data);
                }
                else {
                    str = option.isBuffer ? option.data : option.doFormat ? JSON.stringify(option.data, null, 2) : JSON.stringify(option.data); // isIni is bzw2h format file
                }
                if (str.length > 0) {
                    if (this[_dataStrategy] === DataStrategy.FILE_WATCH) {
                        const fileExists = fse.existsSync(option.path);
                        const fileStatCache = this[_util].getFileStat(option.path);
                        // let isWaitDataReload = false;
                        let msg = undefined;
                        if (!fileExists && !fileStatCache) {
                            // Safe to create file
                        }
                        else if (!fileExists && fileStatCache) {
                            msg = 'The file is expected to exist, but not on file systme.';
                            // isWaitDataReload = true;
                        }
                        else if (fileExists && !fileStatCache) {
                            msg = 'The file is not expected to exist, but it exists on file system.';
                            // console.warn('The expected file to create is already created by others');
                            // isWaitDataReload = true;
                        }
                        else if (fileExists && fileStatCache) {
                            const fileStat = fse.statSync(option.path);
                            if (fileStat.mtimeMs !== fileStatCache.mtimeMs) {
                                msg = 'The file has different mtime, it might have been changed on file system.';
                                // console.warn('The expected file to update is changed by others');
                                // isWaitDataReload = true;
                            }
                        }
                        if (msg) { // We should not stop the data write, print a warning is ok.
                            txnLogger.logWarn('Validation for file (' + option.path + ') failed. Possibly data inconsistent. Message: ' + msg, txnId);
                        }
                        // if (isWaitDataReload) {
                        //     return reject({ status: false, message: MSG_WAIT_DATA_RELOAD});
                        // }
                        // Even with above logics, there is still risk that the target file is changed after all the validations.
                        // So, it's not suggested to run BZDB inside node-cluster mode.
                    }
                    fse.outputFile(option.path, str, (err) => {
                        if (err) {
                            txnLogger.logSevere('addFile() failed: ' + JSON.stringify(option), txnId);
                            reject({ status: false, message: err.stack });
                        }
                        else {
                            // record the new file stats after file write.
                            this[_util].setFileStat(option.path, fse.statSync(option.path));
                            txnLogger.logDebug('addFile() succeed for: ' + JSON.stringify(option), txnId);
                            resolve({ status: true, message: 'Create file successed.' });
                        }
                    });
                }
                else {
                    txnLogger.logSevere('addFile() failed: ' + JSON.stringify(option), txnId);
                    reject({ status: false, message: 'addFile() failed.' });
                }
            }
            catch (error) {
                txnLogger.logWarn('add file failed. error stack: ' + error.stack, txnId);
                reject({ status: false, message: 'addFile() failed.' });
            }
        });
    }
    /**
     * Deletes a file
     * @param path : file path
     */
    _deleteFile(path, txnId) {
        return new Promise((resolve, reject) => {
            txnLogger.logDebug('Deleting file: ' + path, txnId);
            if (fse.existsSync(path)) {
                try {
                    if (this[_dataStrategy] === DataStrategy.FILE_WATCH) {
                        // Rejects the file deletion if the file is changed by others.
                        const fileStatCache = this[_util].getFileStat(path);
                        if (fileStatCache) {
                            const fileStat = fse.statSync(path);
                            if (fileStat.mtimeMs !== fileStatCache.mtimeMs) {
                                txnLogger.logWarn('The expected file to delete is changed by others', txnId);
                                return reject({ status: false, message: MSG_WAIT_DATA_RELOAD });
                            }
                        }
                    }
                    // do the deletion if passed validation.
                    fse.unlink(path, (err) => {
                        if (err) {
                            txnLogger.logSevere('deleteFile() failed ' + path, txnId);
                            txnLogger.logSevere('deleteFile error: ' + err.stack, txnId);
                            return reject({ status: false, message: 'deleteFile() failed.' });
                        }
                        else {
                            this[_util].removeFileStat(path);
                            txnLogger.logDebug('deleteFile() successed ' + path, txnId);
                            return resolve({ status: true, message: 'deleteFile() successed.' });
                        }
                    });
                }
                catch (error) {
                    txnLogger.logSevere('deleteFile() failed ' + path, txnId);
                    txnLogger.logSevere('deleteFile error: ' + error.stack, txnId);
                    return reject({ status: false, message: 'deleteFile() failed.' });
                }
            }
            else {
                txnLogger.logWarn('deleteFile(): file not eixists, path is ' + path, txnId);
                return reject({ status: false, message: 'file not eixists.' });
            }
        });
    }
    /**
     * deletes a dir and all dirs and files in it
     * @param path dir path
     */
    _deleteDir(path, txnId) {
        return new Promise((resolve, reject) => {
            // this._logInfo('Deleting dir: '+path);
            if (fse.existsSync(path)) {
                try {
                    // fse.removeSync(path); // it's not safe to delete the dir. So, deleting all the files in dir instead.
                    fse.emptyDir(path, (err) => {
                        if (err) {
                            txnLogger.logSevere('Error while delete all files in dir.', txnId);
                            txnLogger.logError(err, txnId);
                            return reject({ status: false, message: err.message });
                        }
                        else {
                            return resolve({ status: true, message: 'deleteDir() successed.' });
                        }
                    });
                }
                catch (error) {
                    txnLogger.logSevere('deleteDir() failed ' + path, txnId);
                    txnLogger.logSevere('deleteDir error: ' + error.stack, txnId);
                    return reject({ status: false, message: 'deleteDir() failed.' });
                }
            }
            else {
                txnLogger.logWarn('deleteDir(): dir not eixists, path is ' + path, txnId);
                return reject({ status: false, message: 'dir not eixists.' });
            }
        });
    }
    /**
     * Sends file content to a restful API
     * @param option : Object includes {url, method, headers, body}
     */
    // private _syncFile(option:any) {
    //     return new Promise ((resolve, reject) => {
    //         const isHttps=option.url.toLowerCase().indexOf('https')===0?true:false;
    //         let requestOption={
    //             url: option.url,
    //             method: option.method,
    //             headers: option.headers,
    //             body: JSON.stringify(option.body),
    //         }
    //         if(isHttps){
    //             Object.assign(requestOption,{"agentOptions":{"rejectUnauthorized":false}});  //todo, use this to https error CERT_HAS_EXPIRED   
    //         }
    //         request(requestOption, (error: any, response: any)=>{
    //             if (response && response.statusCode !== 201) {
    //                 this._logInfo('syncFile(); response.statusCode '+response.statusCode+'; url is ' +option.url);
    //                 resolve({ status: false, message: response.body, response});
    //             }else if (response && response.statusCode === 201 ){
    //                 this._logInfo('syncFile(); response.statusCode '+response.statusCode+'; url is ' +option.url);
    //                 resolve({ status: true, message: 'sync successed.', response });
    //             }else if (error) { 
    //                 this._logSevere('Error: syncFile(); URL is '+option.url+'error is '+error.stack);
    //                 reject({ status: false, message: error.message });
    //             }
    //         });
    //     });
    // }
    /**
     * Creates the queue for file system operation
     */
    _createExecQueue() {
        const that = this;
        this[_execQueue] = new Queue((options, cb) => {
            if (!options || !options.action) {
                cb({ status: false, message: `Incorrect action: ${options ? options.action : null}` });
                return;
            }
            const action = options.action;
            const txnId = options.options?.txnId;
            txnLogger.logDebug(`Execute action: ${action}`, txnId);
            let prom;
            try {
                const dataEntityName = options.dataEntityName || options.parts.dataEntityName;
                this[_deAnalysisCache].delete(dataEntityName); // Clears the cached data entity analysis when data is changed.
                switch (action) {
                    case 'insert': {
                        prom = that._execInsert(dataEntityName, options.value, options.options);
                        break;
                    }
                    case 'update': {
                        prom = that._execUpdate(dataEntityName, options.filter, options.value, options.options);
                        break;
                    }
                    case 'updateOrInsert': {
                        prom = that._execUpdateOrInsert(dataEntityName, options.value, options.options);
                        break;
                    }
                    case 'delete': {
                        prom = that._execDelete(dataEntityName, options.filter, options.options);
                        break;
                    }
                    case 'bulkLoad': {
                        prom = that._execBulkLoad(dataEntityName, options.values, options.options);
                        break;
                    }
                    case 'writePartitions': {
                        prom = that._doWritePartitions(options.parts);
                        break;
                    }
                    default: {
                        prom = Promise.resolve({ status: false, message: `Not supported action: ${action}` });
                        break;
                    }
                }
                const waitTimeout = setTimeout(() => {
                    txnLogger.logWarn('Execution promise not return in 30 seconds. Data entity: ' + dataEntityName + ', action: ' + action, txnId);
                }, 30000);
                prom.then((result) => {
                    clearTimeout(waitTimeout);
                    cb(null, result);
                }).catch((err) => {
                    clearTimeout(waitTimeout);
                    txnLogger.logWarn('Queue execution error. Data entity: ' + dataEntityName + ', action: ' + action, txnId);
                    cb(err);
                });
            }
            catch (e) {
                cb({ status: false, message: e.message });
            }
        }, { maxRetries: 0, retryDelay: 1000 });
    }
    /**
     * Initiate a file system operation
     * @param option : Object includes {type: add|delete|sync|deleteDir, option}
     */
    _execInQueue(option) {
        return new Promise((resolve, reject) => {
            const txnId = option.options?.txnId;
            const queueDepth = this[_execQueue].length;
            if (queueDepth > 1) {
                performanceLogger.logInfo(`${option.action} for ${option.dataEntityName} waiting in queue. Queue depth: ${queueDepth}`);
            }
            const putQTs = Date.now();
            txnLogger.logDebug('Push exec queue. DE: ' + option.dataEntityName + ', action: ' + option.action + ' ,stats: ' + JSON.stringify(this[_execQueue].getStats()), txnId);
            this[_execQueue].push(option, (err, result) => {
                txnLogger.logDebug('Exec queue callback. DE: ' + option.dataEntityName + ', action: ' + option.action + ' ,stats: ' + JSON.stringify(this[_execQueue].getStats()), txnId);
                const elapsedTime = Date.now() - putQTs;
                if (elapsedTime > 10000) { // The data operation kept for more than 10 seconds
                    performanceLogger.logWarn('Possible slow data operation. DE: ' + option.dataEntityName + ', action: ' + option.action + ', process time: ' + elapsedTime);
                }
                if (err) {
                    txnLogger.logWarn('add queue event: failed. err stack: ' + err.message, txnId);
                    return reject({ status: false, message: err.message });
                }
                else {
                    txnLogger.logDebug('add queue event: finish', txnId);
                    return resolve(result);
                }
            });
        });
    }
    /**
     * Initiate a file system operation
     * @param option : Object includes {type: add|delete|sync|deleteDir, option}
     */
    _addQueue(option) {
        const that = this;
        return new Promise((resolve, reject) => {
            const queueDepth = this[_queue].length;
            if (queueDepth > 1) {
                performanceLogger.logInfo(`${option.type} for ${option.option.path} waiting in queue. Queue depth: ${queueDepth}`);
            }
            const putQTs = Date.now();
            that[_queue].push(option, (err) => {
                const elapsedTime = Date.now() - putQTs;
                if (elapsedTime > 10000) { // The file operation kept for more than 10 seconds
                    performanceLogger.logWarn('Possible slow file operation. action: ' + option.type + ', file: ' + option.option.path + ', process time: ' + elapsedTime);
                }
                if (err) {
                    txnLogger.logWarn('add queue event: failed. err stack: ' + err.message, option.txnId);
                    return reject({ status: false, message: err.message });
                }
                else {
                    txnLogger.logDebug('add queue event: finish', option.txnId);
                    return resolve({ status: true });
                }
            });
        });
    }
    /**
     * Creates the dir and the parent dirs if not exist.
     * @param {string} dirpath
     */
    _createDirsSync(dirpath) {
        fse.ensureDirSync(this[_util].getDir(dirpath));
    }
    /**
     * Output to log on INFO level
     * @param log
     */
    _logInfo(log) {
        const logger = this[_logger];
        logger.logInfo(log);
    }
    _logWarn(log) {
        const logger = this[_logger];
        logger.logWarn(log);
    }
    _logSevere(log) {
        const logger = this[_logger];
        logger.logSevere(log);
    }
    _logDebug(log) {
        const logger = this[_logger];
        logger.logDebug(log);
    }
    _getStoragePath(metadata) {
        const subPath = metadata.filePath ? metadata.filePath : metadata.name;
        return path.join(this[_basePath], subPath);
    }
    _getStorageFullPath(subPath) {
        return path.join(this[_basePath], subPath);
    }
    _loadDataEntitys() {
        this._logDebug(`Starting Rocket Bluezone Database: ${this.name}`);
        const loadStatuses = [];
        this[_dataEntityMetadata].forEach((deMeta) => {
            // if ((this[_databaseMetadata] && this[_databaseMetadata].getProcessPooling() === ProcessPooling.NONE) 
            //     || deMeta.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE){
            const status = this._manage(deMeta);
            loadStatuses.push(status);
            // resourceLoadService.registerResourceLoad(status);
            // } else {
            // const proms: Promise<any>[] = [];
            // for (let i = 0; i < this[_processPartitionMap].size; i ++){
            //     const process = this[_processPool][i];
            //     const prom: Promise<any> = process('_manage', deMeta, false, this[_processPartitionMap].get(i));
            //     // proms.push(prom);
            //     loadStatuses.push(prom);
            // }
            // Promise.all(proms).then((results) => {
            //     const status = Promise.resolve({status: true, results: results})
            //     loadStatuses.push(status);
            //     // this[_eventEmitter].emit('loadReady', results);
            //     // this._setLoadReport(results);
            // });
            // }
        });
        return loadStatuses;
    }
    _initDataObject(metadata) {
        const indexes = {};
        if (metadata.indexes) {
            const indexNames = Object.keys(metadata.indexes);
            indexNames.forEach((idxName) => {
                indexes[idxName] = {};
            });
        }
        const values = [];
        const keys = [];
        const data = {};
        const deObj = {
            metadata: metadata,
            data: data,
            indexes: indexes,
            values: values,
            keys: keys,
            storagePath: this._getStoragePath(metadata),
            isLocked: false
        };
        if ((!metadata.persistMethod || metadata.persistMethod === PersistMethod.PERSIST_METHOD_COMBINED_FILE) && metadata.dataStrategy !== DataStrategy.NO_CACHE) {
            deObj.partitions = new Map();
        }
        return deObj;
    }
    _deleteKeyValueFromObj(obj, keyPath) {
        const keyPathArray = keyPath.split('.');
        let tmpObj = obj;
        for (let i = 0; i < keyPathArray.length - 1; i++) {
            tmpObj = tmpObj[keyPathArray[i]];
        }
        if (tmpObj[keyPathArray[keyPathArray.length - 1]])
            delete tmpObj[keyPathArray[keyPathArray.length - 1]];
    }
    /**
     *
     * @param deObj
     * @param keyPath string. Should be like 'user.userid'
     */
    _getDeepKeyValueStr(deObj, keyPath) {
        const keyPathArray = keyPath.split('.');
        let obj = deObj;
        for (let i = 0; i < keyPathArray.length; i++) {
            const key = keyPathArray[i];
            if (obj[key] === undefined) {
                return null;
            }
            if (i === keyPathArray.length - 1) {
                const value = obj[key];
                if (typeof (value) === 'string') {
                    return value;
                }
                else if (typeof (value) === 'boolean') {
                    return JSON.stringify(value);
                }
                else if (typeof (value) === 'number') {
                    return value.toString();
                }
                else if (value instanceof Date) {
                    return value.getTime().toString();
                }
                else if (value) {
                    return JSON.stringify(value);
                }
            }
            else {
                obj = obj[key];
            }
        }
        return null;
    }
    _setDeepKeyValueStr(deObj, keyPath, data) {
        var keyPathArray = keyPath.split('.');
        var obj = deObj;
        for (var i = 0; i < keyPathArray.length; i++) {
            var key = keyPathArray[i];
            if (i === keyPathArray.length - 1) {
                var value = obj[key];
                if (!value || typeof (value) !== 'string') {
                    obj[key] = data;
                }
            }
            else {
                obj[key] = {};
                obj = obj[key];
            }
        }
    }
    ;
    // private _getDeepKeyValue(dataObj: Object, keyPath:string): string|null {
    //     const keyPathArray = keyPath.split('.');
    //     let obj = dataObj;
    //     for (let i=0; i< keyPathArray.length; i++){
    //         const key = keyPathArray[i];
    //         if (!obj[key]){
    //             return null;
    //         }
    //         if (i === keyPathArray.length - 1) {
    //             return obj[key];
    //         } else {
    //             obj = obj[key];
    //         }
    //     }
    //     return null;
    // }
    _deletePKValue(value, metadata) {
        const pks = metadata.primaryKeys;
        pks.forEach((pk) => {
            this._deleteKeyValueFromObj(value, pk);
        });
    }
    _getPKValue(value, metadata) {
        let combPkValue = this._getCombFieldsValue(value, metadata.primaryKeys);
        return combPkValue;
    }
    _getCombFieldsValue(value, fields) {
        let combValue = '';
        if (fields) {
            fields.forEach((field) => {
                let fieldValue = this._getDeepKeyValueStr(value, field);
                fieldValue = fieldValue ? fieldValue : '___NULL___';
                combValue = combValue === '' ? fieldValue : combValue + KEY_CONNECTOR + fieldValue;
            });
        }
        else {
            // Should raise exception, this should never happen.
        }
        return combValue;
    }
    _loadPartitions(metadata, partitions) {
        // Init data entity object
        const deObj = this._initDataObject(metadata);
        this._createDirsSync(deObj.storagePath);
        const partMap = new Map();
        deObj['partitions'] = partMap;
        if (metadata.primaryKeys) {
            partitions.forEach((partition, key) => {
                if (partition) {
                    // add primary key if no it in current data. 
                    Object.keys(partition).forEach(key => {
                        if (!this._getDeepKeyValueStr(partition[key], metadata.primaryKeys[0])) {
                            this._setDeepKeyValueStr(partition[key], metadata.primaryKeys[0], key);
                        }
                    });
                    deObj.keys = deObj.keys.concat(Object.keys(partition));
                    deObj.values = deObj.values.concat(Object.values(partition));
                    deObj.data = Object.assign(deObj.data, partition);
                }
                partMap.set(key, partition);
            });
            deObj.values.forEach((value) => {
                this._buildIndexes(deObj, value);
            });
        }
        else {
            // should never happen
        }
        return deObj;
    }
    _buildIndexes(dataEntity, value) {
        if (dataEntity.metadata.indexes) {
            const indexNames = Object.keys(dataEntity.metadata.indexes);
            indexNames.forEach((idxName) => {
                let idxObj = dataEntity.indexes[idxName];
                if (!idxObj) {
                    idxObj = {};
                    dataEntity.indexes[idxName] = idxObj;
                }
                const idxKeyVal = this._getCombFieldsValue(value, dataEntity.metadata.indexes[idxName]);
                if (!idxObj[idxKeyVal]) {
                    idxObj[idxKeyVal] = [];
                }
                idxObj[idxKeyVal].push(value);
            });
        }
    }
    _loadValues(metadata, values) {
        // Init data entity object
        const deObj = this._initDataObject(metadata);
        this._createDirsSync(deObj.storagePath);
        // build data entity object
        // deObj.values = values; // what's the order of values? 
        if (metadata.primaryKeys && values && Array.isArray(values)) {
            values.forEach((value) => {
                const keyVal = this._getPKValue(value, metadata);
                deObj.keys.push(keyVal);
                deObj.values.push(value);
                deObj.data[keyVal] = value;
                this._buildIndexes(deObj, value);
            });
        }
        else {
            // should never happen
        }
        return deObj;
    }
    // private _initProcessPool(): any[] | null {
    //     const isPooledProcess = this[_isPooledProcess];
    //     if (!isPooledProcess && this[_databaseMetadata] && this[_databaseMetadata].getProcessPooling() !== ProcessPooling.NONE) {
    //         let processCount: ProcessPooling = this[_databaseMetadata].getProcessPooling();
    //         if (processCount === ProcessPooling.AUTO){
    //             processCount = Math.min(os.cpus().length - 1, 4); // set a high water mark for process count.
    //         }
    //         if (!processCount) processCount = 1;
    //         for (let i = 0; i < PERSIST_PARTITION_COUNT; i++){
    //             let processId = i % processCount;
    //             let partsOfProcess = this[_processPartitionMap].get(processId);
    //             if (! partsOfProcess){
    //                 const arr: number[] = [];
    //                 this[_processPartitionMap].set(processId, arr);
    //                 partsOfProcess = arr;
    //             }
    //             partsOfProcess.push(i);
    //         }
    //         const processPool: any[] = [];
    //         for (let i = 0; i < processCount; i ++){
    //             const processFunction = poolProvider.prepare((context:any) => {
    //                 const id = context.processId;
    //                 const  { BlueZoneDatabase } = require('./bluezone-database');
    //                 const  { DatabaseMetadata } = require('./metadata');
    //                 // console.log('context.metadata: ' + JSON.stringify(context.metadata));
    //                 const metadata = new DatabaseMetadata(context.metadata);
    //                 const bzdb = new BlueZoneDatabase(metadata, true, `process#${id}`);
    //                 bzdb._logInfo(`Initiate bzdb process id: ${id}`);
    //                 // bzdb._loadDataEntitys(context.partitions);
    //                 return function(functionName: string, param1?:any, param2?: any, param3?:any, param4?:any, param5?:any) {
    //                     // console.log(`process# ${id} executes function ${functionName}`);
    //                     return new Promise<any>((resolve) => {
    //                         if (!bzdb[functionName]){
    //                             resolve({status: false, message: `Function "${functionName}" not exist`});
    //                         }
    //                         // const func = bzdb[functionName];
    //                         const funcResult = bzdb[functionName](param1, param2, param3, param4, param5);
    //                         if (funcResult && funcResult.then){
    //                             funcResult.then((result:any) => {
    //                                 // console.log(`process# ${id} executes function ${functionName}, result is: ${JSON.stringify(result)}`);
    //                                 resolve(result);
    //                             }).catch((err:any) => {
    //                                 resolve({status: false, message: err.stack? err.stack: err.message});
    //                             });
    //                         }else {
    //                             resolve(funcResult? funcResult : true);
    //                         }
    //                     });
    //                 }
    //             }, { metadata: this[_databaseMetadata].getMetaData(), processId: i });
    //             processPool[i] = processFunction;
    //         }
    //         return processPool;
    //     } else {
    //         return null;
    //     }
    // }
    // private _mergeResults(results: any[]): any {
    //     let mergedResult: any;
    //     results.forEach((result:any) => {
    //         if (!mergedResult) {
    //             mergedResult = result;
    //         } else {
    //             if (result.rowCount && result.rowCount > 0){
    //                 if (!mergedResult.rowCount) mergedResult.rowCount = 0;
    //                 mergedResult.rowCount += result.rowCount;
    //             }
    //             if (result.dataEntityName){
    //                 mergedResult.dataEntityName = result.dataEntityName;
    //             }
    //             if (result.results){
    //                 if (!mergedResult.results) mergedResult.results = [];
    //                 mergedResult.results = mergedResult.results.concat(result.results);
    //             }
    //             if (result.data){
    //                 if (!mergedResult.data) mergedResult.data = [];
    //                 mergedResult.data = mergedResult.data.concat(result.data);
    //             }
    //             if (result.message){
    //                 mergedResult.message = result.message;
    //             }
    //         }
    //     });
    //     return mergedResult;
    // }
    // private _forwardToProcesses(functionName: string, dataEntityName: string, param1?: any, param2?: any, param3?: any, param4?: any): Promise<any> {
    //     return new Promise<any> ((resolve) => {
    //         const processes = this[_processPool];
    //         const proms: Promise<any>[] = [];
    //         processes.forEach((process:any) => {
    //             const prom:Promise<any> = process(functionName, dataEntityName, param1, param2, param3, param4);
    //             proms.push(prom);
    //         });
    //         Promise.all(proms).then((results: any) => {
    //             resolve(this._mergeResults(results));
    //         })
    //     });
    // }
    _replaceDE(dataEntityName, newDataEntity) {
        let oldDE = this[_dataEntities][dataEntityName];
        this[_dataEntities][dataEntityName] = newDataEntity;
        this._logDebug('Data entity ' + dataEntityName + 'is replaced. Old DE: ' + JSON.stringify(oldDE) + ', new DE: ' + JSON.stringify(newDataEntity));
        oldDE = undefined;
    }
    /**
     * Loads data from file into memory for a given data entity
     * @param metadata
     * @param isRefresh - Whether it's loading while db starts or it's a reload. The action will be different.
     * @param partitions - In multi-process mode, one process only manage part of the partitions.
     */
    _manage(metadata, isRefresh, partitions) {
        return new Promise((resolve) => {
            // Validations
            this._logDebug('_manage');
            this._logDebug('metadata: ' + JSON.stringify(metadata));
            this._logDebug('isRefresh: ' + isRefresh);
            this._logDebug('partitions: ' + partitions);
            let dataEntityName = metadata.name;
            const dataEntities = this[_dataEntities];
            if (dataEntities[dataEntityName] && !isRefresh) { // Avoid manage same data entity multiple times
                return resolve({ dataEntity: dataEntityName, status: 'failed', message: MSG_DATA_ENTITY_EXIST });
            }
            // Load data
            let rowCount = 0;
            //no cache
            if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                this._replaceDE(dataEntityName, this._initDataObject(metadata));
                return resolve({ dataEntity: dataEntityName, status: 'success', message: MSG_DATA_ENTITY_IS_NOCACHE, rowCount: rowCount });
            }
            this._persistRead(metadata, partitions).then((values) => {
                const filePath = this._getStoragePath(metadata);
                this._logInfo('Loading data entity: ' + metadata.name);
                if (!values || values.size === 0) {
                    this._replaceDE(dataEntityName, this._initDataObject(metadata));
                    this._watchPath(filePath, metadata); // Watch for changes in the path.
                    return resolve({ dataEntity: dataEntityName, status: 'success', message: MSG_DATA_ENTITY_IS_EMPTY, rowCount: rowCount });
                }
                let newDe;
                if (metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                    if (!values.values) { // The returned values is not a map. This could happen when the data file is empty for any reason.
                        Logger.logWarn('Abnormal data for ' + dataEntityName + ', values: ' + JSON.stringify(values));
                        this._replaceDE(dataEntityName, this._loadValues(metadata, []));
                    }
                    else {
                        newDe = this._loadValues(metadata, Array.from(values.values())); // Here is no partitions, just use the values
                    }
                }
                else { // 
                    newDe = this._loadPartitions(metadata, values);
                }
                if (partitions && partitions.length > 0)
                    dataEntities[dataEntityName]['managedPartitions'] = partitions;
                if (isRefresh) {
                    // this[_changedDataEntities].delete(metadata.name); // Removed. This is handled in _execWatchEvent()
                    this[_deAnalysisCache].delete(metadata.name); // Remove the cached de analysis data
                }
                this._replaceDE(dataEntityName, newDe); // Replace the data entity with the new one.
                this._logDebug('Data entity load complete : ' + metadata.name);
                // values.forEach((value) => {
                //     rowCount += Object.keys(value).length;
                // })
                this._watchPath(filePath, metadata); // Watch for changes in the path.
                resolve({ dataEntity: dataEntityName, status: 'success', message: MSG_DATA_ENTITY_LOAD_SUCCEED, filesCount: values.size });
                if (metadata.name === 'userInfo' || metadata.name === 'group') {
                    // console.log('DEBUG: DATA ENTITY: ' + JSON.stringify(dataEntities[dataEntityName], null ,2));
                }
            }).catch(err => {
                console.error(err);
                return resolve({ dataEntity: dataEntityName, status: 'failed', message: err.stack ? err.stack : err.message });
            });
        });
    }
    _getMatchedIndex(metadata, filter) {
        if (!metadata.indexes) {
            return null;
        }
        const filterKeys = Object.keys(filter);
        const idxNames = Object.keys(metadata.indexes);
        if (idxNames.length === 0 || filterKeys.length === 0) {
            return null;
        }
        const possibleIdxes = [];
        for (let idxName of idxNames) {
            const idxKeys = metadata.indexes[idxName];
            let doBreak = false;
            for (let idxKey of idxKeys) {
                if (!filterKeys.includes(idxKey)) {
                    doBreak = true;
                    break;
                }
            }
            if (doBreak)
                break;
            if (idxKeys.length > possibleIdxes.length) {
                // Records the index which is included in filter keys, and order by count of matched keys
                const strArr = [];
                possibleIdxes[idxKeys.length] = strArr;
            }
            possibleIdxes[idxKeys.length].push(idxName);
        }
        // The included index with max length is the best match. 
        // If multiple indexes best matched, these indexes must be the same.
        return possibleIdxes.length === 0 ? null : possibleIdxes[possibleIdxes.length - 1][0];
    }
    /**
     *
     * @param filter
     * @param pks
     * @returns boolean, whether the filter keys includes the primaryKeys
     */
    _arrayIncludes(parentArray, childArray) {
        if (!childArray || !parentArray) {
            return false;
        }
        if (parentArray.length === 0 || childArray.length === 0) {
            return false;
        }
        for (let element of childArray) {
            if (!parentArray.includes(element)) {
                return false;
            }
        }
        return true;
    }
    _arrayMinus(arr1, arr2) {
        return arr1.filter(ele => !arr2.includes(ele));
    }
    _searchDeepKeysArr(valueArr, filter, constraints) {
        if (!filter) {
            return valueArr;
        }
        const filterKeys = Object.keys(filter);
        if (!filterKeys || filterKeys.length === 0) {
            return valueArr;
        }
        const resultArr = [];
        for (let val of valueArr) {
            let isMatch = true;
            for (let key of filterKeys) {
                const keyVal = this._getDeepKeyValueStr(val, key);
                if (!keyVal) { // There seems no issue, the value is changed to string.
                    isMatch = false;
                    break;
                }
                if (constraints && constraints.ignoreCaseFields && constraints.ignoreCaseFields.includes(key)) {
                    if (keyVal.toLowerCase() !== filter[key]) {
                        isMatch = false;
                        break;
                    }
                }
                else if (keyVal !== filter[key]) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                resultArr.push(val);
            }
        }
        return resultArr;
    }
    _getSubObj(dataObj, keys) {
        const subObj = {};
        keys.forEach(key => {
            subObj[key] = dataObj[key];
        });
        return subObj;
    }
    /**
     *
     * @param dataEntity
     * @param filter , this should be an object like: {userId: ['a', 'b', 'c'], sessionId: 's1'} or {userId: 'a', sessionId: 's1'}
    */
    _filter(dataEntity, filter, constraints) {
        // If filter is empty, return full values
        if (!filter || typeof (filter) !== 'object') {
            return dataEntity.values;
        }
        const filterKeys = Object.keys(filter) || [];
        if (filterKeys.length === 0) {
            return dataEntity.values;
        }
        const filters = [];
        const data = {};
        filterKeys.forEach(k => {
            if (Array.isArray(filter[k])) {
                data[k] = filter[k];
            }
        });
        // only support Object.keys(data).length = 1, filter one property is array
        if (Object.keys(data).length === 1) {
            const key = Object.keys(data)[0];
            data[key].forEach((d) => {
                const newFilter = _.clone(filter);
                newFilter[key] = d;
                const result = this._filterByOneRecord(dataEntity, newFilter, constraints) || [];
                filters.push(...result);
            });
            return filters;
        }
        else {
            return this._filterByOneRecord(dataEntity, filter, constraints);
        }
    }
    /**
     *
     * @param dataEntity
     * @param filter , this should be an object like: {userId: 'a', sessionId: 's1'}
     */
    _filterByOneRecord(dataEntity, filter, constraints) {
        const filterKeys = Object.keys(filter);
        const metadata = dataEntity.metadata;
        const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
        const isPersistListFileArr = metadata.persistType && metadata.persistType === PersistType.PERSIST_TYPE_ARRAY;
        if (isPersistListFile && isPersistListFileArr) {
            const data = dataEntity.values[0] || [];
            const keys = Object.keys(filter) || [];
            const values = Object.values(filter) || [];
            let result = _.clone(data);
            keys.forEach((k, i) => {
                result = _.clone(result.filter((d) => d[k] === values[i]) || []);
            });
            return result;
        }
        else if (constraints && constraints.ignoreCaseFields) { // JERRY
            this._constraintIgnoreCaseFields(constraints.ignoreCaseFields, filter);
        }
        else {
            // Below code has a bug, when the filter is not based on Primary key, the filterKeyVal will include __NULL__
            // const filterKeyVal = this._getCombFieldsValue(filter, dataEntity.metadata.primaryKeys);
            // // if the filter data is not managed by current process, return []
            // // but this is not suitable for ignoreCaseConstraint.
            // if (dataEntity.managedPartitions && dataEntity.managedPartitions.length > 0){
            //     const partitionNum = this._genStrHashcode(filterKeyVal) % PERSIST_PARTITION_COUNT;
            //     console.log('!!!!!')
            //     this._logInfo(`${this.name} managedPartitions: ${dataEntity.managedPartitions}`);
            //     this._logInfo(`${this.name} filterKeyVal: ${filterKeyVal}`);
            //     this._logInfo(`${this.name} filter partitionNum: ${partitionNum}`);
            //     if (! dataEntity.managedPartitions.includes(partitionNum)){
            //         return [];
            //     }
            // }
        }
        // The filter is based on primary key
        if (this._arrayIncludes(filterKeys, dataEntity.metadata.primaryKeys)) {
            const pkCount = dataEntity.metadata.primaryKeys.length;
            let pkData;
            if (constraints && constraints.ignoreCaseFields
                && this._arrayIncludes(constraints.ignoreCaseFields, dataEntity.metadata.primaryKeys)) {
                const filterKeyVal = this._getCombFieldsValue(filter, dataEntity.metadata.primaryKeys);
                for (let i = 0; i < dataEntity.keys.length; i++) {
                    const keyVal = dataEntity.keys[i];
                    if (keyVal.toLowerCase() === filterKeyVal) {
                        pkData = dataEntity.values[i];
                        break;
                    }
                }
            }
            else {
                pkData = dataEntity.data[this._getCombFieldsValue(filter, dataEntity.metadata.primaryKeys)];
            }
            if (filterKeys.length > pkCount) { // If there is more filter than PK
                const otherKeys = this._arrayMinus(filterKeys, dataEntity.metadata.primaryKeys);
                for (let key of otherKeys) {
                    // PK is already identical, if the further filter not matched, then return null;
                    let keyVal = this._getDeepKeyValueStr(pkData, key);
                    if (!keyVal)
                        return null;
                    if (constraints && constraints.ignoreCaseFields
                        && constraints.ignoreCaseFields.includes(key)) {
                        if (keyVal.toLowerCase() !== filter[key]) {
                            return null;
                        }
                    }
                    else if (keyVal !== filter[key]) {
                        return null;
                    }
                }
            }
            return pkData ? [pkData] : [];
        }
        const matchedIndexName = this._getMatchedIndex(dataEntity.metadata, filter);
        // The filter is based on index
        if (matchedIndexName) {
            const idx = dataEntity.metadata.indexes[matchedIndexName];
            const filterVal = this._getCombFieldsValue(filter, idx);
            let idxDataArr = null;
            if (constraints && constraints.ignoreCaseFields
                && this._arrayIncludes(constraints.ignoreCaseFields, idx)) {
                const idxKeyVals = Object.keys(dataEntity.indexes[matchedIndexName]);
                for (let idxKeyVal of idxKeyVals) {
                    if (idxKeyVal.toLowerCase() === filterVal) {
                        idxDataArr = dataEntity.indexes[matchedIndexName][idxKeyVal];
                    }
                }
            }
            else {
                idxDataArr = dataEntity.indexes[matchedIndexName][this._getCombFieldsValue(filter, idx)];
            }
            if (!idxDataArr) {
                return null;
            }
            if (filterKeys.length > idx.length) {
                const otherKeys = this._arrayMinus(filterKeys, idx);
                const subFilter = this._getSubObj(filter, otherKeys);
                return this._searchDeepKeysArr(idxDataArr, subFilter, constraints);
            }
            return idxDataArr;
        }
        return this._searchDeepKeysArr(dataEntity.values, filter, constraints);
    }
    _deleteAll(dataEntity, options) {
        return new Promise((resolve) => {
            const txnId = options?.txnId;
            txnLogger.logDebug(`${this.name} delete all`, txnId);
            if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                let emptyDe = this._initDataObject(dataEntity.metadata);
                emptyDe = Object.assign(dataEntity, emptyDe);
                dataEntity = emptyDe;
                this[_dataEntities][dataEntity.metadata.name] = emptyDe;
                return resolve({ status: true });
            }
            let option = { option: dataEntity.storagePath, type: 'deleteDir', txnId };
            if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                if (dataEntity.metadata.fileName) {
                    const fileName = this._getPathFromPK(dataEntity, '');
                    option = { option: fileName, type: 'delete', txnId };
                }
            }
            this._addQueue(option).then(result => {
                let emptyDe = this._initDataObject(dataEntity.metadata);
                // emptyDe.isLocked = true;
                emptyDe = Object.assign(dataEntity, emptyDe);
                emptyDe.partitions = new Map();
                dataEntity = emptyDe;
                this[_dataEntities][dataEntity.metadata.name] = emptyDe;
                if (!result)
                    resolve({ status: true });
                else
                    resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    /**
     * This will delete the data, keys, values. But not including indexes.
     * @param dataEntity
     * @param pkVal
     */
    _deleteDKVByPk(dataEntity, pkVal) {
        this._logDebug(`deleting data, keys, values for pk: ${pkVal}`);
        delete dataEntity.data[pkVal];
        const keyIdx = dataEntity.keys.indexOf(pkVal);
        // delete dataEntity.keys[keyIdx];
        dataEntity.keys.splice(keyIdx, 1);
        // delete dataEntity.values[keyIdx];
        dataEntity.values.splice(keyIdx, 1);
    }
    _deleteFromIndexes(dataEntity, value) {
        const metadata = dataEntity.metadata;
        if (!metadata.indexes)
            return;
        const idxNames = Object.keys(metadata.indexes);
        idxNames.forEach((idxName) => {
            const indexKeyVal = this._getCombFieldsValue(value, metadata.indexes[idxName]);
            let indexValues = dataEntity.indexes[idxName][indexKeyVal];
            if (!indexValues)
                return;
            for (let i = 0; i < indexValues.length; i++) {
                const idxedPK = this._getPKValue(indexValues[i], metadata);
                const valPk = this._getPKValue(value, metadata);
                if (idxedPK === valPk) {
                    // delete indexValues[i];
                    this._logDebug(`deleting value from index: ${idxName}`);
                    indexValues.splice(i, 1);
                    break;
                }
            }
            if (dataEntity.indexes[idxName][indexKeyVal].length === 0) {
                this._logDebug(`deleting index key ${indexKeyVal} from index: ${idxName}`);
                delete dataEntity.indexes[idxName][indexKeyVal];
            }
        });
    }
    _persistDelete(dataEntity, deleteValues, filter, txnId) {
        return new Promise(async (resolve) => {
            let persistMethod = dataEntity.metadata.persistMethod;
            if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                const proms = [];
                let persistType = dataEntity.metadata.persistType;
                if (persistType && persistType === PersistType.PERSIST_TYPE_ARRAY) {
                    const key = dataEntity.metadata.primaryKeys[0];
                    // const dkey = Object.keys(dataEntity.data)[0] || '___NULL___';
                    deleteValues.forEach(val => {
                        const vIndex = dataEntity.values[0].findIndex((d) => d[key] === val[key]);
                        // const dIndex = dataEntity.data[dkey].findIndex((d:any) => d[key] === val[key]);
                        dataEntity.values[0].splice(vIndex, 1);
                        // dataEntity.data[dkey].splice(dIndex, 1); // dataEntity.data[dkey] is the same object as dataEntity.values[0]. Shouldn't delete again.
                        const pkVal = this._getPKValue(val, dataEntity.metadata);
                        const filePath = this._getPathFromPK(dataEntity, pkVal);
                        const option = {
                            data: dataEntity.values[0],
                            path: filePath,
                            metadata: dataEntity.metadata
                        };
                        const prom = this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                            if (result && result.status) {
                                return { status: true, result: result };
                            }
                            else {
                                return { status: false };
                            }
                        }).catch(err => {
                            const errMsg = err.stack ? err.stack : err.message;
                            txnLogger.logWarn('Partition file write error: ' + errMsg, txnId);
                            return { status: false, message: errMsg };
                        });
                        proms.push(prom);
                    });
                }
                else if (dataEntity.metadata.dataStrategy !== DataStrategy.NO_CACHE || // With cache
                    (dataEntity.metadata.dataStrategy === DataStrategy.NO_CACHE && !dataEntity.metadata.isNoPK)) { // or NO_CACHE with PK
                    deleteValues.forEach((value) => {
                        const filePath = this._getPathFromPK(dataEntity, this._getPKValue(value, dataEntity.metadata));
                        const prom = this._addQueue({ option: filePath, type: 'delete', txnId }).then((result) => {
                            if (dataEntity.metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                                this._deleteDKVByPk(dataEntity, this._getPKValue(value, dataEntity.metadata));
                                this._deleteFromIndexes(dataEntity, value);
                            }
                            if (!result)
                                return { status: true };
                            else
                                return result;
                        }).catch(err => {
                            return err;
                        });
                        proms.push(prom);
                    });
                }
                else {
                    if (filter && !_.isEmpty(filter)) { // JERRY, delete for no cache + no PK, rely on file name.
                        let metadata = dataEntity.metadata;
                        let fileName = metadata.fileName || "";
                        let mergedMetadata = this._mergeFilterIntoMetaData(metadata, filter);
                        fileName = metadata.fileName || mergedMetadata.fileName || '';
                        if (!!fileName) {
                            const filePath = path.join(this._getStorageFullPath(metadata.filePath), fileName);
                            const prom = this._addQueue({ option: filePath, type: 'delete', txnId }).then((result) => {
                                if (!result)
                                    return { status: true };
                                else
                                    return result;
                            }).catch(err => {
                                return err;
                            });
                            proms.push(prom);
                        }
                    }
                }
                Promise.all(proms).then(results => {
                    resolve({ status: true, results: results });
                }, reason => {
                    resolve({ status: false, reason: reason });
                });
            }
            else { // Partitioned
                const clonePartitions = {};
                const metadata = dataEntity.metadata;
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) { // No cache data, use filter to delete
                    if (filter === undefined) {
                        throw 'Filter is undefined'; // This shouldn't happen. filter is already validated before calling this function.
                    }
                    const partitionNums = this._calFilterParitions(metadata, filter); // filter should not be emtpy object
                    let isDataFound = false;
                    for await (const partitionNum of partitionNums) {
                        const filePath = this._getPathFromPK(dataEntity, partitionNum + '');
                        if (!fse.existsSync(filePath))
                            continue;
                        const partData = await this[_util].readJSON(filePath);
                        if (_.isEmpty(partData))
                            continue;
                        if (this._isAllPKColIncluded(filter, metadata)) { // deleting with PK
                            const tempFilters = Utils.splitObject(filter);
                            tempFilters.forEach((fl) => {
                                const pkVal = this._getPKValue(fl, metadata);
                                if (!pkVal || pkVal.includes('___NULL___'))
                                    return; // the filter pk not exists
                                delete partData[pkVal];
                                isDataFound = true;
                            });
                        }
                        else { // not deleting with PK
                            const tempFilters = Utils.splitObject(filter);
                            tempFilters.forEach((fl) => {
                                const rows = _.filter(Object.values(partData), fl);
                                if (_.isEmpty(rows))
                                    return;
                                for (const row of rows) {
                                    const pkVal = this._getPKValue(row, metadata);
                                    delete partData[pkVal];
                                    isDataFound = true;
                                }
                            });
                        }
                        if (isDataFound) {
                            clonePartitions[partitionNum] = partData;
                        }
                    }
                    if (!isDataFound) {
                        return resolve({ status: true, message: MSG_DELETE_DATA_NOT_EXIST });
                    }
                }
                else { // cached data, use deleteValues array to delete
                    for await (const updateVal of deleteValues) {
                        const pkVal = this._getPKValue(updateVal, metadata);
                        const partitionNum = this._calAllPartNums(metadata, updateVal);
                        if (!clonePartitions[partitionNum]) {
                            clonePartitions[partitionNum] = _.cloneDeep(dataEntity['partitions']?.get(partitionNum) || {});
                        }
                        const partitionObj = clonePartitions[partitionNum];
                        delete partitionObj[pkVal];
                    }
                }
                const proms = [];
                // To improve performance, all updates in 1 partition will only persist for once.
                Object.keys(clonePartitions).forEach((partNum) => {
                    const filePath = this._getPathFromPK(dataEntity, partNum + '');
                    const option = {
                        data: clonePartitions[partNum],
                        path: filePath,
                        metadata
                    };
                    const prom = this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                        if (result && result.status) {
                            return { status: true, partition: partNum };
                        }
                        else {
                            return { status: false };
                        }
                    }).catch(err => {
                        const errMsg = err.stack ? err.stack : err.message;
                        txnLogger.logWarn('Partition file write error: ' + errMsg, txnId);
                        return { status: false, message: errMsg };
                    });
                    proms.push(prom);
                });
                Promise.all(proms).then(results => {
                    if (metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                        const delValues = [];
                        // deleteValues is exact the index value array, 
                        // so when a value is deleted from index, deleteValues is changed as well. 
                        // this is why I make a copy for it.
                        deleteValues.forEach(val => {
                            delValues.push(val);
                        });
                        for (let updateVal of delValues) {
                            const pkVal = this._getPKValue(updateVal, dataEntity.metadata);
                            const partitionNum = this._calAllPartNums(metadata, updateVal);
                            let isSucceed = false;
                            for (let i = 0; i < results.length; i++) {
                                if (results[i] && results[i].status && results[i].partition === partitionNum + '') {
                                    isSucceed = true;
                                    break;
                                }
                            }
                            if (isSucceed) { // update in memory data only when persist is succeed.
                                const partitionObj = dataEntity['partitions'].get(partitionNum);
                                this._deleteDKVByPk(dataEntity, this._getPKValue(updateVal, dataEntity.metadata));
                                this._deleteFromIndexes(dataEntity, updateVal);
                                delete partitionObj[pkVal];
                            }
                        }
                    }
                    resolve({ status: true, results: results });
                }).catch(err => {
                    const errMsg = err.stack ? err.stack : err.message;
                    resolve({ status: false, message: errMsg });
                });
            }
        });
    }
    _deleteByFilter(dataEntity, filter, options) {
        return new Promise(async (resolve) => {
            const txnId = options?.txnId;
            let deleteArr = [];
            if (dataEntity.metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                deleteArr = this._filter(dataEntity, filter, options?.constraints) || [];
                txnLogger.logDebug(`${this.name} array to delete: ${JSON.stringify(deleteArr)}`, txnId);
                if (!deleteArr || deleteArr.length === 0) {
                    return resolve({ status: true, message: MSG_DELETE_DATA_NOT_EXIST });
                }
                if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                    const results = [];
                    const result = { status: true, results, message: '' };
                    deleteArr.forEach(val => {
                        try {
                            this._deleteDKVByPk(dataEntity, this._getPKValue(val, dataEntity.metadata));
                            this._deleteFromIndexes(dataEntity, val);
                            results.push({ status: true, data: val });
                        }
                        catch (e) {
                            const msg = e.stack ? e.stack : e.message;
                            results.push({ status: false, data: val, message: msg });
                            result.status = false;
                            result.message += msg;
                        }
                    });
                    return resolve(result);
                }
            }
            else if (dataEntity.metadata.persistMethod && dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE &&
                dataEntity.metadata.dataStrategy === DataStrategy.NO_CACHE && !dataEntity.metadata.isNoPK) { // NO_CACHE + LIST_FILE with PK
                deleteArr = (await this.select(dataEntity.metadata.name, filter)).data;
            }
            this._persistDelete(dataEntity, deleteArr, filter, txnId).then(result => {
                resolve(result);
            }).catch(err => {
                const errMsg = err.stack ? err.stack : err.message;
                resolve({ status: false, message: errMsg });
            });
        });
    }
    _getPathFromPK(dataEntity, pkValue) {
        return path.join(dataEntity.storagePath, this._getFileNameFromMeta(dataEntity.metadata, pkValue));
    }
    _getFileNameFromMeta(metadata, pkValue) {
        const fixedFileName = metadata.fileName;
        if (fixedFileName) {
            return fixedFileName;
        }
        const prefix = metadata.fileNamePrefix ? metadata.fileNamePrefix : '';
        const surfix = metadata.fileNameSurfix ? metadata.fileNameSurfix : (metadata.persistType === PersistType.PERSIST_TYPE_YAML ? '.yaml' : '.json');
        let fileName = prefix + pkValue + surfix;
        const fnConstraints = metadata.constraintFileName;
        if (fnConstraints && Array.isArray(fnConstraints)) {
            if (fnConstraints.includes(CONSTRAINT_FILE_NAME_PK_LOWERCASE)) {
                fileName = prefix + pkValue.toLowerCase() + surfix;
            }
            if (fnConstraints.includes(CONSTRAINT_FILE_NAME_ENCODEURI)) {
                fileName = encodeURIComponent(fileName);
            }
        }
        return fileName;
    }
    _insertIndexes(dataEntity, value) {
        if (!dataEntity.metadata.indexes) {
            return;
        }
        const idxNames = Object.keys(dataEntity.metadata.indexes);
        idxNames.forEach((idxName) => {
            const indexKeyVal = this._getCombFieldsValue(value, dataEntity.metadata.indexes[idxName]);
            if (!dataEntity.indexes[idxName]) {
                dataEntity.indexes[idxName] = {};
            }
            if (!dataEntity.indexes[idxName][indexKeyVal]) {
                dataEntity.indexes[idxName][indexKeyVal] = [];
            }
            dataEntity.indexes[idxName][indexKeyVal].push(value);
        });
    }
    /**
     * transform the field value to lowercase for ignore case constraint
     * @param metadata
     * @param value
     */
    _constraintIgnoreCaseFields(ignoreCaseFields, value) {
        if (ignoreCaseFields) {
            ignoreCaseFields.forEach(fieldName => {
                const keyPathArray = fieldName.split('.');
                let obj = value;
                for (let i = 0; i < keyPathArray.length; i++) {
                    const key = keyPathArray[i];
                    if (!obj[key]) {
                        break;
                    }
                    if (i === keyPathArray.length - 1) {
                        const value = obj[key];
                        if (typeof (value) === 'string') {
                            obj[key] = value.toLowerCase();
                        }
                        else if (value) {
                            this._logWarn('The field value is not a string: ' + value);
                        }
                    }
                    else {
                        obj = obj[key];
                    }
                }
            });
        }
    }
    _insert(dataEntity, value, options) {
        return new Promise(async (resolve) => {
            const metadata = dataEntity.metadata;
            if (metadata.persistType !== PersistType.PERSIST_TYPE_ARRAY && !metadata.validateRequiredCol(value)) {
                return resolve({ status: false, message: MSG_DATA_MISSING_REQUIRED_COL });
            }
            const pkVal = this._getPKValue(value, metadata);
            const persistMethod = metadata.persistMethod;
            const persistType = metadata.persistType;
            if (persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                const result = { status: true };
                try {
                    dataEntity.keys.push(pkVal);
                    dataEntity.data[pkVal] = value;
                    dataEntity.values.push(value);
                    this._insertIndexes(dataEntity, value);
                }
                catch (e) {
                    const msg = e.stack ? e.stack : e.message;
                    result.status = false;
                    result.message = msg;
                }
                return resolve(result);
            }
            try {
                await this._obtainResourceLock(dataEntity.metadata.name); // Obtain the lock for the DE.
            }
            catch (e) {
                txnLogger.logSevere('Error encountered while obtaining source lock: ' + e.message, options?.txnId);
                await this._releaseResourceLock(dataEntity.metadata.name);
                return resolve({ status: false, message: e.message });
            }
            this._persistSave(dataEntity, value, options?.txnId).then(async (result) => {
                txnLogger.logDebug(`${this.name} insert result: ${result}`, options?.txnId);
                if (result && result.message === 'Not managed partition') {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    return resolve({ status: true });
                }
                if (metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                    dataEntity.keys.push(pkVal);
                    if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE &&
                        persistType && persistType === PersistType.PERSIST_TYPE_ARRAY && value != null) {
                        const key = metadata.primaryKeys[0];
                        const dkey = Object.keys(dataEntity.data)[0] || '___NULL___';
                        dataEntity.data[dkey] = dataEntity.data[dkey] || [];
                        dataEntity.values[0] = dataEntity.values[0] || [];
                        // value is array when _bulkLoad
                        let vals = value;
                        if (!Array.isArray(value)) {
                            vals = [value];
                        }
                        vals.forEach((v) => {
                            const vIndex = dataEntity.values[0].findIndex((d) => d[key] === v[key]);
                            if (vIndex > -1) {
                                dataEntity.values[0][vIndex] = v;
                            }
                            else {
                                dataEntity.values[0].push(v);
                            }
                            const dIndex = dataEntity.data[dkey].findIndex((d) => d[key] === v[key]);
                            if (dIndex > -1) {
                                dataEntity.data[dkey][dIndex] = v;
                            }
                            else {
                                dataEntity.data[dkey].push(v);
                            }
                        });
                    }
                    else { //push in to memory
                        dataEntity.data[pkVal] = value;
                        dataEntity.values.push(value);
                    }
                    this._insertIndexes(dataEntity, value);
                }
                await this._releaseResourceLock(dataEntity.metadata.name);
                if (!result)
                    resolve({ status: true });
                else
                    resolve(result);
            }).catch(async (err) => {
                await this._releaseResourceLock(dataEntity.metadata.name);
                resolve(err);
            });
        });
    }
    _isAnyPKColIncluded(value, metadata) {
        const pkCols = metadata.primaryKeys;
        for (let pkCol of pkCols) {
            if (this._getDeepKeyValueStr(value, pkCol)) {
                return true;
            }
        }
        return false;
    }
    _isAllPKColIncluded(value, metadata) {
        const pkCols = metadata.primaryKeys;
        // BZ-15480, support single raw file entity 
        if (metadata.fileName && PersistType.PERSIST_TYPE_RAW === metadata.persistType) {
            return true;
        }
        if (!(pkCols && Array.isArray(pkCols))) {
            return false;
        }
        for (let pkCol of pkCols) {
            if (this._getDeepKeyValueStr(value, pkCol) === null) {
                return false;
            }
        }
        return true;
    }
    _genStrHashcode(str) {
        let hash = 0;
        if (str.length === 0)
            return hash;
        for (let i = 0; i < str.length; i++) {
            const chr = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return Math.abs(hash);
    }
    _genPersistFileObj() {
        const obj = {};
        return obj;
    }
    /**
     * Moved to files.service.ts
     * Returns the path of a given file, or returns the path itself if given a path.
     * @param filePath
     */
    // private _getDir(filePath: string): string {
    //     let dirPath = filePath;
    //     if(dirPath.search(/.json$|.zmd$|.zad$|.zvt$|.zap$|.zmp$/)>0){
    //         dirPath=path.dirname(dirPath); 
    //     }
    //     return dirPath;
    // }
    _handleFileChange(dirPath, metadata, stats, filename, event) {
        const storedState = this[_watchedPaths].get(metadata.name);
        // Comment these 2 logs out, in setInterval watch mode, these are too noisy. 
        // this._logDebug('dirPath: ' + dirPath);
        // this._logDebug('storedState: ' + JSON.stringify(storedState, null, 2));
        // const fstate = fse.statSync(dirPath)
        const fstate = stats;
        // avoid further actions if the mtime is not changed.
        if (storedState && fstate.mtimeMs === storedState.mtimeMs) {
            this._logInfo('No change in mtime, ignored');
            return;
        }
        // Updates the file state record, avoid multiple re-loading for same file change.
        this[_watchedPaths].set(metadata.name, fstate);
        this._logDebug('Handling changes in : ' + dirPath);
        const changedFile = filename ? filename : dirPath;
        // Records the changed files status. The changed file list is not in use now... maybe useful in future.
        let changeStatus = this[_changedDataEntities].get(metadata.name);
        if (!changeStatus) {
            changeStatus = new ChangeStatus(metadata.name, [changedFile]);
        }
        else if (!changeStatus.fileNames) {
            changeStatus.fileNames = [changedFile];
        }
        else if (!changeStatus.fileNames.includes(changedFile)) {
            changeStatus.fileNames.push(changedFile);
        }
        else {
            this._logDebug('Ignored event: ' + event);
            return; // The changed file is already recorded, no further actions need.
        }
        this._logDebug('Watch DIR event: ' + event);
        this._logInfo('Data change encountered for data entity: ' + metadata.name);
        this._logDebug('Changed file name: ' + filename);
        // records the changed data entity
        this[_changedDataEntities].set(metadata.name, changeStatus);
        // executes the data entity refreshing. 
        // Any further actions (select / insert etc.) will wait until this is done.
        // But if an data managing action (insert/update/delete/bulkload) already started before this event is triggered, 
        // the action could fail, this depends on the time point of the file change action. 
        this[_promsReload].push(this._execWatchEvent(metadata.name));
    }
    /**
     * Watches for data changes, and refresh the data in memory accordingly.
     * @param filePath
     * @param metadata
     * @param isWatchParent Boolean. True to watch the parent dir of the given filePath. False to watch the given filePath.
     */
    _watchPath(filePath, metadata, isWatchParent = true) {
        if (metadata.isInternal === true) { // No need to watch for the internal data entities.
            return;
        }
        // if (metadata.name !== 'sessionShared') { // !!!! Testing only. Remember to delete this!
        //     return
        // }
        if (this[_dataStrategy] === DataStrategy.FILE_WATCH && metadata.dataStrategy !== DataStrategy.NO_CACHE && !metadata.isInternal) {
            try {
                const dirPath = isWatchParent ? this[_util].getDir(filePath) : filePath;
                if (this[_watchedPaths].has(metadata.name))
                    return; // Avoid watching the same path for multiple times.
                this._logInfo('Watching file change for data entity: ' + metadata.name + ', path: ' + dirPath);
                // const watcherOption = {
                //     ignoreInitial: true,
                //     persistent: true,
                //     usePolling: true,
                //     interval: 100,
                //     binaryInterval: 100,
                //     CHOKIDAR_INTERVAL: 100,
                //     depth: 5
                // }
                // let watcher = FileWatcher.watch(dirPath, {persistent: true, recursive: true});
                let watcher = FileWatcher.watch(dirPath, { interval: WATCH_INTERVAL });
                // let watcher = chokidar.watch(dirPath, watcherOption);
                watcher.on('change', (file, stats) => {
                    this._logDebug(`Triggered event: change on file: ${file}. New stats: ${JSON.stringify(stats)}`);
                    this._handleFileChange(dirPath, metadata, stats, file, 'change');
                });
                // watcher.on('add', (file: string, stats: fs.Stats) => {
                //     this._logInfo(`Triggered event: add on file: ${file}. New stats: ${JSON.stringify(stats)}`);
                //     this._handleFileChange(dirPath, metadata, stats, file, 'add');
                // });
                // watcher.on('unlink', (file: string, stats: fs.Stats) => {
                //     this._logInfo(`Triggered event: unlink on file: ${file}. New stats: ${JSON.stringify(stats)}`);
                //     this._handleFileChange(dirPath, metadata, stats, file, 'unlink');
                // });
                // Specially for z/OS, it doesn't support fs.watch yet...
                // watcher.on('error', (error:any) => {
                //     if ( error.message.includes('ENOTSUP') ){ // should use error.code here, but here the Error doesn't have a code property...
                //         this._logWarn('fs.watch() is not supported on current platform, use fs.watchFile() instead.');
                //         // this[_flagWatchFile] = true; // A mark for the watch file method.
                //         fse.watchFile(dirPath, {interval: WATCH_INTERVAL, persistent: true}, (curr) => {
                //             // OK, on z/OS with node.js v8, watchFile doesn't work neither...
                //             // In this case, we check the file mtime with setInterval. This is not a good idea, but there is no other choice.
                //             if (curr.mtimeMs === 0){
                //                 this[_watchedPaths].set(metadata.name, fse.statSync(dirPath));
                //                 this._logDebug('Watching file with setInterval for: ' + dirPath);
                //                 setInterval(()=>{
                //                     const fstate = fse.statSync(dirPath)
                //                     this._handleFileChange(dirPath, metadata, fstate, dirPath);
                //                 }, WATCH_INTERVAL);
                //                 return;
                //             }
                //             this._logDebug('Watchfile event: ' + dirPath);
                //             const fstate = fse.statSync(dirPath)
                //             this._handleFileChange(dirPath, metadata, fstate, dirPath);
                //         })
                //         watcher.close();
                //     } else {
                //         this._logSevere(error.stack? error.stack: error.message);
                //     }
                // })
                // Refresh the file stats
                this[_watchedPaths].set(metadata.name, fse.statSync(dirPath));
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    _persistRead(metadata, partitions, filter) {
        return new Promise((resolve) => {
            const partsMap = new Map();
            let persistMethod = metadata.persistMethod;
            if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                let fileName = metadata.fileName || "";
                let mergedMetadata = this._mergeFilterIntoMetaData(metadata, filter);
                fileName = metadata.fileName || mergedMetadata.fileName || '';
                if (!fileName) { //mutiple file read by directory path
                    const fileFilter = metadata.fileName ? metadata.fileName : (metadata.fileNameSurfix || '.json');
                    const filePath = this._getStoragePath(metadata);
                    this._createDirsSync(filePath); // create the path in case it doesn't exist
                    this[_util].getDataMap(filePath, fileFilter, this[_dataStrategy] === DataStrategy.FILE_WATCH).then((dataMap) => {
                        if (metadata.encryptAttrs != null && metadata.encryptAttrs.length > 0) {
                            let dataArr = [];
                            if (!_.isEmpty(filter) && metadata.primaryKeys && metadata.primaryKeys.length > 0) {
                                dataArr = _.filter(Array.from(dataMap.values()), filter);
                            }
                            else {
                                dataArr = Array.from(dataMap.values());
                            }
                            Encryption.decrypt(metadata.encryptAttrs, dataArr);
                        }
                        resolve(dataMap);
                    }).catch((err) => {
                        resolve(err);
                    });
                }
                else { //Signle file read by file name, if not exist, then will continue to read from backupPath.
                    this._readSignleFile(mergedMetadata).then((values) => {
                        Encryption.decrypt(metadata.encryptAttrs, [values]);
                        partsMap.set(fileName, values);
                        resolve(partsMap);
                    }).catch((err) => {
                        resolve(err);
                    });
                }
            }
            else { // default to PERSIST_METHOD_COMBINED_FILE
                const promises = [];
                const filterPartitions = this._calFilterParitions(metadata, filter, partitions); // calculates the partition of the filter
                filterPartitions.forEach((partNum) => {
                    if (partitions && !partitions.includes(partNum)) {
                        promises.push(Promise.resolve([]));
                        return;
                    }
                    const filePath = path.join(this._getStoragePath(metadata), this._getFileNameFromMeta(metadata, partNum + ''));
                    this._createDirsSync(filePath); // create the path in case it doesn't exist
                    if (!fs.existsSync(filePath))
                        return;
                    const prom = this[_util].readFilePromise(filePath, 'utf8', this[_dataStrategy] === DataStrategy.FILE_WATCH).then((partition) => {
                        if (!partition || partition === '') {
                            return [];
                        }
                        return [partNum, JSON.parse(partition)];
                    }).catch((err) => {
                        if (err.code === 'ENOENT') { // partition file not exist
                            return [];
                        }
                        else {
                            throw err;
                        }
                    });
                    promises.push(prom);
                });
                Promise.all(promises).then((parts) => {
                    parts.forEach((part) => {
                        if (part && part.length === 2) {
                            Encryption.decrypt(metadata.encryptAttrs, part[1]);
                            partsMap.set(part[0], part[1]);
                        }
                    });
                    resolve(partsMap);
                }).catch((err) => {
                    resolve(err);
                });
            }
        });
    }
    _getString(val) {
        const type = typeof (val);
        if (type === 'string') {
            return val;
        }
        else if (type === 'number') {
            return String(val);
        }
        else if (val instanceof Date) {
            return val.getTime().toString();
        }
        else {
            return JSON.stringify(val);
        }
    }
    _calSinglePartNum(metadata, partCol, row) {
        const partVal = row[partCol];
        const partCount = metadata.getPartitionCount(partCol);
        const num = this._genStrHashcode(this._getString(partVal));
        return String(num % partCount);
    }
    _calAllPartNums(metadata, row) {
        const partCols = metadata.getPartitionColumn();
        const partVals = partCols.map((pc) => {
            return this._calSinglePartNum(metadata, pc, row);
        });
        return _.join(partVals, KEY_CONNECTOR);
    }
    // private _haveCommenElement(arr1: any[], arr2: any[]){
    //     return arr1.some(v=> arr2.indexOf(v) !== -1)
    // }
    _calFilterParitions(metadata, partFilter, filterPartitions) {
        let parts = [];
        const filter = _.cloneDeep(partFilter);
        const partCols = metadata.getPartitionColumn();
        if (!_.isEmpty(filter)) {
            for (const key of Object.keys(filter)) {
                const val = filter[key];
                if (val == undefined || (typeof (val) === 'object' && _.isEmpty(val))) {
                    delete filter[key];
                }
            }
        }
        if (_.isEmpty(filter)) {
            const tempP = [];
            partCols.forEach(partCol => {
                tempP.push(Array.from(Array(metadata.getPartitionCount(partCol)).keys()));
            });
            const tempPs = Utils.cartesian(tempP);
            tempPs.forEach((tp) => {
                if (Array.isArray(tp)) {
                    const partNum = String(_.join(tp, KEY_CONNECTOR));
                    if (!parts.includes(partNum)) {
                        parts.push(partNum);
                    }
                }
                else {
                    const tpstr = String(tp);
                    if (!parts.includes(tpstr)) {
                        parts.push(tpstr);
                    }
                }
            });
            return parts;
        }
        const rows = Utils.splitObject(filter || {});
        const cols = Object.keys(filter || {});
        if (_.difference(partCols, cols).length === 0) { // filter includes all columns for partition
            rows.forEach((row) => {
                const partVal = this._calAllPartNums(metadata, row);
                parts.push(partVal);
            });
        }
        else { // part or none of partition columns is included by filter
            rows.forEach((row) => {
                const tempP = [];
                partCols.forEach(partCol => {
                    if (cols.includes(partCol)) {
                        tempP.push([this._calSinglePartNum(metadata, partCol, row)]);
                    }
                    else {
                        tempP.push(Array.from(Array(metadata.getPartitionCount(partCol)).keys()));
                    }
                });
                const tempPs = Utils.cartesian(tempP);
                tempPs.forEach((tp) => {
                    if (Array.isArray(tp)) {
                        const partNum = String(_.join(tp, KEY_CONNECTOR));
                        if (!parts.includes(partNum)) {
                            parts.push(partNum);
                        }
                    }
                    else {
                        const tpstr = String(tp);
                        if (!parts.includes(tpstr)) {
                            parts.push(tpstr);
                        }
                    }
                });
            });
        }
        if (filterPartitions && filterPartitions.length > 0) {
            parts = _.intersection(parts, filterPartitions);
        }
        return parts;
    }
    _persistReadNoPKData(metadata) {
        return new Promise((resolve) => {
            let persistMethod = metadata.persistMethod;
            if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                let fileName = metadata.fileName || '';
                let isNoPK = _.isEmpty(metadata.primaryKeys);
                if (!fileName && isNoPK) { // is NO PK and no fileName, need return fileName.
                    const fileFilter = metadata.fileName ? metadata.fileName : (metadata.fileNameSurfix) || '';
                    const filePath = this._getStoragePath(metadata);
                    this._createDirsSync(filePath); // create the path in case it doesn't exist
                    this[_util].returnDataWithName(filePath, fileFilter, metadata.persistType, metadata.isAllowSubFolder).then((values) => {
                        resolve(values);
                    }).catch((err) => {
                        resolve(err);
                    });
                }
                else {
                    this._persistRead(metadata).then((value) => {
                        resolve(Array.from(value.values()));
                    }).catch((err) => {
                        resolve(err);
                    });
                }
            }
            else { // default to PERSIST_METHOD_COMBINED_FILE
                this._persistRead(metadata).then((value) => {
                    resolve(Array.from(value.values()));
                }).catch((err) => {
                    resolve(err);
                });
            }
        });
    }
    _readSignleFile(metadata) {
        return new Promise(async (resolve, reject) => {
            if (metadata.fileName) {
                let pathArray = [];
                if (metadata.filePath) {
                    pathArray.push(metadata.filePath);
                }
                if (metadata.backupFilePaths && Array.isArray(metadata.backupFilePaths)) {
                    pathArray.push(...metadata.backupFilePaths);
                }
                for (var i = 0; i < pathArray.length; i++) {
                    const filePath = this._getStorageFullPath(pathArray[i]);
                    this._createDirsSync(filePath); // create the path in case it doesn't exist
                    const filePathName = path.join(filePath, metadata.fileName);
                    if (this[_util].existFileSync(filePathName)) {
                        let fileString = "";
                        try {
                            if (metadata.persistType !== PersistType.PERSIST_TYPE_RAW) {
                                fileString = await this[_util].readFilePromise(filePathName, 'utf8', this[_dataStrategy] === DataStrategy.FILE_WATCH); // BZ-15480
                                let fileObj;
                                if (metadata.fileName.endsWith('.yaml') || metadata.persistType == PersistType.PERSIST_TYPE_YAML) { // yaml
                                    try {
                                        fileObj = yaml.yamlStrToJson(fileString); //yaml string format to object
                                    }
                                    catch (err) {
                                        Logger.logError(err);
                                        fileObj = {};
                                    }
                                }
                                else { // json
                                    try {
                                        fileObj = JSON.parse(fileString); //json string format to object
                                    }
                                    catch (err) {
                                        fileObj = this[_util].convertToJsonWithComment(fileString);
                                    }
                                }
                                return resolve(fileObj);
                            }
                            else {
                                // BZ-15480, support single raw file entity
                                // this._logSevere(`_readSignleFile, ${metadata.name}`);                      
                                const str = await this[_util].readBufferFilePromise(filePathName);
                                fileString = JSON.stringify(str);
                                return resolve({ data: fileString });
                            }
                        }
                        catch (err) {
                            return reject(err);
                        }
                    }
                }
                return reject(false);
            }
        });
    }
    _mergeFilterIntoMetaData(metadata, filter) {
        let newmMetadata = _.clone(metadata);
        if (filter && !_.isEmpty(filter)) {
            // Object.keys(filter).forEach(key => {
            //     if(newmMetadata.){
            //         newmMetadata[key]= filter[key];
            //     }
            // });
            Object.assign(newmMetadata, filter);
        }
        return newmMetadata;
    }
    _persistSave(dataEntity, value, txnId) {
        return new Promise(async (resolve, reject) => {
            const metadata = dataEntity.metadata;
            const persistMethod = metadata.persistMethod;
            const persistType = metadata.persistType;
            const pkVal = this._getPKValue(value, dataEntity.metadata);
            const inMemory = persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
            if (inMemory) {
                resolve({ status: true, message: "Saved successfully in only memory mode" });
            }
            else if (persistMethod && (persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE)) {
                let option = {
                    data: value,
                    path: '',
                    metadata
                };
                if (!!pkVal || metadata.fileName) { //exist PK or metaData.fileName
                    let filePath = this._getPathFromPK(dataEntity, pkVal);
                    option.path = filePath;
                }
                else { // no metaData.fileName and no PK.  get fileName from value
                    let fileName = value.fileName || 'newfile';
                    let filePath = path.join(this._getStorageFullPath(metadata.filePath), fileName);
                    option.path = filePath;
                    option.data = value.data;
                    Object.defineProperty(option, 'doFormat', {
                        value: true,
                        writable: false
                    });
                }
                if (persistType && persistType === PersistType.PERSIST_TYPE_ARRAY) {
                    const values = dataEntity.values;
                    let newValue = _.clone(values);
                    newValue = [].concat(...newValue); // convert to linear array
                    if (Array.isArray(value)) {
                        newValue = _.concat(newValue, value);
                    }
                    else {
                        const index = dataEntity.keys.findIndex((d) => d === pkVal);
                        if (index > -1) {
                            newValue[index] = value;
                        }
                        else {
                            newValue.push(value); // insert new value.
                        }
                    }
                    option.data = newValue;
                }
                else if (persistType && persistType === PersistType.PERSIST_TYPE_RAW) { //upload, buffer format
                    let fileObj = value;
                    // BZ-15480, support single raw file entity 
                    if (!metadata.fileName && fileObj.fileName) {
                        option.path = path.join(this._getStorageFullPath(metadata.filePath), fileObj.fileName);
                    }
                    option.data = fileObj.data;
                    if (typeof (option.data) === 'string') {
                        option.data = JSON.parse(option.data);
                        option.data = Buffer.from(option.data, 'utf8');
                    }
                    Object.defineProperty(option, 'isBuffer', {
                        value: true,
                        writable: false
                    });
                }
                this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                    resolve(result);
                }).catch(err => {
                    reject(err);
                });
            }
            else { // default to PERSIST_METHOD_COMBINED_FILE: parittioned
                const partitionNum = this._calAllPartNums(metadata, value);
                if (dataEntity.managedPartitions && dataEntity.managedPartitions.length > 0) {
                    if (!dataEntity.managedPartitions.includes(partitionNum)) {
                        return resolve({ status: true, message: 'Not managed partition' });
                    }
                }
                const filePath = this._getPathFromPK(dataEntity, partitionNum + '');
                const option = {
                    data: {},
                    path: filePath,
                    metadata
                };
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                    let partitionObj;
                    try {
                        partitionObj = await this[_util].readJSON(filePath);
                    }
                    catch (e) {
                        txnLogger.logWarn('Error while reading partition file: ' + filePath, txnId);
                        txnLogger.logError(e, txnId);
                        throw e;
                    }
                    if (partitionObj[pkVal] !== undefined) {
                        return resolve({ status: false, message: MSG_INSERT_DATA_DUPLICATED });
                    }
                    partitionObj[pkVal] = value;
                    option.data = partitionObj;
                }
                else {
                    if (!dataEntity['partitions']) {
                        const emptyMap = new Map();
                        dataEntity['partitions'] = emptyMap;
                    }
                    if (!dataEntity['partitions'].has(partitionNum)) {
                        dataEntity['partitions'].set(partitionNum, this._genPersistFileObj());
                    }
                    const partitionObj = dataEntity['partitions'].get(partitionNum);
                    partitionObj[pkVal] = value;
                    option.data = partitionObj;
                }
                this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                    resolve(result);
                }).catch(err => {
                    reject(err);
                });
            }
        });
    }
    _bulkLoadPersistPartition(dataEntity, values, options) {
        const txnId = options?.txnId;
        txnLogger.logDebug(`Bulk loading data entity: ${dataEntity.metadata.name}, row count: ${values.length}, persist partition`, txnId);
        return new Promise(async (resolve) => {
            const constraint = options?.bulkloadConstraints;
            const metadata = dataEntity.metadata;
            const promsPartition = [];
            const promsData = [];
            const partitionValues = new Map();
            const clonePartitions = {};
            for await (let value of values) {
                if (!this._isAllPKColIncluded(value, dataEntity.metadata)) { // each row must include PK. otherwise status is false.
                    promsData.push({ status: false, message: MSG_INSERT_DATA_HAS_NO_KEY, data: value });
                    continue;
                }
                if (!metadata.validateRequiredCol(value)) {
                    promsData.push({ status: false, message: MSG_DATA_MISSING_REQUIRED_COL, data: value });
                    continue;
                }
                const pkVal = this._getPKValue(value, dataEntity.metadata);
                // const partitionNum = this._calFilterParitions(metadata, value)[0]
                const partitionNum = this._calAllPartNums(metadata, value);
                if (dataEntity.managedPartitions && dataEntity.managedPartitions.length > 0 && dataEntity.managedPartitions.length < 20) {
                    if (!dataEntity.managedPartitions.includes(partitionNum)) {
                        continue;
                    }
                }
                if (!clonePartitions[partitionNum]) {
                    if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                        const filePath = this._getPathFromPK(dataEntity, partitionNum + '');
                        const partData = await this[_util].readJSON(filePath);
                        clonePartitions[partitionNum] = partData;
                    }
                    else {
                        clonePartitions[partitionNum] = _.cloneDeep(dataEntity['partitions']?.get(partitionNum) || {});
                    }
                }
                const partitionObj = clonePartitions[partitionNum];
                if (metadata.isNonPKPartitioned) {
                    // TBD
                    // Here performance is the highest priority, so I choose to tolerant same PK exists in different partitions. 
                    // When selecting the records without partition columns, the duplicated PKs spotted can be cleared.
                }
                // Value change strategies
                if (constraint && constraint.isReplaceAsUpdate()) {
                    if (partitionObj[pkVal]) {
                        Object.assign(partitionObj[pkVal], value); // Update means the Object reference is not changed.
                    }
                    else {
                        partitionObj[pkVal] = value;
                    }
                }
                else if (!constraint || (constraint && constraint.isReplaceAsDeleteInsert())) { // Default action is delete insert
                    partitionObj[pkVal] = value; //  Delete&insert means the Object reference is changed.
                }
                else { // ignore
                    if (partitionObj[pkVal]) {
                        // Ignore it when data already exist
                    }
                    else {
                        partitionObj[pkVal] = value;
                    }
                }
                const partVals = partitionValues.get(partitionNum);
                if (partVals) {
                    partVals.push(value);
                }
                else {
                    partitionValues.set(partitionNum, [value]);
                }
            }
            Object.keys(clonePartitions).forEach((partNum) => {
                const filePath = this._getPathFromPK(dataEntity, partNum + '');
                const option = {
                    data: clonePartitions[partNum],
                    path: filePath,
                    metadata
                };
                const prom = this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                    if (result && result.status) {
                        return { status: true, partition: partNum };
                    }
                    else {
                        return { status: false, partition: partNum };
                    }
                }).catch(err => {
                    const errMsg = err.stack ? err.stack : err.message;
                    txnLogger.logWarn('Partition file write error: ' + errMsg, txnId);
                    return { status: false, message: errMsg, partition: partNum };
                });
                promsPartition.push(prom);
            });
            Promise.all(promsPartition).then(results => {
                results.forEach((result) => {
                    if (result && result.status) {
                        const partNum = result.partition;
                        const partValues = partitionValues.get(partNum);
                        if (partValues) {
                            partValues.forEach((value) => {
                                if (metadata.dataStrategy !== DataStrategy.NO_CACHE) { // only cached de needs update memory
                                    const pkVal = this._getPKValue(value, dataEntity.metadata);
                                    const partitionNum = this._calAllPartNums(metadata, value);
                                    let partitionObj = dataEntity['partitions'].get(partitionNum);
                                    if (!partitionObj) {
                                        dataEntity['partitions'].set(partitionNum, {});
                                        partitionObj = dataEntity['partitions'].get(partitionNum);
                                    }
                                    let dataObj = partitionObj[pkVal];
                                    if (dataObj) {
                                        if (constraint && constraint.isReplaceAsIgnore()) {
                                            // Ignore it when data already exist
                                        }
                                        else {
                                            this._deleteFromIndexes(dataEntity, dataObj);
                                            // Value change strategies
                                            if (constraint && constraint.isReplaceAsUpdate()) {
                                                // Update means the Object reference is not changed, only change contents
                                                partitionObj[pkVal] = Object.assign(dataObj, value);
                                            }
                                            else if (!constraint || (constraint && constraint.isReplaceAsDeleteInsert())) { // default
                                                partitionObj[pkVal] = value; //  Delete&insert means the Object reference is changed.
                                                dataObj = value;
                                            }
                                            const idx = dataEntity.keys.indexOf(pkVal);
                                            dataEntity.data[pkVal] = value;
                                            dataEntity.values[idx] = value;
                                        }
                                    }
                                    else {
                                        partitionObj[pkVal] = value;
                                        dataObj = value;
                                        dataEntity.data[pkVal] = value;
                                        dataEntity.keys.push(pkVal);
                                        dataEntity.values.push(value);
                                    }
                                    this._insertIndexes(dataEntity, dataObj);
                                }
                                promsData.push({ status: true, data: value }); // return a copy of the data?
                            });
                        }
                        else {
                            txnLogger.logDebug('Wrote data for partitioned NO_CACHE', txnId);
                        }
                    }
                    else if (result && result.status === false) {
                        const partNum = result.partition;
                        const partValues = partitionValues.get(partNum);
                        if (partValues) {
                            partValues.forEach((value) => {
                                promsData.push({ status: false, data: value }); // return a copy of the data?
                            });
                        }
                        else {
                            // this should never happen. 
                            txnLogger.logSevere('Partition write result abnormal: ' + result, txnId);
                        }
                    }
                    else {
                        // this should never happen
                    }
                });
                resolve({ status: true, results: promsData });
            }).catch(err => {
                const errMsg = err.stack ? err.stack : err.message;
                resolve({ status: false, message: errMsg });
            });
            // Promise.all(promsData).then(results => {
            //     resolve({status: true, results: results});
            // }, err => { //
            //     const errMsg = err.stack? err.stack: err.message;
            //     resolve({status: false, message: errMsg});
            // });
        });
    }
    _bulkLoadPersistFileList(dataEntity, values, options) {
        return new Promise(resolve => {
            const proms = [];
            const metadata = dataEntity.metadata;
            const constraint = options?.bulkloadConstraints;
            if (constraint && constraint.isReplaceAsUpdate()) {
                values.forEach(value => {
                    const prom = this._updateOrInsert(dataEntity, value, options);
                    proms.push(prom);
                });
            }
            else if (constraint && constraint.isReplaceAsDeleteInsert()) {
                values.forEach(value => {
                    const filter = {};
                    metadata.primaryKeys.forEach((keyCol) => {
                        filter[keyCol] = this._getDeepKeyValueStr(value, keyCol);
                    });
                    this._deleteByFilter(dataEntity, filter, options).then(result => {
                        if (result && result.status) {
                            const prom = this._insert(dataEntity, value, options);
                            proms.push(prom);
                        }
                        else {
                            proms.push(Promise.resolve({ status: false, result: result, data: value }));
                        }
                    });
                });
            }
            else { // default as ignore
                if (metadata.persistType && metadata.persistType === PersistType.PERSIST_TYPE_ARRAY && metadata.fileName) {
                    values = [values];
                }
                values.forEach(value => {
                    const filter = {};
                    metadata.primaryKeys.forEach((keyCol) => {
                        filter[keyCol] = this._getDeepKeyValueStr(value, keyCol);
                    });
                    if (this.selectSync(metadata.name, filter).rowCount === 0) {
                        const prom = this._insert(dataEntity, value, options);
                        proms.push(prom);
                    }
                    else {
                        proms.push(Promise.resolve({ status: true, message: 'Ignored existing data', data: value }));
                    }
                });
            }
            Promise.all(proms).then(results => {
                resolve(results);
            }).catch(err => {
                resolve({ status: false, message: err.stack ? err.stack : err.message });
            });
        });
    }
    async _bulkLoadOnlyMemory(dataEntity, values, options) {
        const results = [];
        const result = { status: true, results, message: '' };
        const constraint = options?.bulkloadConstraints;
        values.forEach((value) => {
            try {
                if (!this._isAllPKColIncluded(value, dataEntity.metadata)) { // bulkload value must include pk
                    results.push({ status: false, data: value, message: MSG_INSERT_DATA_HAS_NO_KEY });
                }
                const pkVal = this._getPKValue(value, dataEntity.metadata);
                let dataObj = dataEntity.data[pkVal];
                if (dataObj) { // the bulkload value already exists
                    if (constraint && constraint.isReplaceAsIgnore()) {
                        // Ignore it when data already exist
                    }
                    else {
                        this._deleteFromIndexes(dataEntity, dataObj);
                        // Value change strategies
                        if (constraint && constraint.isReplaceAsUpdate()) {
                            // Update means the Object reference is not changed, only change contents
                            dataObj = Object.assign(dataObj, value);
                        }
                        else if (!constraint || (constraint && constraint.isReplaceAsDeleteInsert())) {
                            dataObj = value; //  Delete&insert means the Object reference is changed.
                        }
                        const idx = dataEntity.keys.indexOf(pkVal);
                        dataEntity.values[idx] = dataObj;
                        dataEntity.data[pkVal] = dataObj;
                    }
                }
                else {
                    dataObj = value;
                    dataEntity.data[pkVal] = value;
                    dataEntity.keys.push(pkVal);
                    dataEntity.values.push(value);
                }
                this._insertIndexes(dataEntity, dataObj);
                results.push({ status: true, data: value });
            }
            catch (e) {
                const msg = e.stack ? e.stack : e.message;
                results.push({ status: false, data: value, message: msg });
                result.status = false;
                result.message += msg;
            }
        });
        return result;
    }
    _bulkLoad(dataEntity, values, options) {
        return new Promise(async (resolve) => {
            const txnId = options?.txnId;
            let persistMethod = dataEntity.metadata.persistMethod;
            if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                this._bulkLoadOnlyMemory(dataEntity, values, options).then(result => {
                    resolve(result);
                }).catch(err => {
                    const errMsg = err.stack ? err.stack : err.message;
                    txnLogger.logWarn('Data bulkload failed with error: ' + errMsg, txnId);
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                });
            }
            else if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                try {
                    await this._obtainResourceLock(dataEntity.metadata.name); // Obtain the lock for the DE.
                }
                catch (e) {
                    txnLogger.logSevere('Error encountered while obtaining source lock: ' + e.message, txnId);
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    return resolve({ status: false, message: e.message });
                }
                this._bulkLoadPersistFileList(dataEntity, values, options).then(async (result) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve(result);
                }).catch(async (err) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                });
            }
            else {
                try {
                    await this._obtainResourceLock(dataEntity.metadata.name); // Obtain the lock for the DE.
                }
                catch (e) {
                    txnLogger.logSevere('Error encountered while obtaining source lock: ' + e.message, txnId);
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    return resolve({ status: false, message: e.message });
                }
                this._bulkLoadPersistPartition(dataEntity, values, options).then(async (result) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve(result);
                }).catch(async (err) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                });
            }
        });
    }
    async _isLockExist(dataEntityName, filePath) {
        let existLock;
        try {
            existLock = await fse.stat(filePath);
            // this._logInfo('Lock file stats: ' + JSON.stringify(existLock))
            if (existLock) {
                const timediff = Date.now() - existLock.mtimeMs;
                // this._logInfo('Lock timediff: ' + timediff)
                if (timediff > DE_LOCK_MAX_AGE) { // The existing lock has exists for more than 1 minutes. Maybe it's a lock created by a dead server...
                    // this._logInfo('Releasing old lock')
                    await this._releaseResourceLock(dataEntityName);
                    // this._logInfo('Released old lock')
                    return false;
                }
                else {
                    this._logWarn('Entity ' + dataEntityName + ' is currently locked by other server.');
                    return true;
                }
            }
            return false;
        }
        catch (e) {
            if (e.code === 'ENOENT') { // Lock file not exist
                // Expected result. Though using exception as part of logic is not a good code standard, but this will save disk I/O here.
                return false;
            }
            else {
                this._logWarn('Error while obtaining entity lock for ' + dataEntityName + '. Error message: ' + e.message);
                return true;
            }
        }
    }
    async _obtainResourceLock(dataEntityName, times = 0) {
        const funcNextRound = (resolve, reject) => {
            if (times % 10 === 0) {
                this._logWarn('Obtaining lock for data entity: ' + dataEntityName + ', seconds: ' + (times / 2));
            }
            if (times > 120) {
                reject('Obtaining lock for data entity: ' + dataEntityName + ' timeout'); // Time limit for data entity lock is 1 minute.
            }
            else {
                setTimeout(() => {
                    resolve(this._obtainResourceLock(dataEntityName, ++times));
                }, 500);
            }
        };
        try {
            if (this[_dataStrategy] !== DataStrategy.FILE_WATCH) {
                return Promise.resolve(true);
            }
            const dataEntity = this[_dataEntities][dataEntityName];
            if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                return Promise.resolve(true);
            }
            // this._logInfo('Started trying to obtain lock for entity: ' + dataEntityName)
            const lockDE = this[_dataEntities]['internal_de_lock'];
            const dirPath = path.join(this[_basePath], lockDE.metadata.filePath);
            // this._logInfo('Before clearNFSClientCacheAsync')
            await this[_util].clearNFSClientCacheAsync(dirPath);
            // this._logInfo('After clearNFSClientCacheAsync')
            const filePath = path.join(dirPath, dataEntityName + '.json');
            // const locks = await this.select('internal_de_lock', {id: dataEntityName})
            const isLockExists = await this._isLockExist(dataEntityName, filePath);
            if (isLockExists) {
                return new Promise(funcNextRound);
            }
            const isChangedDE = this[_changedDataEntities].has(dataEntityName);
            if (isChangedDE) {
                this._logWarn('Entity ' + dataEntityName + ' is currently being reloaded.');
                return new Promise(funcNextRound);
            }
            else {
                return new Promise((resolve, reject) => {
                    // this._logInfo('Calculating lock file path.')
                    // const filePath = path.join(this[_basePath], lockDE.metadata.filePath, dataEntityName + '.json')
                    // this._logInfo('Lock file path: ' + filePath)
                    fse.outputJSON(filePath, { id: dataEntityName, timestamp: Date.now() }).then(() => {
                        this._logInfo('Entity lock is obtained for: ' + dataEntityName);
                        return resolve(true);
                    }).catch((e) => {
                        this._logWarn('Error while obtaining entity lock for: ' + dataEntityName + '. Message: ' + e.message);
                        if (times % 10 === 0) {
                            this._logWarn('Obtaining lock for data entity: ' + dataEntityName + ', seconds: ' + (times / 2));
                        }
                        if (times > 120) {
                            reject('Obtaining lock for data entity: ' + dataEntityName + ' timeout'); // Time limit for data entity lock is 1 minute.
                        }
                        else {
                            setTimeout(() => {
                                resolve(this._obtainResourceLock(dataEntityName, ++times));
                            }, 500);
                        }
                    });
                });
            }
        }
        catch (e) {
            this._logSevere('Error while obtaining lock for entity: ' + dataEntityName + '. Error: ' + e.message);
            return new Promise(funcNextRound);
        }
    }
    async _releaseResourceLock(dataEntityName) {
        return new Promise((resolve) => {
            const dataEntity = this[_dataEntities][dataEntityName];
            if (this[_databaseMetadata].getDataStrategy() !== DataStrategy.FILE_WATCH || dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                return resolve(false);
            }
            const lockDE = this[_dataEntities]['internal_de_lock'];
            const filePath = path.join(this[_basePath], lockDE.metadata.filePath, dataEntityName + '.json');
            fse.unlink(filePath).then(() => {
                this._logInfo('Entity lock is released for: ' + dataEntityName);
                return resolve(true);
            }).catch(e => {
                if (e.code === 'ENOENT') {
                    // The lock is already removed.
                }
                else {
                    this._logSevere('Error while deleting data entity lock for: ' + dataEntityName + '. Please delete the file manually: ' + filePath);
                    this._logSevere(e.message);
                }
                return resolve(false);
            });
        });
    }
    _updateOrInsert(dataEntity, value, options) {
        return new Promise(async (resolve) => {
            const txnId = options?.txnId;
            const filter = {};
            const metadata = dataEntity.metadata;
            metadata.primaryKeys.forEach((key) => {
                filter[key] = this._getDeepKeyValueStr(value, key);
            });
            if (!options || !options.isSilent) {
                txnLogger.logInfo('Update or insert ' + metadata.name + ', PK : ' + JSON.stringify(filter), txnId);
            }
            txnLogger.logDebug('Value: ' + JSON.stringify(value), txnId);
            let updateValues;
            if (metadata.dataStrategy === DataStrategy.NO_CACHE && (metadata.persistMethod === PersistMethod.PERSIST_METHOD_COMBINED_FILE)) {
                updateValues = (await this.select(metadata.name, _.pick(value, metadata.primaryKeys))).data;
            }
            else {
                updateValues = !_.isEmpty(filter) ? this._filter(dataEntity, filter) : []; //support no PK
            }
            if (updateValues && updateValues.length > 0) {
                this._update(dataEntity, updateValues, value, options).then(result => {
                    resolve(result);
                }).catch(err => {
                    const errMsg = err.stack ? err.stack : err.message;
                    resolve({ status: false, message: errMsg });
                });
            }
            else {
                this._insert(dataEntity, value, options).then(result => {
                    resolve(result);
                });
            }
        });
    }
    // private _setLoadReport(report: any[]){
    //     this[_loadReport] = report;
    // }
    //TODO do not merge attr!
    _update(dataEntity, updateValues, value, options) {
        return new Promise(async (resolve) => {
            let persistMethod = dataEntity.metadata.persistMethod;
            const txnId = options?.txnId;
            try {
                await this._obtainResourceLock(dataEntity.metadata.name); // Obtain the lock for the DE.
            }
            catch (e) {
                txnLogger.logSevere('Error encountered while obtaining source lock: ' + e.message, txnId);
                await this._releaseResourceLock(dataEntity.metadata.name);
                return resolve({ status: false, message: e.message });
            }
            if (dataEntity.metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY) {
                const results = [];
                const result = { status: true, results, message: '' };
                try {
                    updateValues.forEach((updateVal) => {
                        const pkVal = this._getPKValue(updateVal, dataEntity.metadata);
                        this._deleteFromIndexes(dataEntity, updateVal);
                        dataEntity.data[pkVal] = Object.assign(dataEntity.data[pkVal], value);
                        this._insertIndexes(dataEntity, dataEntity.data[pkVal]);
                        results.push({ status: true, data: updateVal });
                    });
                    resolve(result);
                }
                catch (err) {
                    const errMsg = err.stack ? err.stack : err.message;
                    txnLogger.logWarn('Data update failed with error: ' + errMsg, txnId);
                    resolve({ status: false, message: errMsg });
                }
            }
            else if (persistMethod && persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                const proms = [];
                updateValues.forEach((updateVal) => {
                    const cloneVal = JSON.parse(JSON.stringify(updateVal));
                    Object.assign(cloneVal, value); // Avoid change the data in memory before file write.
                    const prom = this._persistSave(dataEntity, cloneVal, txnId).then(result => {
                        if (result && result.status) {
                            if (dataEntity.metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                                this._deleteFromIndexes(dataEntity, updateVal);
                                updateVal = Object.assign(updateVal, value); // change the data in memory
                                if (dataEntity.metadata.persistType && dataEntity.metadata.persistType === PersistType.PERSIST_TYPE_ARRAY) {
                                    // TBD: process dataEntity.data nd dataEntity.values in this case
                                    txnLogger.logWarn('process dataEntity.data nd dataEntity.values for PERSIST_TYPE_ARRAY', txnId);
                                }
                                this._insertIndexes(dataEntity, updateVal);
                            }
                            return { status: true };
                        }
                        return { status: false, message: 'Unknown Error' };
                    }).catch(err => {
                        const errMsg = err.stack ? err.stack : err.message;
                        txnLogger.logWarn('Data persist failed with error: ' + err.stack ? err.stack : err.message, txnId);
                        return { status: false, message: errMsg };
                    });
                    proms.push(prom);
                });
                Promise.all(proms).then(async (results) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve({ status: true, results: results });
                }).catch(async (reason) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve({ status: false, reason: reason });
                });
            }
            else { // Partitioned
                const partitionValues = new Map();
                const partitionValuesDelete = new Map();
                const clonePartitions = {}; // the data to write file
                const metadata = dataEntity.metadata;
                for await (const updateVal of updateValues) {
                    const pkVal = this._getPKValue(updateVal, metadata);
                    const newVal = Object.assign(_.cloneDeep(updateVal), value);
                    const partitionNum = this._calAllPartNums(metadata, updateVal);
                    const newPartNum = this._calAllPartNums(metadata, newVal);
                    if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                        if (metadata.isNonPKPartitioned) { // partition by non PK column
                            if (partitionNum !== newPartNum) {
                                if (!clonePartitions[partitionNum]) {
                                    const filePath = this._getPathFromPK(dataEntity, partitionNum + '');
                                    const partData = await this[_util].readJSON(filePath);
                                    clonePartitions[partitionNum] = partData;
                                }
                                const partitionObj = clonePartitions[partitionNum];
                                delete partitionObj[pkVal]; // delete the data from old partition
                            }
                            if (!clonePartitions[newPartNum]) {
                                const filePath = this._getPathFromPK(dataEntity, newPartNum + '');
                                const partData = await this[_util].readJSON(filePath);
                                clonePartitions[newPartNum] = partData;
                            }
                            const partitionObj = clonePartitions[newPartNum];
                            partitionObj[pkVal] = newVal; // adds the data into new parition
                        }
                        else {
                            if (!clonePartitions[partitionNum]) {
                                const filePath = this._getPathFromPK(dataEntity, partitionNum + '');
                                const partData = await this[_util].readJSON(filePath);
                                clonePartitions[partitionNum] = partData;
                            }
                            const partitionObj = clonePartitions[partitionNum];
                            partitionObj[pkVal] = newVal; // updates the data
                        }
                    }
                    else { // data cached in memory
                        if (metadata.isNonPKPartitioned) { // partition by non PK column
                            if (!clonePartitions[partitionNum]) {
                                const partData = _.cloneDeep(dataEntity['partitions']?.get(partitionNum) || {});
                                delete partData[pkVal]; // delete the data from old partition
                                clonePartitions[partitionNum] = partData;
                                const partVals = partitionValuesDelete.get(partitionNum); // in case of None NO_CACHE, it needs update memory
                                if (partVals) {
                                    partVals.push(pkVal);
                                }
                                else {
                                    partitionValuesDelete.set(partitionNum, [pkVal]);
                                }
                            }
                            const newVal = Object.assign(updateVal, value);
                            // const newPartNum = this._calFilterParitions(metadata, newVal)[0]
                            const newPartNum = this._calAllPartNums(metadata, newVal);
                            if (!clonePartitions[newPartNum]) {
                                const partData = JSON.parse(JSON.stringify(dataEntity['partitions'].get(newPartNum)));
                                clonePartitions[newPartNum] = partData;
                            }
                            const partitionObj = clonePartitions[newPartNum];
                            partitionObj.set(pkVal, newVal); // adds the data into new parition for file writing
                            const partVals = partitionValues.get(newPartNum); // in case of None NO_CACHE, it needs update memory
                            if (partVals) {
                                partVals.push(updateVal);
                            }
                            else {
                                partitionValues.set(newPartNum, [updateVal]); // records the partition to update in memory
                            }
                        }
                        else {
                            if (!clonePartitions[partitionNum]) {
                                clonePartitions[partitionNum] = _.cloneDeep(dataEntity['partitions']?.get(partitionNum) || {});
                            }
                            const partitionObj = clonePartitions[partitionNum];
                            Object.assign(partitionObj[pkVal], value); // updates the data
                            const partVals = partitionValues.get(partitionNum); // in case of None NO_CACHE, it needs update memory
                            if (partVals) {
                                partVals.push(newVal);
                            }
                            else {
                                partitionValues.set(partitionNum, [newVal]); // records the partition to update in memory
                            }
                        }
                    }
                }
                // updateValues.forEach((updateVal) => {
                // });
                const proms = [];
                // To improve performance, all updates in 1 partition will only persist for once.
                Object.keys(clonePartitions).forEach((partNum) => {
                    const filePath = this._getPathFromPK(dataEntity, partNum + '');
                    const option = {
                        data: clonePartitions[partNum],
                        path: filePath,
                        metadata
                    };
                    const prom = this._addQueue({ option: option, type: 'add', txnId }).then(result => {
                        if (result && result.status) {
                            return { status: true, partition: partNum };
                        }
                        else {
                            return { status: false, partition: partNum };
                        }
                    }).catch(err => {
                        const errMsg = err.stack ? err.stack : err.message;
                        txnLogger.logWarn('Partition file write error: ' + errMsg, txnId);
                        return { status: false, message: errMsg, partition: partNum };
                    });
                    proms.push(prom);
                });
                Promise.all(proms).then(async (results) => {
                    if (metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                        results.forEach((result) => {
                            if (result && result.status) {
                                const partNum = result.partition;
                                const delPartkeys = partitionValuesDelete.get(partNum);
                                if (delPartkeys) {
                                    delPartkeys.forEach((delkey) => {
                                        const partitionObj = dataEntity['partitions'].get(partNum);
                                        this._deleteFromIndexes(dataEntity, delkey);
                                        delete partitionObj[delkey]; // delete the data that moved to other partition
                                    });
                                }
                                const partValues = partitionValues.get(partNum);
                                if (partValues) {
                                    partValues.forEach((updateVal) => {
                                        const pkVal = this._getPKValue(updateVal, dataEntity.metadata);
                                        // const partitionNum = this._calAllPartNums(metadata, updateVal)
                                        const partitionObj = dataEntity['partitions'].get(partNum);
                                        const oldRow = partitionObj[pkVal];
                                        this._deleteFromIndexes(dataEntity, oldRow); // delete the old row from indexes
                                        partitionObj[pkVal] = Object.assign(oldRow, value);
                                        this._insertIndexes(dataEntity, oldRow); // insert the new row into indexes
                                    });
                                }
                                else {
                                    // this should never happen. 
                                    txnLogger.logSevere('Partition write result abnormal: ' + result, txnId);
                                }
                            }
                        });
                    }
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    resolve({ status: true, results: results });
                }).catch(async (err) => {
                    await this._releaseResourceLock(dataEntity.metadata.name);
                    const errMsg = err.stack ? err.stack : err.message;
                    resolve({ status: false, message: errMsg });
                });
            }
        });
    }
    /**
     * Public functions
     */
    /**
     * Data query function in synchronize mode. This function should NOT be used when process pooling is enabled
     * @param dataEntityName Name of data entity
     * @param filter An object includes filter field name and value, e.g. {userId: 'a', sessionName: 's1'}
     */
    selectSync(dataEntityName, filter, options) {
        // TBD, should check cache for frequently queried data.
        const dataEntities = this[_dataEntities];
        const metadata = this[_dataEntityMetadata].get(dataEntityName);
        const opt = new SelectConstraints(options);
        if (!dataEntities[dataEntityName]) {
            this._logInfo('The data entity to retrieve does not exist : ' + dataEntityName);
            return { status: false, message: MSG_DATA_ENTITY_NOT_EXIST };
        }
        if (metadata.dataStrategy === DataStrategy.NO_CACHE && metadata.persistMethod === PersistMethod.PERSIST_METHOD_COMBINED_FILE) {
            return { status: false, message: MSG_FUN_NOT_IMPLEMENTED };
        }
        const de = dataEntities[dataEntityName];
        let result;
        if (!filter) {
            result = de.values;
        }
        else {
            result = this._filter(de, filter, opt);
        }
        if (!result) {
            return {
                dataEntityName: dataEntityName,
                rowCount: 0,
                data: []
            };
        }
        if (opt && opt.orderBy) {
            result = _.orderBy(result, opt.orderBy.fields, opt.orderBy.orders);
        }
        else if (opt && opt.pagination) {
            result = _.orderBy(result, metadata.primaryKeys);
        }
        const rowCount = result.length;
        let paginationResult = {};
        if (opt && opt.pagination) {
            const size = opt.pagination.size;
            const page = opt.pagination.page;
            const offset = (page - 1) * size;
            result = _.drop(result, offset).slice(0, size); // paged data
            paginationResult = {
                page: page,
                pageSize: size,
                total: rowCount,
                totalPages: _.ceil(rowCount / size)
            };
        }
        else {
            result = _.cloneDeep(result);
        }
        // TBD, should check whether to cache the search result.
        let returnValue = {
            dataEntityName: dataEntityName,
            rowCount: result.length,
            data: result
        };
        returnValue = _.assign(returnValue, paginationResult);
        return returnValue;
    }
    /**
     * Data query.
     *
     * @param dataEntityName Name of data entity
     * @param filter Optional. An object includes filter field name and value, e.g. {userId: 'a', sessionName: 's1'}
     * @param options Optional. An object includes options:
     * @param options.ignoreCaseFields Optional. An array of field names used as filter. The query on these fields will ignore case
     * @param options.orderBy Optional. Defines the orderBy rules.
     * @param options.orderBy.fields An array of field names to order by on
     * @param options.orderBy.orders An array of order ('asc' or 'desc'). The value index should match to the fields
     * @param options.pagination Optional. If you want BZDB to do pagination
     * @param options.pagination.page The page number
     * @param options.pagination.size Page size
     *
     * @returns Promise<any>
     * @returns {dataEntityName} String. Name of data entity
     * @returns {data} Array. Contains returned data
     * @returns {rowCount} Number. Row count of data returned
     * @returns {total} Number. When pagination, total is the total row count of the filter result
     * @returns {page} Number. When pagination, page number
     * @returns {pageSize} Number. When pagination, size of page
     * @returns {totalPages} Number. When pagination, count of pages
     */
    select(dataEntityName, filter, options) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                let returnObj = {};
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                    const valuesMap = await this._persistRead(metadata, undefined, filter);
                    const values = valuesMap ? Array.from(valuesMap.values()) : [];
                    if (values && Array.isArray(values)) {
                        const resultData = {};
                        const resultKeys = [];
                        let data = [];
                        const updateParts = {};
                        let rowCount = 0;
                        if (!metadata.persistMethod || metadata.persistMethod === PersistMethod.PERSIST_METHOD_COMBINED_FILE) {
                            const filters = Utils.splitObject(filter);
                            const tempPartitions = {};
                            values.forEach((partObj) => {
                                if (_.isEmpty(partObj))
                                    return;
                                const keysInPart = Object.keys(partObj);
                                const partNum = this._calAllPartNums(metadata, partObj[keysInPart[0]]);
                                tempPartitions[partNum] = partObj; // record the partion into tempPartitions
                                for (const keyInPart of keysInPart) { // Check each row of the partition
                                    const row = partObj[keyInPart];
                                    if (resultKeys.includes(keyInPart)) { // the PK already found in other partition
                                        const rowR = resultData[keyInPart];
                                        const rowP = partObj[keyInPart];
                                        if (rowR.timestamp >= rowP.timestamp) { // the row in this partition is old data
                                            // const partNum = this._calAllPartNums(metadata, rowP)
                                            delete partObj[keyInPart]; // delete the row from the partition
                                            updateParts[partNum] = partObj; // this part will be updated
                                            continue; // process next row
                                        }
                                        else { // the row in this partition is newer data
                                            const oldRowPartNum = this._calAllPartNums(metadata, rowR);
                                            const oldRowPart = tempPartitions[oldRowPartNum];
                                            delete oldRowPart[keyInPart];
                                            updateParts[oldRowPartNum] = oldRowPart; // this part will be updated
                                            resultData[keyInPart] = rowP;
                                        }
                                    }
                                    else { // the PK is not found in other partitions
                                        if (_.isEmpty(filters)) {
                                            resultData[keyInPart] = row;
                                            resultKeys.push(keyInPart);
                                        }
                                        else {
                                            let isPassed = false;
                                            for (const fl of filters) {
                                                const tempRows = _.filter([row], fl);
                                                if (tempRows.length > 0) {
                                                    isPassed = true;
                                                    break;
                                                }
                                            }
                                            if (isPassed) {
                                                resultData[keyInPart] = row;
                                                resultKeys.push(keyInPart);
                                            }
                                        }
                                    }
                                }
                            });
                            data = Object.values(resultData); // set return data
                            rowCount = data.length;
                            const dataEntity = this[_dataEntities][dataEntityName];
                            for (const partNum of Object.keys(updateParts)) { // update the partitions with outdated data
                                const filePath = this._getPathFromPK(dataEntity, partNum + '');
                                const option = {
                                    data: updateParts[partNum],
                                    path: filePath,
                                    metadata
                                    //how to test in this condition?
                                };
                                try {
                                    await this._addQueue({ option: option, type: 'add' });
                                    Logger.logInfo('Removed out-of-date row from Data Entity: ' + dataEntityName + ', partition: ' + partNum);
                                }
                                catch (err) {
                                    const errMsg = err.stack ? err.stack : err.message;
                                    Logger.logWarn('Partition file write error: ' + errMsg);
                                }
                            }
                        }
                        else { // PERSIST_METHOD_LIST_FILE or PERSIST_METHOD_ONLY_MEMORY
                            if (!_.isEmpty(filter) && !metadata.isNoPK) { // filter is not empty and has pk
                                data = _.filter(values, filter); // Apply the filter
                            }
                            else {
                                data = values;
                            }
                            rowCount = data.length;
                        }
                        returnObj = {
                            dataEntityName: dataEntityName,
                            rowCount,
                            data
                        };
                    }
                    else {
                        // this._logInfo('The data entity to retrieve does not exist : ' + dataEntityName + ';');
                        return resolve({
                            dataEntityName: dataEntityName,
                            rowCount: 0,
                            data: []
                        });
                    }
                }
                else {
                    returnObj = await this._selectFromCache(dataEntityName, filter, options);
                }
                const opt = new SelectConstraints(options);
                let dat = returnObj.data;
                if (opt && opt.orderBy) {
                    dat = _.orderBy(dat, opt.orderBy.fields, opt.orderBy.orders);
                }
                else if (opt && opt.pagination) {
                    dat = _.orderBy(dat, metadata.primaryKeys);
                }
                let paginationResult = {};
                if (opt && opt.pagination) {
                    const size = opt.pagination.size;
                    const page = opt.pagination.page;
                    const offset = (page - 1) * size;
                    dat = _.drop(dat, offset).slice(0, size); // paged data
                    paginationResult = {
                        page: page,
                        pageSize: size,
                        total: returnObj.rowCount,
                        totalPages: _.ceil(returnObj.rowCount / size)
                    };
                }
                else {
                    dat = _.cloneDeep(dat);
                }
                // TBD, should check whether to cache the search result.
                let returnValue = {
                    dataEntityName: dataEntityName,
                    rowCount: dat.length,
                    data: dat
                };
                returnValue = _.assign(returnValue, paginationResult);
                return resolve(returnValue);
            });
        });
    }
    /***
     * this function is designed to read all files from a folder and these files in this folder have different structure.
     * the return result like below
     *
     * {
     *    dataEntityName: 'dataEntityName',
     *    rowCount: 2,
     *    data: [
     *           {
     *               fileName:'xxx.json',
     *               data:{
     *                    name: 'aaaa',
     *                    type: 'atype'
     *               }
     *           },
     *           {
     *               fileName:'yyy.json',
     *               data:{
     *                    name: 'bbbb',
     *                    groupName:'test'
     *               }
     *           }
     *       ]
     *  }
     *
     */
    selectNoPKData(dataEntityName) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                let returnObj = {};
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                    let values = await this._persistReadNoPKData(metadata);
                    if (values && Array.isArray(values)) {
                        returnObj = {
                            dataEntityName: dataEntityName,
                            rowCount: values.length,
                            data: values
                        };
                    }
                    else {
                        this._logInfo('The data entity to retrieve does not exist : ' + dataEntityName + ';');
                        return resolve({
                            dataEntityName: dataEntityName,
                            rowCount: 0,
                            data: []
                        });
                    }
                }
                else {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_IS_NOCACHE });
                }
                return resolve(returnObj);
            });
        });
    }
    /**
     * Fully query the data entity and return the data in partitions (files).
     * @param dataEntityName
     * @returns
     */
    async partitions(dataEntityName) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                const de = this[_dataEntities][dataEntityName];
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                    const partitions = await this[_util].getDirFileContents(de.storagePath, metadata.fileName || metadata.fileNamePrefix || metadata.fileNameSurfix);
                    if (partitions && Array.isArray(partitions)) {
                        return resolve({
                            dataEntityName,
                            partitionCount: partitions.length,
                            partitions
                        });
                    }
                    else {
                        this._logInfo('The data entity to retrieve does not exist : ' + dataEntityName + ';');
                        return resolve({
                            dataEntityName: dataEntityName,
                            partitionCount: 0,
                            partitions: []
                        });
                    }
                }
                else {
                    const partitions = [];
                    if (metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE) {
                        for (let i = 0; i < de.keys.length; i++) {
                            const fileName = this._getFileNameFromMeta(metadata, de.keys[i] + '');
                            partitions.push({
                                fileName,
                                content: JSON.stringify(de.values[i])
                            });
                        }
                    }
                    else {
                        for (const entry of de.partitions.entries()) {
                            partitions.push({
                                fileName: this._getFileNameFromMeta(metadata, entry[0] + ''),
                                content: JSON.stringify(entry[1])
                            });
                        }
                    }
                    return resolve({
                        dataEntityName: dataEntityName,
                        partitionCount: partitions.length,
                        partitions
                    });
                }
            });
        });
    }
    writePartitions(parts) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'writePartitions',
                parts
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    /**
     * Fully overwrite data entity from partitions
     * @param parts
     * @returns
     */
    async _doWritePartitions(parts) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const { dataEntityName, partitionCount, partitions } = parts;
                if (!dataEntityName) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                this._logInfo('Write partitions for data entity: ' + dataEntityName);
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                const de = this[_dataEntities][dataEntityName];
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (!partitionCount || !partitions || partitions.length === 0) {
                    return resolve({ status: true, message: MSG_PARTITION_LOAD_SUCCESS });
                }
                const results = [];
                let isAllSuccess = true;
                for (const part of partitions) {
                    const { fileName, content } = part;
                    if (fileName && typeof (fileName) === 'string' && content && typeof (content) === 'string') {
                        const option = {
                            data: content,
                            path: path.join(de.storagePath, fileName),
                            isBuffer: true,
                            doFormat: false,
                            metadata // Fix bug. metadata is required by _addFile function
                        };
                        try {
                            //isBuffer: true, so there is no need to store
                            const result = await this._addQueue({ option: option, type: 'add' });
                            this._logDebug(MSG_PARTITION_LOAD_SUCCESS + '. File name: ' + fileName);
                            result.fileName = fileName;
                            results.push(result);
                        }
                        catch (e) {
                            isAllSuccess = false;
                            console.error(e);
                            this._logWarn(MSG_PARTITION_LOAD_FAIL + '. File name: ' + fileName + ', err: ' + (e.message || e));
                            results.push({ status: false, message: (e.message || e) });
                        }
                    }
                    else {
                        isAllSuccess = false;
                        const msg = 'Invalid partition data for ' + dataEntityName + '. fileName: ' + fileName;
                        this._logWarn(msg);
                        results.push({ status: false, message: msg });
                    }
                }
                if (metadata.dataStrategy === DataStrategy.NO_CACHE) {
                    // No more action
                }
                else {
                    try {
                        const result = await this.refreshDataEntity(dataEntityName); // reload the data from file
                        results.push(result);
                    }
                    catch (e) {
                        isAllSuccess = false;
                        console.error(e);
                        this._logSevere('Error while refresh data entity: ' + dataEntityName);
                        results.push({ status: false, message: (e.message || e) });
                    }
                }
                return resolve({ status: isAllSuccess, results });
            });
        });
    }
    delete(dataEntityName, filter, options) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'delete',
                dataEntityName: dataEntityName,
                filter: filter,
                options
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    /**
     * Addes data refreshing into wait ready status.
     */
    _statusReady() {
        const that = this;
        return new Promise((resolve) => {
            that[_promLoadReady].then(() => {
                if (that[_promsReload].length > 0) {
                    Promise.all(that[_promsReload]).then(() => {
                        resolve(true);
                    });
                }
                else {
                    resolve(true);
                }
            });
        });
    }
    _execDelete(dataEntityName, filter, options) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const txnId = options?.txnId;
                if (!options || !options.isSilent) {
                    txnLogger.logInfo(`Delete from ${dataEntityName} where filter is ${JSON.stringify(filter)} constraints: ${JSON.stringify(options?.constraints)}`, txnId);
                }
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('delete', dataEntityName, filter, constraints).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                if (!dataEntities[dataEntityName]) {
                    txnLogger.logInfo('The data entity to delete does not exist : ' + dataEntityName, txnId);
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                let de = dataEntities[dataEntityName];
                // Delete is not allowed when data entity is locked.
                // if (de.isLocked){
                //     return resolve({status: false, message: MSG_DATA_ENTITY_IS_LOCKED});
                // } else {
                //     de.isLocked = true;
                // }
                try {
                    try {
                        await this._obtainResourceLock(metadata.name); // Obtain the lock for the DE.
                    }
                    catch (e) {
                        txnLogger.logSevere('Error encountered while obtaining source lock: ' + e.message, txnId);
                        await this._releaseResourceLock(metadata.name);
                        return resolve({ status: false, message: e.message });
                    }
                    // If filter is empty, delete all data. Dangerous action!!!
                    const filterKeys = (!filter || typeof (filter) !== 'object') ? [] : Object.keys(filter);
                    if (filterKeys.length === 0) {
                        this._deleteAll(de, options).then(async (result) => {
                            await this._releaseResourceLock(metadata.name);
                            resolve(result);
                            // de.isLocked = false;
                        }).catch(async (err) => {
                            await this._releaseResourceLock(metadata.name);
                            resolve(err);
                            // de.isLocked = false;
                        });
                        return true;
                    }
                    this._deleteByFilter(de, filter, options).then(async (result) => {
                        await this._releaseResourceLock(metadata.name);
                        resolve(result);
                        // de.isLocked = false;
                    }).catch(async (err) => {
                        await this._releaseResourceLock(metadata.name);
                        resolve(err);
                        // de.isLocked = false;
                    });
                }
                catch (e) {
                    // de.isLocked = false;
                    await this._releaseResourceLock(metadata.name);
                    throw e;
                }
                // }
            });
        });
    }
    /**
     *
     * @param dataEntityName
     * @param value
     */
    insert(dataEntityName, value, options) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'insert',
                dataEntityName: dataEntityName,
                value: value,
                options
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    /**
     *
     * @param dataEntityName
     * @param value
     */
    _execInsert(dataEntityName, value, options) {
        return new Promise((resolve) => {
            this._statusReady().then(() => {
                const txnId = options?.txnId;
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (!options || !options.isSilent) {
                    if (metadata.encryptAttrs && metadata.encryptAttrs.length > 0) {
                        txnLogger.logInfo(`Insert into ${dataEntityName}`, txnId);
                    }
                    else {
                        txnLogger.logInfo(`Insert into ${dataEntityName} value ${JSON.stringify(value)}`, txnId);
                    }
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('insert', dataEntityName, value).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                if (!dataEntities[dataEntityName]) {
                    txnLogger.logInfo('The data entity to insert does not exist : ' + dataEntityName, txnId);
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (!value || Object.keys(value).length === 0) {
                    return resolve({ status: false, message: MSG_INSERT_DATA_IS_EMPTY });
                }
                let de = dataEntities[dataEntityName];
                if (metadata.dataStrategy !== DataStrategy.NO_CACHE) {
                    if (!this._isAllPKColIncluded(value, de.metadata)) {
                        return resolve({ status: false, message: MSG_INSERT_DATA_HAS_NO_KEY });
                    }
                }
                const pkVal = this._getPKValue(value, de.metadata);
                if (de.data[pkVal]) {
                    return resolve({ status: false, message: MSG_INSERT_DATA_DUPLICATED });
                }
                // Insert is not allowed when data entity is locked
                // if (de.isLocked){ // TBD set time out
                //     return resolve({status: false, message: MSG_DATA_ENTITY_IS_LOCKED});
                // } else {
                //     de.isLocked = true;
                // }
                this._insert(de, value, options).then(result => {
                    resolve(result);
                    // de.isLocked = false;
                }).catch(err => {
                    resolve(err);
                    // de.isLocked = false;
                });
                // }
            });
        });
    }
    /**
     *
     * @param dataEntityName
     * @param filter
     * @param value
     * @param constraints
     */
    update(dataEntityName, filter, value, options) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'update',
                dataEntityName: dataEntityName,
                filter: filter,
                value: value,
                options
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    _execUpdate(dataEntityName, filter, value, options) {
        return new Promise((resolve) => {
            this._statusReady().then(async () => {
                const txnId = options?.txnId;
                if (!options || !options.isSilent) {
                    txnLogger.logInfo(`Update ${dataEntityName} where filter is ${JSON.stringify(filter)}`, txnId);
                }
                txnLogger.logDebug(`Values: ${JSON.stringify(value)}`, txnId);
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('update', dataEntityName, filter, value, constraints).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                if (!dataEntities[dataEntityName]) {
                    txnLogger.logInfo('The data entity to insert does not exist : ' + dataEntityName, txnId);
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                let de = dataEntities[dataEntityName];
                if (this._isAnyPKColIncluded(value, de.metadata)) {
                    if (de.metadata['rejectPKonUpdate'] || (de.metadata['rejectPKonUpdate'] === undefined && this[_databaseMetadata].getRejectPKonUpdate())) {
                        return resolve({ status: false, message: MSG_UPDATE_PK });
                    }
                    else {
                        this._deletePKValue(value, de.metadata);
                    }
                }
                // Update is not allowed when data entity is locked
                // if (de.isLocked){
                //     return resolve({status: false, message: MSG_DATA_ENTITY_IS_LOCKED});
                // } else {
                //     de.isLocked = true;
                // }
                const isNoCache = metadata.dataStrategy === DataStrategy.NO_CACHE;
                const updateValues = isNoCache ? (await this.select(dataEntityName, filter, options?.constraints)).data
                    : this._filter(de, filter, options?.constraints);
                if (!updateValues || updateValues.length === 0) {
                    resolve({ status: true, message: MSG_UPDATE_DATA_NOT_EXIST });
                    // de.isLocked = false;
                }
                else {
                    if (isNoCache && metadata.persistMethod && metadata.persistMethod !== PersistMethod.PERSIST_METHOD_COMBINED_FILE) {
                        return resolve(await this._insert(de, value, options)); // this._deletePKValue(value, de.metadata); insert will check pk
                    }
                    this._update(de, updateValues, value, options).then(result => {
                        resolve(result);
                        // de.isLocked = false;
                    }).catch(err => {
                        const errMsg = err.stack ? err.stack : err.message;
                        resolve({ status: false, message: errMsg });
                        // de.isLocked = false;
                    });
                }
                // }
            });
        });
    }
    /**
     *
     * @param dataEntityName
     * @param value
     */
    updateOrInsert(dataEntityName, value, options) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'updateOrInsert',
                dataEntityName: dataEntityName,
                value: value,
                options
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    _execUpdateOrInsert(dataEntityName, value, options) {
        return new Promise((resolve) => {
            this._statusReady().then(() => {
                const txnId = options?.txnId;
                txnLogger.logDebug(`Update or Insert ${dataEntityName}`, txnId);
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('updateOrInsert', dataEntityName, value).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                if (!dataEntities[dataEntityName]) {
                    txnLogger.logInfo('The data entity to insert does not exist : ' + dataEntityName, txnId);
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                let de = dataEntities[dataEntityName];
                if (!this._isAllPKColIncluded(value, de.metadata)) {
                    return resolve({ status: false, message: MSG_INSERT_DATA_HAS_NO_KEY });
                }
                // Update is not allowed when data entity is locked
                // if (de.isLocked){
                //     return resolve({status: false, message: MSG_DATA_ENTITY_IS_LOCKED});
                // } else {
                //     de.isLocked = true;
                // }
                this._updateOrInsert(de, value, options).then(result => {
                    resolve(result);
                    // de.isLocked = false;
                }).catch(err => {
                    const errMsg = err.stack ? err.stack : err.message;
                    resolve({ status: false, message: errMsg });
                    // de.isLocked = false;
                });
                // }
            });
        });
    }
    bulkLoad(dataEntityName, values, options) {
        return new Promise((resolve) => {
            const execOptions = {
                action: 'bulkLoad',
                dataEntityName: dataEntityName,
                values: values,
                options
            };
            this._execInQueue(execOptions).then(result => {
                resolve(result);
            }).catch(err => {
                resolve(err);
            });
        });
    }
    _execBulkLoad(dataEntityName, values, options) {
        return new Promise((resolve) => {
            this._statusReady().then(() => {
                const txnId = options?.txnId;
                if (!options || !options.isSilent) {
                    txnLogger.logInfo(`Bulkload ${dataEntityName} row count: ${values.length} constraints: ${JSON.stringify(options?.bulkloadConstraints)}`, txnId);
                }
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('bulkLoad', dataEntityName, values, constraint).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                if (!dataEntities[dataEntityName]) {
                    txnLogger.logInfo('The data entity does not exist : ' + dataEntityName, txnId);
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                if (!values || values.length === 0) {
                    txnLogger.logInfo('The data to load is empty.', txnId);
                    return resolve({ status: true, message: 'The data to load is empty.' });
                }
                let de = dataEntities[dataEntityName];
                // Bulk load is not allowed when data entity is locked
                // if (de.isLocked){
                //     return resolve({status: false, message: MSG_DATA_ENTITY_IS_LOCKED});
                // } else {
                //     de.isLocked = true;
                // }
                this._bulkLoad(de, values, options).then(result => {
                    resolve(result);
                    // de.isLocked = false;
                }).catch(err => {
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                    // de.isLocked = false;
                });
                // }
            });
        });
    }
    /**
     * When data file changed by other process or so, the data in memory needs a reload
     * @param dataEntityName
     * @param values
     * @param constraint
     */
    _execWatchEvent(dataEntityName) {
        return new Promise((resolve) => {
            this[_promLoadReady].then(() => {
                this._logInfo('Handle data change for data entity: ' + dataEntityName);
                const changeStatus = this[_changedDataEntities].get(dataEntityName);
                if (!changeStatus || !changeStatus.fileNames || changeStatus.fileNames.length === 0) {
                    return resolve({ status: true, message: 'Data entity change status not exist' }); // INFO
                }
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                const dataEntities = this[_dataEntities];
                let de = dataEntities[dataEntityName];
                // Now the logic is to reload the whole data entity. This has potential performance issue. 
                // TBD, consider only reload the changed partition in future.
                this._manage(metadata, true, de.managedPartitions).then(result => {
                    this[_changedDataEntities].delete(dataEntityName);
                    this._logInfo('Refresh data succeed for: ' + dataEntityName);
                    resolve(result);
                }).catch(err => {
                    this._logSevere(err.message);
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                });
            });
        });
    }
    /**
     * WebDeployment is using this for upgrading.
     * @param dataEntityName
     */
    refreshDataEntity(dataEntityName) {
        return new Promise((resolve) => {
            this[_promLoadReady].then(() => {
                const metadata = this[_dataEntityMetadata].get(dataEntityName);
                if (!metadata) {
                    resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
                }
                // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
                // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
                // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
                //     this._forwardToProcesses('refreshDataEntity', dataEntityName).then( (result) => {
                //         return resolve (result);
                //     }).catch(err => {
                //         return resolve ({status: false, message: err.stack? err.stack: err.message});
                //     })
                // } else {
                const dataEntities = this[_dataEntities];
                let managedParts = null;
                if (dataEntities[dataEntityName]) {
                    managedParts = dataEntities[dataEntityName].managedPartitions;
                    // delete dataEntities[dataEntityName]; // The delete action should happen after the new data is loaded.
                }
                this._manage(metadata, true, managedParts).then((result) => {
                    resolve(result);
                }).catch(err => {
                    resolve({ status: false, message: err.stack ? err.stack : err.message });
                });
                // }
            });
        });
    }
    search() {
        // TBD, like the search engine, search any data includes a string in the values
    }
    getName() {
        return this.name;
    }
    waitLoadReady() {
        return new Promise((resolve) => {
            this[_promLoadReady].then(() => {
                resolve(true);
            });
        });
    }
    // public getLoadReport(){
    //     return this[_loadReport];
    // }
    changeLogger(config) {
        LoggerConfigurer.setWriter(config);
        // if (this.name === 'MainProcess'){
        //     for (let i = 0; i < this[_processPartitionMap].size; i ++){
        //         const process = this[_processPool][i];
        //         process('changeLogger', config);
        //     }
        // }
    }
    _selectFromCache(dataEntityName, filter, options) {
        const opt = new SelectConstraints(options);
        const metadata = this[_dataEntityMetadata].get(dataEntityName);
        // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
        // const isOnlyMemory = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_ONLY_MEMORY;
        return new Promise((resolve) => {
            // if (!isOnlyMemory && !isPersistListFile && this[_processPool] && this[_processPool].length > 0){
            //     this._logDebug('select from multi process');
            //     this._forwardToProcesses('select', dataEntityName, filter, options).then( (result) => {
            //         this._logDebug('select returned from multi process');
            //         return resolve (result);
            //     }).catch(err => {
            //         return resolve ({status: false, message: err.stack? err.stack: err.message});
            //     })
            // } else {            
            const dataEntities = this[_dataEntities];
            if (!dataEntities[dataEntityName]) {
                this._logInfo('The data entity to retrieve does not exist : ' + dataEntityName);
                return resolve({ status: false, message: MSG_DATA_ENTITY_NOT_EXIST });
            }
            const de = dataEntities[dataEntityName];
            // TBD, should check cache for frequently queried data.
            let result;
            if (!filter || _.isEmpty(filter)) {
                if (metadata.persistType === PersistType.PERSIST_TYPE_ARRAY) {
                    if (de.values && de.values[0])
                        result = de.values && de.values[0] ? de.values[0] : [];
                }
                else {
                    result = de.values;
                }
            }
            else {
                result = this._filter(de, filter, opt);
            }
            if (!result) {
                return resolve({
                    dataEntityName: dataEntityName,
                    rowCount: 0,
                    data: []
                });
            }
            let returnValue = {
                dataEntityName: dataEntityName,
                rowCount: result.length,
                data: result
            };
            return resolve(returnValue);
            // }
        });
    }
    /**
     *
     * @param dataEntityName
     * @param isIncludeRows Includes statistics for each row.
     * @param isDoHash Includes a hash of the row value into the row hash
     * @returns
     */
    async analyzeDataEntity(dataEntityName, isIncludeRows = true, isDoHash = false) {
        const metadata = this[_dataEntityMetadata].get(dataEntityName);
        if (!metadata) {
            return {
                name: dataEntityName
            };
        }
        const de = this[_dataEntities][dataEntityName];
        const statistics = {
            name: dataEntityName
        };
        // At most of times, data entity won't be changed frequently after server is stable. So the cache should improve performance a lot.
        const cachedData = this[_deAnalysisCache].get(dataEntityName);
        if (cachedData) {
            return cachedData;
        }
        // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
        const isNoCache = metadata.dataStrategy === DataStrategy.NO_CACHE;
        if (isNoCache) {
            if (metadata.analyzeMethod === AnalyzeMethod.ANALYZE_METHOD_FILE_SIZE) {
                /**
                 * In case of NO_CACHE, when data volume is big, selecting could be very slow.
                 * So, if the data entity could include big data volume, use AnalyzeMethod.ANALYZE_METHOD_FILE_SIZE to change the way to calculate file size.
                 */
                const dataPath = path.resolve(de.storagePath);
                const fileSizes = await this[_util].getDirFileSize(dataPath);
                let totalSize = 0;
                fileSizes.forEach((fsize) => {
                    totalSize += fsize.size;
                });
                statistics.stat = totalSize.toString();
                if (isIncludeRows) {
                    const rowStats = [];
                    const tmpStrs = [];
                    fileSizes.forEach((fsize) => {
                        const key = fsize.fileName;
                        const size = fsize.size;
                        let rs = key + '_' + size;
                        // if (isDoHash){ // In case of AnalyzeMethod.ANALYZE_METHOD_FILE_SIZE, it's not reading content of each file, so ignore this.
                        //     rs += '_' + Utils.generateHash(rs)
                        // }
                        rowStats.push([key, size]);
                        tmpStrs.push(rs);
                    });
                    statistics.rowStats = rowStats.sort((a, b) => {
                        return a[0] > b[0] ? 1 : -1;
                    });
                    statistics.rowStatsHash = Utils.generateHash(_.join(_.sortBy(tmpStrs), '|'));
                }
            }
            else {
                const result = await this.select(dataEntityName);
                statistics.stat = result.rowCount;
                if (isIncludeRows) {
                    const rowStats = [];
                    const tmpStrs = [];
                    const data = result.data;
                    if (!metadata.isNoPK) {
                        data.forEach((val) => {
                            const key = this._getPKValue(val, metadata);
                            const ts = val.timestamp || 0;
                            let rs = key + '_' + ts;
                            if (isDoHash) {
                                rs += '_' + Utils.generateHash(JSON.stringify(val));
                            }
                            rowStats.push([key, ts]);
                            tmpStrs.push(rs);
                        });
                    }
                    else { // No PK
                        data.forEach((val, index) => {
                            const ts = val.timestamp || Utils.generateHash(JSON.stringify(val));
                            let rs = index + '_' + ts;
                            if (isDoHash && val.timestamp) {
                                rs += '_' + Utils.generateHash(JSON.stringify(val));
                            }
                            rowStats.push([index, ts]);
                            tmpStrs.push(rs);
                        });
                    }
                    statistics.rowStats = rowStats.sort((a, b) => {
                        return a[0] > b[0] ? 1 : -1;
                    });
                    statistics.rowStatsHash = Utils.generateHash(_.join(_.sortBy(tmpStrs), '|'));
                }
            }
        }
        else {
            const rowCount = de.keys.length;
            let firstTimestamp = 0;
            let lastTimestamp = 0;
            if (de.metadata.persistType === PersistType.PERSIST_TYPE_ARRAY) {
                // PersistType.PERSIST_TYPE_ARRAY has different memory storage format, and this is wrong. 
                // The inmomory storage format is the basic design, and we should keep it same for all kinds of persistType.
                // select for PersistType.PERSIST_TYPE_ARRAY is also wrong.
                // Below is just a quick fix for the issue, but not the correct solution.
                // TBD, if we still need support this kind of persistType, we need fix it in future. 
                const realValues = de.values[0];
                if (realValues && realValues.length !== undefined && realValues.length > 0) {
                    const fts = realValues[0].timestamp;
                    firstTimestamp = fts === undefined ? 0 : fts;
                    const lts = realValues[realValues.length - 1].timestamp;
                    lastTimestamp = lts === undefined ? 0 : lts;
                }
            }
            else if (rowCount > 0) {
                const fts = de.values[0].timestamp;
                firstTimestamp = fts === undefined ? 0 : fts;
                const lts = de.values[rowCount - 1].timestamp;
                lastTimestamp = lts === undefined ? 0 : lts;
            }
            statistics.stat = rowCount + '_' + firstTimestamp + '_' + lastTimestamp;
            if (isIncludeRows) {
                const rowStats = [];
                const tmpStrs = [];
                if (de.metadata.persistType === PersistType.PERSIST_TYPE_ARRAY) {
                    // Again, special logic for PERSIST_TYPE_ARRAY...
                    const realValues = de.values[0];
                    if (realValues && Array.isArray(realValues) && realValues.length > 0) {
                        realValues.forEach((val, idx) => {
                            const id = val['id'] || idx;
                            let ts = val['timestamp'] || 0;
                            let rs = id + '_' + ts;
                            if (de.metadata.syncFile4Cluster) {
                                // BZ-15355, sync file for cluster
                                const fsi_stat = FileSync.getRealFileState(this[_basePath], val);
                                ts += fsi_stat;
                                rs += fsi_stat;
                            }
                            if (isDoHash) {
                                rs += '_' + Utils.generateHash(JSON.stringify(val));
                            }
                            rowStats.push([id, ts]);
                            tmpStrs.push(rs);
                        });
                    }
                }
                else {
                    de.keys.forEach((key, idx) => {
                        const val = de.values[idx];
                        let ts = val.timestamp || 0;
                        let rs = key + '_' + ts;
                        if (de.metadata.syncFile4Cluster) {
                            // BZ-15355, sync file for cluster
                            const fsi_stat = FileSync.getRealFileState(this[_basePath], val);
                            ts += fsi_stat;
                            rs += fsi_stat;
                        }
                        if (isDoHash) {
                            rs += '_' + Utils.generateHash(JSON.stringify(val));
                        }
                        rowStats.push([key, ts]);
                        tmpStrs.push(rs);
                    });
                }
                statistics.rowStats = rowStats.sort((a, b) => {
                    return a[0] > b[0] ? 1 : -1;
                });
                statistics.rowStatsHash = Utils.generateHash(_.join(_.sortBy(tmpStrs), '|'));
            }
            // To be safe, DE Analysis cache is implemented for cached DEs only.
            // For NO_CACHE, we suppose the data file could be changed without BZDB, 
            // so analysis could be changed without awareness of BZDB.
            if (metadata.syncFile4Cluster !== true) {
                this[_deAnalysisCache].set(dataEntityName, statistics);
            }
        }
        this._logDebug('Data entity: ' + statistics.name + ', stat value: ' + statistics.stat);
        return statistics;
    }
    /**
     *
     * @param dataEntityName
     * @returns
     */
    async count(dataEntityName) {
        const metadata = this[_dataEntityMetadata].get(dataEntityName);
        if (!metadata) {
            return { status: false, message: 'Unknown Data Entity', rowCount: 0 };
        }
        const de = this[_dataEntities][dataEntityName];
        let rowCount = 0;
        // const isPersistListFile = metadata.persistMethod && metadata.persistMethod === PersistMethod.PERSIST_METHOD_LIST_FILE;
        const isNoCache = metadata.dataStrategy === DataStrategy.NO_CACHE;
        if (isNoCache) {
            const result = await this.select(dataEntityName);
            rowCount = result.rowCount;
        }
        else {
            rowCount = de.keys.length;
            if (de.metadata.persistType === PersistType.PERSIST_TYPE_ARRAY) {
                // PersistType.PERSIST_TYPE_ARRAY has different memory storage format, and this is wrong. 
                // The inmomory storage format is the basic design, and we should keep it same for all kinds of persistType.
                // select for PersistType.PERSIST_TYPE_ARRAY is also wrong.
                // Below is just a quick fix for the issue, but not the correct solution.
                // TBD, if we still need support this kind of persistType, we need fix it in future. 
                const realValues = de.values[0];
                if (realValues) {
                    rowCount = realValues.length;
                }
            }
        }
        return { status: true, rowCount };
    }
    async _appendExtend() {
        const extendEntity = new DataEntityMetadata(CONFIG.EXTEND_ENTITY_META);
        if (!this[_dataEntityMetadata].has(extendEntity.name)) {
            this[_dataEntityMetadata].set(extendEntity.name, extendEntity);
        }
        await this._loadEntity(extendEntity);
        await this._appendExtendEntity();
        return { status: true, message: `append Extend ${extendEntity.name} success` };
    }
    async _appendExtendEntity() {
        //select extend entity definition 
        const extendEntity = new DataEntityMetadata(CONFIG.EXTEND_ENTITY_META);
        const entities = await this._persistRead(extendEntity);
        if (entities) {
            for await (let entity of Array.from(entities.values())) {
                const dMetaData = new DataEntityMetadata(entity);
                this._logInfo('append Extend Entity: ' + entity.name);
                await this._loadEntity(dMetaData);
                if (!this[_dataEntityMetadata].has(dMetaData.name)) {
                    this[_dataEntityMetadata].set(dMetaData.name, dMetaData);
                }
            }
        }
        return { status: true, message: `append Extend entities success` };
    }
    async _loadEntity(dMetaData) {
        const result = await this._manage(dMetaData);
        if (result.status === 'success' || result.message === 'Data entity already exist' || dMetaData.name === CONFIG.EXTEND_ENTITY) {
            this[_dataEntityMetadata].set(dMetaData.name, dMetaData);
        }
        else {
            // once faild, clear data
            this._releaseEntity(dMetaData.name);
        }
        return result;
    }
    _releaseEntity(entityName) {
        if (this[_dataEntityMetadata].has(entityName)) {
            this[_dataEntityMetadata].delete(entityName);
        }
        if (this[_dataEntities][entityName]) {
            delete this[_dataEntities][entityName];
        }
    }
    async create(type, value, options) {
        txnLogger.logInfo('bluezone-database::create, type: ' + type + "value:" + JSON.stringify(value), options?.txnId);
        const dMetaData = new DataEntityMetadata(value);
        if (!this[_dataEntityMetadata].has(dMetaData.name)) { //exist, can not create again
            if (type === "ENTITY" /* SchemaType.PERSIST_ENTITY */) {
                let result = await this.insert(CONFIG.EXTEND_ENTITY, value, options);
                if (result.status) {
                    result = await this._loadEntity(dMetaData);
                    result.status = result.status === 'success' ? true : false;
                }
                return result;
            }
            else if (type === "TEMP ENTITY" /* SchemaType.TEMP_ENTITY */) {
                let result = await this._loadEntity(dMetaData);
                result.status = result.status === 'success' ? true : false;
                return result;
            }
            else {
                return { status: false, message: 'no such SchemaType' };
            }
        }
        else {
            return { status: false, message: 'exist Data entity' };
        }
    }
    //will drop all the data and it's entity meta data
    async drop(type, entityName, options) {
        this._logInfo('bluezone-database::destroy, type: ' + type + "name:" + entityName);
        if (type === "ENTITY" /* SchemaType.PERSIST_ENTITY */) {
            const entityMetas = await this.select(CONFIG.EXTEND_ENTITY, { name: entityName });
            if (entityMetas.data && entityMetas.data.length > 0) {
                await this.delete(entityName, {}, options); //remove all data
                await this.delete(CONFIG.EXTEND_ENTITY, { name: entityName }, options);
            }
        }
        this._releaseEntity(entityName);
        return { status: true, message: `delete ${entityName} success ` };
    }
}
// class LoadEventEmitter extends EventEmitter{}
export { BlueZoneDatabase };
// module.exports = {
//     getInstance(isPooledProcess: boolean = false): BlueZoneDatabase {
//         if (! bzdb){
//             bzdb = new BlueZoneDatabase(isPooledProcess);
//         }
//         return bzdb;
//     }
// }
// const bzdb = new BlueZoneDatabase();
// module.exports = bzdb;
