// import { BzdbLogger, DefaultLogger } from '../services/logger';
import { Utils } from '../services/index.js';
import path from 'path';
// import { isNumber } from 'util';
import _ from 'lodash';
const DEFAULT_PERSIST_PARTITION_COUNT = 20;
var IntegratyLevel;
(function (IntegratyLevel) {
    IntegratyLevel[IntegratyLevel["INTEGRATY_STRONG"] = 1] = "INTEGRATY_STRONG";
    IntegratyLevel[IntegratyLevel["INTEGRATY_MIDIUM"] = 2] = "INTEGRATY_MIDIUM";
    IntegratyLevel[IntegratyLevel["INTEGRATY_WEAK"] = 3] = "INTEGRATY_WEAK"; // Allow txn even in data conflict / out of date
})(IntegratyLevel || (IntegratyLevel = {}));
var AnalyzeMethod;
(function (AnalyzeMethod) {
    AnalyzeMethod[AnalyzeMethod["ANALYZE_METHOD_SELECT"] = 1] = "ANALYZE_METHOD_SELECT";
    AnalyzeMethod[AnalyzeMethod["ANALYZE_METHOD_FILE_SIZE"] = 2] = "ANALYZE_METHOD_FILE_SIZE";
})(AnalyzeMethod || (AnalyzeMethod = {}));
var PersistMethod;
(function (PersistMethod) {
    PersistMethod[PersistMethod["PERSIST_METHOD_LIST_FILE"] = 1] = "PERSIST_METHOD_LIST_FILE";
    PersistMethod[PersistMethod["PERSIST_METHOD_COMBINED_FILE"] = 2] = "PERSIST_METHOD_COMBINED_FILE";
    PersistMethod[PersistMethod["PERSIST_METHOD_ONLY_MEMORY"] = 3] = "PERSIST_METHOD_ONLY_MEMORY";
})(PersistMethod || (PersistMethod = {}));
var PersistType;
(function (PersistType) {
    PersistType[PersistType["PERSIST_TYPE_ARRAY"] = 1] = "PERSIST_TYPE_ARRAY";
    PersistType[PersistType["PERSIST_TYPE_OBJECT"] = 2] = "PERSIST_TYPE_OBJECT";
    PersistType[PersistType["PERSIST_TYPE_RAW"] = 3] = "PERSIST_TYPE_RAW";
    PersistType[PersistType["PERSIST_TYPE_YAML"] = 4] = "PERSIST_TYPE_YAML";
})(PersistType || (PersistType = {}));
var SyncMode;
(function (SyncMode) {
    SyncMode[SyncMode["SYNC_ALL"] = 1] = "SYNC_ALL";
    SyncMode[SyncMode["SYNC_LOCAL"] = 2] = "SYNC_LOCAL"; // don't sync data, just updat in current node
})(SyncMode || (SyncMode = {}));
/**
 * Removed
 */
// enum ProcessPooling {
//     NONE = 0,
//     ONE = 1,
//     // TWO = 2,
//     // FOUR = 4,
//     // SIX = 6,
//     // EIGHT = 8,
//     // TEN = 10,
//     // SIXTEEN = 16,
//     // TWENTY = 20,
//     AUTO = 2  // CPU count - 1
// }
var DataStrategy;
(function (DataStrategy) {
    DataStrategy[DataStrategy["FILE_NO_WATCH"] = 0] = "FILE_NO_WATCH";
    DataStrategy[DataStrategy["FILE_WATCH"] = 1] = "FILE_WATCH";
    DataStrategy[DataStrategy["MEMORY_ONLY"] = 2] = "MEMORY_ONLY";
    DataStrategy[DataStrategy["NO_CACHE"] = 3] = "NO_CACHE"; // TBD, Data is not in memory.
})(DataStrategy || (DataStrategy = {}));
var EntityType;
(function (EntityType) {
    EntityType[EntityType["PERSIST"] = 0] = "PERSIST";
    EntityType[EntityType["TEMP"] = 1] = "TEMP";
})(EntityType || (EntityType = {}));
// Cluster peer discovery methods.
export var PeerDiscovery;
(function (PeerDiscovery) {
    PeerDiscovery["MULTICAST_DNS"] = "mdns";
    PeerDiscovery["BOOTSTRAP"] = "bootstrap";
})(PeerDiscovery || (PeerDiscovery = {}));
export var ClusterNodeType;
(function (ClusterNodeType) {
    ClusterNodeType["PERSISTENT"] = "persistent";
    ClusterNodeType["SCALABLE"] = "scalable";
})(ClusterNodeType || (ClusterNodeType = {}));
export var DATA_CONFLICT_POLICY;
(function (DATA_CONFLICT_POLICY) {
    DATA_CONFLICT_POLICY[DATA_CONFLICT_POLICY["MARK_CONFLICT"] = 0] = "MARK_CONFLICT";
    DATA_CONFLICT_POLICY[DATA_CONFLICT_POLICY["CUT_SHORTER_CHAIN"] = 1] = "CUT_SHORTER_CHAIN"; // Take the longer chain as correct, force pull
})(DATA_CONFLICT_POLICY || (DATA_CONFLICT_POLICY = {}));
class DatabaseMetadata {
    /**
     * @param metadata The database metadata
     * @param metadata.appName : string, the application name who is using BZDB
     * @param metadata.storePath : string
     * @param metadata.dataEntities : [DataEntityMetadata]
     * @param metadata.logging : logger.LoggerConfig
     * @param metadata.OnLoadReady : Function
     * @param metadata.memoryOnly : boolean
     * @param metadata.watchDataChanges : boolean
     * @param metadata.rejectPKonUpdate : boolean
     * @param metadata.enableWorkerThread: boolean. If true, the db-worker will run in a seperate thread.
     * @param metadata.cluster: MetaCluster
     * @param metadata.performance.workOnBusy: boolean. If true, the db won't reject any request even when process is busy
     * @param metadata.autoResolveConflict: auto resolve data conflict
     */
    constructor(metadata) {
        // console.log('_metadata: ' + JSON.stringify(metadata));
        this._metadata = metadata;
        this._storePath = path.join(process.cwd(), './_db_store');
        if (metadata) {
            if (metadata.storePath && typeof (metadata.storePath) === 'string') {
                this._storePath = path.join(process.cwd(), metadata.storePath, './_db_store');
            }
            // const inputPooling: number = metadata.processPooling;
            // if (inputPooling && inputPooling === 1){
            //     this._processPooling = ProcessPooling.ONE;
            // } else if (inputPooling && inputPooling >= 2){
            //     this._processPooling = ProcessPooling.AUTO;
            // } else {
            //     this._processPooling = ProcessPooling.NONE;
            // }
            this._dataEntityMetadata = new Map();
            const dataEntities = metadata.dataEntities;
            if (dataEntities && Array.isArray(dataEntities)) {
                dataEntities.forEach((de) => {
                    if (de.name) {
                        this._dataEntityMetadata.set(de.name, new DataEntityMetadata(de));
                    }
                });
            }
            const onLoadReady = metadata.OnLoadReady;
            if (onLoadReady && typeof (onLoadReady) === 'function') {
                this._onLoadReady = onLoadReady;
            }
            else {
                this._onLoadReady = () => { };
            }
            this._dataStrategy = metadata.memoryOnly ? DataStrategy.MEMORY_ONLY :
                metadata.watchDataChanges ? DataStrategy.FILE_WATCH :
                    DataStrategy.FILE_NO_WATCH;
            this._rejectPKonUpdate = metadata['rejectPKonUpdate'] ? true : false;
            this.parseClusterSettings();
            this._performance = metadata.performance;
            this._conflictPolicy = Number(this._metadata['conflictPolicy'] ?? 0) || 0;
        }
    }
    /**
     * Here includes user configurations, and requires better validation.
     */
    parseClusterSettings() {
        this._cluster = {
            enabled: true,
            autoScaling: {
                enabled: false,
                discovery: PeerDiscovery.MULTICAST_DNS,
                nodeType: ClusterNodeType.PERSISTENT,
                peerList: [],
                pnetMasks: [],
                ipBlackList: [] // Exclude some specific IP addresses inside the sub network
            }
        };
        if (this._metadata.cluster !== undefined) {
            const clusterEnabled = this._metadata.cluster.enabled;
            if (clusterEnabled !== undefined) {
                this._cluster.enabled = clusterEnabled === true; // We only accept the boolean value "true"
            }
            if (this._metadata.cluster.proxy) {
                this._cluster.proxy = {};
                if (this._metadata.cluster.proxy.protocol && this._metadata.cluster.proxy.protocol.length > 0) {
                    this._cluster.proxy.protocol = this._metadata.cluster.proxy.protocol;
                }
                if (this._metadata.cluster.proxy.ip && this._metadata.cluster.proxy.ip.length > 0) {
                    this._cluster.proxy.ip = this._metadata.cluster.proxy.ip;
                }
                if (this._metadata.cluster.proxy.port && this._metadata.cluster.proxy.port.length > 0) {
                    this._cluster.proxy.port = this._metadata.cluster.proxy.port;
                }
            }
            if (this._metadata.cluster.autoScaling !== undefined) {
                const asEnabled = this._metadata.cluster.autoScaling.enabled;
                if (asEnabled !== undefined) {
                    this._cluster.autoScaling.enabled = asEnabled === true; // We only accept the boolean value "true"
                }
                if (this._cluster.autoScaling.enabled === true) {
                    if (this._metadata.cluster.autoScaling.discovery !== undefined) {
                        if (this._metadata.cluster.autoScaling.discovery === PeerDiscovery.BOOTSTRAP) {
                            this._cluster.autoScaling.discovery = this._metadata.cluster.autoScaling.discovery;
                            this._cluster.autoScaling.peerList = this._metadata.cluster.autoScaling.peerList || [];
                        }
                        else {
                            // use the default value 'mdns'
                        }
                    }
                    const nodeType = this._metadata.cluster.autoScaling.nodeType;
                    if (nodeType === ClusterNodeType.SCALABLE) {
                        this._cluster.autoScaling.nodeType = ClusterNodeType.SCALABLE;
                    }
                    const pnetMasks = this._metadata.cluster.autoScaling.pnetMasks;
                    if (pnetMasks !== undefined && Array.isArray(pnetMasks)) {
                        // TBD, validate subnet mask format
                    }
                    const ipBlackList = this._metadata.cluster.autoScaling.ipBlackList;
                    if (ipBlackList !== undefined && Array.isArray(ipBlackList)) {
                        // TBD, validate IP address format
                    }
                }
            }
        }
    }
    get cluster() {
        return this._cluster;
    }
    get logging() {
        return this._metadata.logging;
    }
    isWorkOnBusy() {
        return this._performance?.workOnBusy === true;
    }
    isWorkerThreadEnabled() {
        return this._metadata['enableWorkerThread'] === true;
    }
    get conflictPolicy() {
        return this._conflictPolicy;
    }
    getDataStrategy() {
        return this._dataStrategy;
    }
    getMetaData() {
        return this._metadata;
    }
    setStorePath(relevantPathtoCwd) {
        this._storePath = path.join(process.cwd(), relevantPathtoCwd, './_db_store');
    }
    getStorePath() {
        return this._storePath;
    }
    // setProcessPooling(pooling: ProcessPooling): void{
    //     this._processPooling = pooling;
    // }
    // getProcessPooling(): ProcessPooling{
    //     return this._processPooling
    // }
    setDataEntity(metadata) {
        if (metadata && metadata.name) {
            this._dataEntityMetadata.set(metadata.name, metadata);
        }
    }
    getDataEntities() {
        return this._dataEntityMetadata;
    }
    // overrideLogger(logger: BzdbLogger): void{
    //     this._logger = logger;
    // }
    // getLogger(): BzdbLogger {
    //     return this._logger;
    // }
    getOnLoadReady() {
        return this._onLoadReady;
    }
    setOnLoadReady(cb) {
        this._onLoadReady = cb;
    }
    setRejectPKonUpdate(val) {
        this._rejectPKonUpdate = val;
    }
    getRejectPKonUpdate() {
        return this._rejectPKonUpdate;
    }
}
class DataEntityMetadata {
    constructor(deObj) {
        this.isAllowSubFolder = false;
        this.isNonPKPartitioned = false;
        this.syncFile4Cluster = false;
        this.isNoPK = false; // Has no PK or PK is empty
        this.isInternal = false;
        Object.assign(this, deObj);
        if (this.primaryKeys === undefined) { // give primaryKeys a default value
            this.primaryKeys = [];
        }
        if (!this.persistMethod)
            this.persistMethod = PersistMethod.PERSIST_METHOD_COMBINED_FILE;
        this.isNoPK = _.isEmpty(this.primaryKeys);
        if (_.isEmpty(this.partitions)) {
            if (!this.isNoPK) {
                // Utils.cartesian([this.primaryKeys, [DEFAULT_PERSIST_PARTITION_COUNT]])
                this.partitions = _.fromPairs(Utils.cartesian([this.primaryKeys, [DEFAULT_PERSIST_PARTITION_COUNT]]));
                // console.log(this.partitions)
            }
            else {
                this.partitions = {};
            }
        }
        else {
            this.isNonPKPartitioned = !_.isEqual(Object.keys(this.partitions), this.primaryKeys);
        }
        if (!this.requiredCols)
            this.requiredCols = [];
        this.primaryKeys?.forEach(pk => {
            if (!this.requiredCols.includes(pk))
                this.requiredCols.push(pk);
        });
        this.getPartitionColumn().forEach(pc => {
            if (!this.requiredCols.includes(pc))
                this.requiredCols.push(pc);
        });
    }
    validateRequiredCol(row) {
        return _.difference(this.requiredCols, Object.keys(row)).length === 0;
    }
    getPartitionColumn() {
        return Object.keys(this.partitions);
    }
    getPartitionCount(col) {
        return this.partitions[col];
    }
}
;
class SelectConstraints {
    /**
     *
     * @param options
     * @param options.ignoreCaseFields: string []
     * @param options.orderBy: {fields: string[], order: 'asc' | 'desc'}
     * @param options.pagination: {size: number, page: number}
     */
    constructor(options) {
        if (options && options.ignoreCaseFields && Array.isArray(options.ignoreCaseFields)) {
            this.ignoreCaseFields = options.ignoreCaseFields;
        }
        else {
            this.ignoreCaseFields = [];
        }
        if (options && options.orderBy && options.orderBy.fields && Array.isArray(options.orderBy.fields)) {
            const orders = [];
            if (options.orderBy.orders && Array.isArray(options.orderBy.orders)) {
                for (let i = 0; i < options.orderBy.fields.length; i++) {
                    let order = "asc" /* SortOrder.ASC */;
                    let ord = options.orderBy.orders[i];
                    ord = ord ? ord.toLowerCase() : 'asc';
                    if ('desc' === ord || 'descend' === ord || 'descending' === ord) {
                        order = "desc" /* SortOrder.DESC */;
                    }
                    orders.push(order);
                }
            }
            this.orderBy = { fields: options.orderBy.fields, orders: orders };
        }
        if (options && options.pagination && !isNaN(options.pagination.size) && !isNaN(options.pagination.page)
            && options.pagination.size > 0 && options.pagination.page > 0) {
            this.pagination = { size: options.pagination.size, page: options.pagination.page };
        }
    }
    addIgnoreCaseFields(fieldName) {
        if (!this.ignoreCaseFields)
            this.ignoreCaseFields = [];
        this.ignoreCaseFields.push(fieldName);
        return this;
    }
}
class BulkLoadConstraints {
    constructor() {
        this.setReplaceAsDeleteInsert();
    }
    setReplaceAsDeleteInsert() {
        this.replaceStrategy = 1 /* BulkLoadReplaceStrategy.DELETE_INSERT */;
    }
    isReplaceAsDeleteInsert() {
        return this.replaceStrategy === 1 /* BulkLoadReplaceStrategy.DELETE_INSERT */;
    }
    setReplaceAsUpdate() {
        this.replaceStrategy = 2 /* BulkLoadReplaceStrategy.UPDATE */;
    }
    isReplaceAsUpdate() {
        return this.replaceStrategy === 2 /* BulkLoadReplaceStrategy.UPDATE */;
    }
    setReplaceAsIgnore() {
        this.replaceStrategy = 3 /* BulkLoadReplaceStrategy.IGNORE */;
    }
    isReplaceAsIgnore() {
        return this.replaceStrategy === 3 /* BulkLoadReplaceStrategy.IGNORE */;
    }
}
export { DataEntityMetadata, PersistMethod, PersistType, SelectConstraints, BulkLoadConstraints, DatabaseMetadata, DataStrategy, SyncMode, EntityType, AnalyzeMethod, IntegratyLevel };
