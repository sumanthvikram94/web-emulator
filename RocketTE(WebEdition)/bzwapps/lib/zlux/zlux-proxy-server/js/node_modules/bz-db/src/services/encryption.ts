
import crypto from 'crypto'

class Encryption{

  static rKey = Buffer.from([145, 116, 54, 181, 215, 23, 211, 238, 143, 184, 191, 134, 142, 153, 69, 143, 192, 179, 40, 219, 10, 83, 145, 72, 199, 67, 146, 248, 2, 245, 190, 113]);
  static rIV= Buffer.from([145, 116, 54, 181, 215, 23, 211, 238, 143, 184, 191, 134, 142, 153, 69, 143]);
  static rString = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';

  static encryptWithKeyAndIV(text: string,key: any,iv: Buffer){
      var cipher = crypto.createCipheriv('AES-256-CBC',key,iv);
      var encrypted = cipher.update(text,'utf8','hex');
      encrypted += cipher.final('hex');
      return encrypted;
  }

  static decryptWithKeyAndIV(text: string,key: any,iv: Buffer): any {
    const cipher = crypto.createDecipheriv('AES-256-CBC',key,iv);
    let decrypted = cipher.update(text,'hex','utf8');
    decrypted += cipher.final('utf8');
    return decrypted;
  }

  static getKeyFromValue(text: crypto.BinaryLike,salt: crypto.BinaryLike,length: any,callback: any) {
    const rounds = 500;
    crypto.pbkdf2(text,salt,rounds,length,'sha256',(error, derivedKey) => {
      if (error) {
        throw error;
      } else {
        callback(derivedKey);
      }
    });
  }

  static getKeyFromValueSync(value: crypto.BinaryLike,salt: any,length: any) {
    const rounds = 500;
    return crypto.pbkdf2Sync(value,salt,rounds,length,'sha256');
  }
    
  static generateSaltIv(value: string){
    let saltBytes = new Array(16);
    for (let i = 0; i < 16; i++) {
      var num = this.rString.charCodeAt(Math.round(Math.random() * 62));
      var randChar = value.charCodeAt(Math.round(Math.random() * value.length));
      saltBytes[i] = (num > randChar) ? num : randChar;
    }
    const salt = String.fromCharCode.apply(null, saltBytes);

    let ivBytes = new Array(16);
    for (let i = 0; i < 16; i++) {
      ivBytes[i] = this.rString.charCodeAt(Math.round(Math.random() * 62));
    }
    const iv = String.fromCharCode.apply(null, ivBytes);
    return {salt,iv}
  }

  static encryptWithKeyConstIV(text:string,akey:string) {
    text = this.encryptWithKeyAndIV(text, akey, this.rIV);
    let key = this.encryptWithKeyAndIV(akey, this.rKey, this.rIV);
    return {
        text,
        key
    };
  }
  
  static decryptWithKeyConstIV(text:string,akey:string) {
    try {
        const key = this.decryptWithKeyAndIV(akey, this.rKey, this.rIV);
        text = this.decryptWithKeyAndIV(text, key, this.rIV);
    } catch (e) {
      text = text;
    } finally {
        return text;
    }
  }

  // static encrypt(encryptAttrs: string[], data: any): Promise<any>{
  //   return new Promise((resolve,reject) => {
  //     try{
  //       if(!encryptAttrs || encryptAttrs.length === 0){
  //         resolve(data);
  //       }else{
  //         let count = encryptAttrs.length;
  //         if(count > 0){
  //           let _encryptAttrs = [...encryptAttrs];
  //           for (let i = count-1; i >= 0 ; i-- ){
  //             if(!data[_encryptAttrs[i]]){
  //               _encryptAttrs.splice(i,1);
  //             }
  //           }
  //           let loopNum = _encryptAttrs.length;
  //           if(loopNum > 0){
  //             for(const _encryptAttr of _encryptAttrs){
  //               data[_encryptAttr] = this.encryptWithKeyAndIV(data[_encryptAttr], this.rKey, this.rIV);
  //               if( --loopNum  === 0 ){
  //                 resolve(data);
  //               }
  //             }
  //           }else{
  //             resolve(data);
  //           }
  //         }else{
  //           resolve(data);
  //         }
  //       }
  //     }catch(error){
  //       reject(error)
  //     }
  //   });
  // }

  //encryption from one factor
  static encrypt(encryptAttrs: string[], data: any): Promise<any>{
    return new Promise((resolve,reject) => {
      try{
        if(!encryptAttrs || encryptAttrs.length === 0 || data.salt){
          resolve(data);
        }else{
          let count = encryptAttrs.length;
          if(count > 0){
            let _encryptAttrs = [...encryptAttrs];
            for (let i = count-1; i >= 0 ; i-- ){
              if(!data[_encryptAttrs[i]]){
                _encryptAttrs.splice(i,1);
              }
            }
            let loopNum = _encryptAttrs.length;
            if(loopNum > 0){
              const saltIvObj = this.generateSaltIv(_encryptAttrs.join(','));
              for(const _encryptAttr of _encryptAttrs){
                this.getKeyFromValue(_encryptAttr,saltIvObj.salt, 32, (key: any) => {
                  if(key){
                    data[_encryptAttr] = this.encryptWithKeyAndIV(data[_encryptAttr], key, this.rIV);
                    if( --loopNum  === 0 ){
                      data.salt = this.encryptWithKeyAndIV(saltIvObj.salt, this.rKey, this.rIV);
                      resolve(data);
                    }
                  }
                });
              }
            }else{
              resolve(data);
            }
          }else{
            resolve(data);
          }
        }
      }catch(error){
        reject(error)
      }
    });
  }


  //encryption from two factor
  // static encrypt(encryptAttrs: string[], data: any): Promise<any>{
  //   return new Promise((resolve,reject) => {
  //     try{
  //       if(!encryptAttrs || encryptAttrs.length === 0 || data.iv || data.salt){
  //         resolve(data);
  //       }else{
  //         let count = encryptAttrs.length;
  //         if(count > 0){
  //           let _encryptAttrs = [...encryptAttrs];
  //           for (let i = count-1; i >= 0 ; i-- ){
  //             if(!data[_encryptAttrs[i]]){
  //               _encryptAttrs.splice(i,1);
  //             }
  //           }
  //           let loopNum = _encryptAttrs.length;
  //           if(loopNum > 0){
  //             const saltIvObj = this.generateSaltIv(_encryptAttrs.join(','));
  //             for(const _encryptAttr of _encryptAttrs){
  //               this.getKeyFromValue(_encryptAttr,saltIvObj.salt, 32, (key: any) => {
  //                 if(key){
  //                   data[_encryptAttr] = this.encryptWithKeyAndIV(data[_encryptAttr], key, saltIvObj.iv);
  //                   if(--loopNum === 0){
  //                     data.iv = this.encryptWithKeyAndIV(saltIvObj.iv, this.rKey, this.rIV);
  //                     data.salt = this.encryptWithKeyAndIV(saltIvObj.salt, this.rKey, this.rIV);
  //                     resolve(data);
  //                   }
  //                 }
  //               });
  //             }
  //           }else{
  //             resolve(data);
  //           }
  //         }else{
  //           resolve(data);
  //         }
  //       }
  //     }catch(error){
  //       reject(error)
  //     }
  //   });
  // }
  
  static decrypt(encryptAttrs: string[] | undefined, data: Array<any> | any){
    if(encryptAttrs != null && encryptAttrs.length > 0){
      if(Array.isArray(data)){
        for(let i=0; i< data.length; i++){
          this._decrypt_(encryptAttrs,data[i])
        }
      }else{
        Object.keys(data).forEach(key => {
          this._decrypt_(encryptAttrs,data[key])
        });
      }
    }
  }

  // static _decrypt_(encryptAttrs: string[], data: any){
  //   try{
  //     if(data.iv && data.salt){
  //       let iv = this.decryptWithKeyAndIV(data.iv, this.rKey, this.rIV);
  //       let salt = this.decryptWithKeyAndIV(data.salt, this.rKey, this.rIV);
  //       let _encryptAttrs = [...encryptAttrs];
  //         for (let i = encryptAttrs.length-1; i >= 0 ; i-- ){
  //           if(!data[_encryptAttrs[i]]){
  //             _encryptAttrs.splice(i,1);
  //           }
  //         }
  //       for (let _encryptAttr of _encryptAttrs){
  //         const key = this.getKeyFromValueSync(_encryptAttr, salt, 32);
  //         if(data[_encryptAttr]){
  //           data[_encryptAttr] = this.decryptWithKeyAndIV(data[_encryptAttr], key, iv);
  //         }
  //       }
  //       delete data.iv
  //       delete data.salt
  //     }
  //   }catch(e){
  //     console.error(e.stack? e.stack: e.message)
  //     throw e;
  //   }
  // }

  static _decrypt_(encryptAttrs: string[], data: any){
    try{
      if(data.salt){
        let salt = this.decryptWithKeyAndIV(data.salt, this.rKey, this.rIV);
        let _encryptAttrs = [...encryptAttrs];
          for (let i = encryptAttrs.length-1; i >= 0 ; i-- ){
            if(!data[_encryptAttrs[i]]){
              _encryptAttrs.splice(i,1);
            }
          }
        for (let _encryptAttr of _encryptAttrs){
          const key = this.getKeyFromValueSync(_encryptAttr, salt, 32);
          if(data[_encryptAttr]){
            data[_encryptAttr] = this.decryptWithKeyAndIV(data[_encryptAttr], key, this.rIV);
          }
        }
        delete data.salt
      }
    }catch(e){
      console.error(e.stack? e.stack: e.message)
      throw e;
    }
  }


  // static _decrypt_(encryptAttrs: string[], data: any){
  //   try{
  //     let _encryptAttrs = [...encryptAttrs];
  //     for (let i = encryptAttrs.length-1; i >= 0 ; i-- ){
  //       if(!data[_encryptAttrs[i]]){
  //         _encryptAttrs.splice(i,1);
  //       }
  //     }
  //     for (let _encryptAttr of _encryptAttrs){
  //       if(data[_encryptAttr]){
  //         data[_encryptAttr] = this.decryptWithKeyAndIV(data[_encryptAttr], this.rKey, this.rIV);
  //       }
  //     }
  //   }catch(e){
  //     console.error(e.stack? e.stack: e.message)
  //     throw e;
  //   }
  // }
}

export {
    Encryption
}