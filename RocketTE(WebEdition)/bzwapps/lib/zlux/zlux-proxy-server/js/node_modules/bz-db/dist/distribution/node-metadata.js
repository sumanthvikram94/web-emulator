/**
 * Handle logics that transforms data format for meta_node and meta_peers
 */
import { peerIdFromKeys, peerIdFromString } from '@libp2p/peer-id';
import { multiaddr } from '@multiformats/multiaddr';
import _ from 'lodash';
// Instance of nodeinfo
export class NodeMetadata {
    constructor() {
        this.multiaddrs = []; //
        this.privateKey = new Uint8Array(); //
        this.localAddrs = '';
    }
    static async fromJSON(nodeMetaExt) {
        let nodemeta = new NodeMetadata();
        nodemeta._nodeMetaExt = _.cloneDeep(nodeMetaExt);
        nodemeta = Object.assign(nodemeta, nodemeta._nodeMetaExt);
        if (nodeMetaExt.peerId && nodeMetaExt.peerId.pubKey) { // Legal peer data with peerId
            const privateKey = nodeMetaExt.peerId.privKey ? Buffer.from(nodeMetaExt.peerId.privKey, 'base64') : undefined;
            nodemeta.peerIdInst = await peerIdFromKeys(Buffer.from(nodeMetaExt.peerId.pubKey, 'base64'), privateKey);
        }
        else if (nodeMetaExt.id && nodeMetaExt.id.length > 0) { // No peerId, this happens when the data is from a remote node that is not in the private net.
            nodemeta.peerIdInst = await peerIdFromString(nodeMetaExt.id);
        }
        if (nodemeta.localAddrs) { // It includes meta_node data
            nodemeta._nodeMeta = {
                id: nodemeta.id,
                peerId: nodemeta.peerId,
                port: nodemeta.port,
                version: nodemeta.version,
                localAddrs: nodemeta.localAddrs
            };
        }
        const multiaddrs = [];
        if (nodemeta._nodeMetaExt.multiaddrs) {
            nodemeta._nodeMetaExt.multiaddrs?.forEach((ma) => {
                multiaddrs.push(multiaddr(ma)); // Builds the Multiaddr instances
            });
        }
        nodemeta.multiaddrs = multiaddrs;
        const peerMultiaddrs = nodemeta._nodeMetaExt.multiaddrs ? nodemeta._nodeMetaExt.multiaddrs : [];
        nodemeta._peerMeta = {
            id: nodemeta.id,
            peerId: {
                id: nodemeta.id,
                pubKey: nodemeta.peerId?.pubKey
            },
            port: nodemeta.port,
            version: nodemeta.version,
            multiaddrs: peerMultiaddrs,
            serverURL: nodemeta.serverURL,
            developmentMode: nodemeta.developmentMode,
            localIp: nodemeta.localIp,
            timestamp: nodemeta.timestamp,
            nodeType: nodemeta.nodeType
        };
        return nodemeta;
    }
    updateMultiaddrs(multiaddrs) {
        this.multiaddrs = multiaddrs;
        if (this._peerMeta) {
            const mas = [];
            multiaddrs.forEach(ma => {
                mas.push(ma.toString());
            });
            this._peerMeta.multiaddrs = mas;
        }
    }
    updateTimestamp(ts) {
        this.timestamp = ts;
        if (this._peerMeta) {
            this._peerMeta.timestamp = ts;
        }
    }
    getPeerMeta() {
        return this._peerMeta;
    }
    getNodeMeta() {
        return this._nodeMeta;
    }
}
