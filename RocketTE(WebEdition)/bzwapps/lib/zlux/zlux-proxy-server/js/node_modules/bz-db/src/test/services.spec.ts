import fse from 'fs-extra';
import { FileService, Utils, yaml } from '../services/index'
import { PersistType } from '../main/metadata';

let fileSrc: FileService;
const dir = './testdatasrcs';

beforeAll(() => {
    fse.emptyDirSync(dir)
})

describe('files service', () => {
    const path = './testdatasrcs/files';
    const helloPath = `${path}/hello.json`;
    const commentPath = `${path}/withComment.txt`;

    beforeAll(() => {
        fileSrc = new FileService();
        fse.ensureDir(path);
        fse.writeFileSync(helloPath, `{"data": "hello"}`);
        fse.writeFileSync(commentPath, `//test with comment\n{"data": "test"}`);

    })

    test('Manage file stat', () => {
        expect.assertions(2);
        fileSrc.setFileStat(helloPath, fse.statSync(helloPath));
        const stat = fileSrc.getFileStat(helloPath);
        expect(stat).toBeTruthy();
        fileSrc.removeFileStat(helloPath);
        const removedStat = fileSrc.getFileStat(helloPath);
        expect(removedStat).toBeUndefined();
    })

    test('Get files sync', () => {
        expect.assertions(4);
        const notExistPath = './testdatasrcs/notExist';
        const emptyResult = fileSrc.getFiles(notExistPath);
        expect(emptyResult.length).toBe(0);
        const result = fileSrc.getFiles(path);
        expect(result.length).toBe(2);
        expect(result[0]).toBe('hello.json');
        const fileContent = fileSrc.existFileSync(helloPath);
        expect(fileContent).toBeTruthy();
    })

    test('Get files async without name', async () => {
        expect.assertions(2);
        const result = await fileSrc.getData(path, 'hello');
        expect(result.length).toBe(1);
        const commentResult = await fileSrc.getData(path, 'withComment');
        expect(commentResult.length).toBe(1);
    })

    test('Get files async with name but not allow sub folder', async () => {
        expect.assertions(2);
        const result = await fileSrc.returnDataWithName(path, 'hello', PersistType.PERSIST_TYPE_RAW);
        expect(result.length).toBe(1);
        const commentResult = await fileSrc.returnDataWithName(path, 'withComment', PersistType.PERSIST_TYPE_OBJECT);
        expect(commentResult.length).toBe(1);
    })

    test('Get files async with name and allow sub folder', async () => {
        expect.assertions(1);
        const subPath = `${path}/sub`;
        await fse.ensureDir(subPath);
        const subHelloPath = `${subPath}/sub_hello.json`;
        fse.writeFileSync(subHelloPath, `{"data": "hello"}`);
        
        const allowSubResult = await fileSrc.returnDataWithName(path, 'hello', PersistType.PERSIST_TYPE_RAW, true);
        expect(allowSubResult.length).toBe(2);
    })
})

describe('Utils', () => {

    test('Utils.splitObject', () => {
        const sources = [
            {key1: 'key1-1'},
            {key1: ['key1-1', 'key1-2']},
            {
                key1: ['key1-1', 'key1-2'],
                key2: 'key2',
                key3: ['key3-1', 'key3-2', 'key3-3']
            }
        ]
        const objects0 = Utils.splitObject(sources[0])
        expect(objects0).toEqual([
            { key1: 'key1-1' }
        ])
        const objects1 = Utils.splitObject(sources[1])
        expect(objects1).toEqual([
            { key1: 'key1-1' }, { key1: 'key1-2'}
        ])
        const objects2 = Utils.splitObject(sources[2])
        expect(objects2).toEqual([
            { key1: 'key1-1', key2: 'key2', key3: 'key3-1' },
            { key1: 'key1-1', key2: 'key2', key3: 'key3-2' },
            { key1: 'key1-1', key2: 'key2', key3: 'key3-3' },
            { key1: 'key1-2', key2: 'key2', key3: 'key3-1' },
            { key1: 'key1-2', key2: 'key2', key3: 'key3-2' },
            { key1: 'key1-2', key2: 'key2', key3: 'key3-3' }
          ])
    })
})


describe('yaml', () => {

    const yaml_str = 
`# A commented document

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ss-rtew # name of ss
  namespace: termbz
spec:
  selector:
    matchLabels:
      app: rtew
  serviceName: svc-rtew-headless
  replicas: 1
  minReadySeconds: 10
  template:
    metadata:
      labels:
        app: rtew
    spec:
      # specification for pod
      terminationGracePeriodSeconds: 10
      containers:
        - name: rtew
          image: 363261076729.dkr.ecr.us-east-1.amazonaws.com/termbz:latest
          ports:
            - containerPort: 8543 # http
            - containerPort: 8643 # cluster
`

    test('yaml.yamlStrToJson', () => {
        const json = yaml.yamlStrToJson(yaml_str)
        expect(Object.keys(json).length).toBe(5)
        expect(json.kind).toBe('StatefulSet')
        expect(json.spec.template.spec.containers.length).toBe(1)
        expect(json.spec.template.spec.containers[0].ports[0].containerPort).toBe(8543)
        expect(json.__bzdb_yaml_metadata.comments.length).toBe(5)
        // Negative testings:
        expect(yaml.yamlStrToJson('')).toEqual({})
        expect(yaml.yamlStrToJson('#')).toEqual({})
        expect(yaml.yamlStrToJson('# 123')).toEqual({})
        expect(yaml.yamlStrToJson('aa:bb')).toEqual({})
        expect(yaml.yamlStrToJson(':aa')).toEqual({})
        expect(yaml.yamlStrToJson('aa: bb#cc')).toEqual({aa: 'bb#cc'})
    })

    test('yaml.jsonToYAMLStr', () => {
        const json = yaml.yamlStrToJson(yaml_str)
        const yamlStr = yaml.jsonToYAMLStr(json)
        expect(yamlStr).toBe(yaml_str)
        // Negative testings:
        expect(yaml.jsonToYAMLStr('aaa')).toBe('')
        expect(yaml.jsonToYAMLStr('123')).toBe('')
        expect(yaml.jsonToYAMLStr(undefined)).toBe('')
        expect(yaml.jsonToYAMLStr(null)).toBe('')
        expect(yaml.jsonToYAMLStr(123)).toBe('')
        expect(yaml.jsonToYAMLStr({
            key1: 'value1',
            __bzdb_yaml_metadata: {
                comments: [{key: ['key2'], comment: 'You can not see me.'}]
            }
        })).toBe('key1: value1\n')
    })
})


afterAll(() => {
    fse.removeSync(dir)
})
