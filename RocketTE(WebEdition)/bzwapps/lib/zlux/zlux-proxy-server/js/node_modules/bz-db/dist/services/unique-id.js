import lodash_pkg from 'lodash';
const { now } = lodash_pkg;
import { CONFIG } from '../constants/config.js';
class UniqueId {
    constructor() {
        this._internalSequence = 0;
        this._ipNum = 0;
    }
    /**
     *
     * @param multiAddr The multiAddr object, it should inludes the ip data as bytes.
     */
    setIp(multiAddr) {
        try {
            if (multiAddr && multiAddr.bytes) {
                this._ipNum = multiAddr.bytes.reduce((prev, curr) => {
                    return prev + curr;
                });
            }
        }
        catch (e) {
            // shouldn't happen. keep the ipnum as 0. Do nothing.
        }
    }
    generate(radix = CONFIG.UID_NUMBER_STR_RADIX, level = CONFIG.UID_MAX_LEVEL) {
        if (radix < 2 || radix > 36) {
            radix = CONFIG.UID_NUMBER_STR_RADIX;
        }
        const partsArr = [
            now() - CONFIG.UID_BASE_TIME,
            this._internalSequence++, // internal sequence
        ];
        if (this._internalSequence >= CONFIG.UID_SEQUENCE_MAX) {
            this._internalSequence = 0;
        }
        if (level > 1) {
            partsArr.push(Math.floor(Math.random() * CONFIG.UID_RANDOM_RANGE)); // random number
        }
        if (level > 2) {
            partsArr.push(process.pid); // process id
        }
        if (level > 3) {
            partsArr.push(this._ipNum); // Sum of ip address parts
        }
        let uid = partsArr[0].toString(radix) + CONFIG.UID_SEPRATOR + partsArr[1].toString(radix);
        for (let i = 2; i <= Math.min(level, CONFIG.UID_MAX_LEVEL); i++) {
            uid += CONFIG.UID_SEPRATOR + partsArr[i].toString(radix);
        }
        return uid;
    }
}
const uid = new UniqueId();
export { uid };
