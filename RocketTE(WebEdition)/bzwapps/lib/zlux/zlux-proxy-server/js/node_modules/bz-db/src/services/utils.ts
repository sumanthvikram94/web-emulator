// import * as _ from 'lodash'

import { BlockChain, BlockChainStat } from "../blockchain/blockchain.js";
import { Logger } from "./index.js";
import crypto from 'crypto'
import { CONFIG } from '../constants/config.js'
import _ from 'lodash'
import { DbWorker } from '../main/db-worker.js'
import portfinder from 'portfinder'

class Utils{
    static mapToString(map: Map<any, any>){
        return JSON.stringify(Array.from(map.entries()))
    }

    static stringToMap(str: string){
        try{
            return new Map(JSON.parse(str))
        } catch(e){
            Logger.logWarn('Error while parsing string to map: ' + str)
            throw e
        }
    }

    
    static mapToArray(map: Map<any, any>){
        return Array.from(map.entries())
    }

    static arrayToMap(arr: any[]): Map<string, any>{
        try{
            return new Map<string, any>(arr)
        } catch(e){
            Logger.logWarn('Error while parsing array to map: ' + arr)
            throw e
        }
    }

    static arrayToChainMap(arr: any[]): Map<string, BlockChain>{
        try{
            return new Map<string,BlockChain>(arr)
        } catch(e){
            Logger.logWarn('Error while parsing array to map: ' + arr)
            throw e
        }
    }

    static arrayToBCSMap(arr: any[]): Map<string, BlockChainStat>{
        try{
            return new Map<string,BlockChainStat>(arr)
        } catch(e){
            Logger.logWarn('Error while parsing array to map: ' + arr)
            throw e
        }
    }

    /**
     * 
     * @param arr Array of object
     * @param propertyName object[propertyName] must be number
     */
    static sumArray(arr: any[], propertyName: string): number{
        const sum = arr.map((bc: any) => bc[propertyName]).reduce((total: number, val: number) => { 
            return total + val 
        })
        return sum
    }

    static andArray(arr: any[]): boolean{
        for (let bln of arr){
            if (!bln) return false
        }
        return true
    }

    
    static generateHash(val:string){
        const hmac = crypto.createHmac(CONFIG.HASH_ALGORITHM, CONFIG.HASH_KEY)
        hmac.update(val)
        return hmac.digest('hex')
    }

    /**
     * 
     * @param arrs 
     * @returns cartesian of arrays inside input arrs
     */
    static cartesian(arrs: any[]){
        const f = (a:any, b:any) => [].concat(...a.map((d:any) => b.map((e:any) => [].concat(d, e))));
        const cartesianFun:any = (a:any, b:any, ...c:any[]) => (b ? cartesianFun(f(a, b), ...c) : a);
        return cartesianFun(...arrs)
    }

    /**
     * Turn {id1:[1,2], id2:[3,4]} into [{id1:1,id2:3}, {id1:1,id2:4}, {id1:2, id2:3}, {id1:2, id2:4}]
     * @param obj 
     * @returns 
     */
    static splitObject(obj: any): any[]{
        if (_.isEmpty(obj)) return []
        const objects: any[] = []
        const keys = Object.keys(obj)
        let values:any = []
        keys.forEach((key) => {
            const val = obj[key]
            if (Array.isArray(val)){
                if (val.length === 0) return
                values.push(val)
            } else if (typeof(val) === 'object') {
                if (_.isEmpty(val)) return
                values.push([val])
            } else {
                values.push([val])
            }
        })
        if ( values.length > 1 ){
            values = Utils.cartesian(values)
        } else if (values.length === 1){ // only 1 key in obj
            const tempVals:any[] = []
            values[0].forEach((v:any) => {
                tempVals.push([v])
            })
            values = tempVals
        }
        values.forEach((vs:any[]) => {
            const tempArr = _.zip(keys, vs)
            const tempObj = _.fromPairs(tempArr)
            objects.push(tempObj)
        })
        return objects
    }

    static isFreePort(port: number): Promise<boolean>{
        return new Promise<boolean>((resolve) => {
            portfinder.getPort({port, stopPort:port}, (err, p) => {
                if (err) {
                    Logger.logDebug('Port is in use: ' + port)
                    resolve(false)
                } else {
                    Logger.logDebug('Port is free: ' + p)
                    resolve (true)
                }
            })
        })
    }

    
    static getFreePortSince(port: number): Promise<number>{
        return new Promise((resolve) => {
            portfinder.getPort({port}, (err, p) => {
                if (err) {
                    Logger.logError(err)
                    resolve(0)
                }
                resolve(p)
            })
        });
    }

    static async shutdown (worker: DbWorker){
        await worker.stop()
        Logger.logWarn('Exiting process')
        process.nextTick(() => {
            process.exit(0)
        })
    }

    static waitTime(ms = 5000){
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(true)
            }, ms);
        })
    }
    static async wait(callback:Function, interval:number=100, count:number=50) {
        while (count-- > 0) {
          if (await callback()) {
            return true
          } else {
            await this.waitTime(interval)
          }
        }
        return false
    }

    static getServerNameFromUrl(url: string) {
        if(url){
            const serverUrl = new URL(url);
            return serverUrl.hostname;
        }else {
            return '';
        }
    }

    static getParamObject(message: string, detail: string, type: string,remotePeerId: string = '', metadata: any, dataEntity:string = '',localLastBlockTime:string  = '',peerLastBlockTime: string  = ''){
        return {
            message,
            detail,
            type,
            remotePeerId,
            localPeerId: metadata?.id || '',
            localIP: metadata?.localIp || '',
            serverName: Utils.getServerNameFromUrl(metadata?.serverURL),
            dataEntity,
            localLastBlockTime,
            peerLastBlockTime,
            localLastBlockDateTime: Utils.transferTimestampToDateTime(localLastBlockTime),
            peerLastBlockDateTime: Utils.transferTimestampToDateTime(peerLastBlockTime)

        }
    }

    static transferTimestampToDateTime(timestamp:string){
        if(timestamp && Number(timestamp)){
            const date = new Date(Number(timestamp));
            return Utils.date2DateString(date);
        }
        return '';
    }

    static transferTimestampToDate(timestamp?:string){
        let date = new Date();
        if(timestamp && Number(timestamp)){
            date = new Date(Number(timestamp));
        }
        return Utils.date2DateString(date, true);
    }

    static date2DateString(date: Date, dateOnly: boolean = false, timeOnly: boolean = false){
        const year = date.getFullYear()
        const month = ( date.getMonth() < 9 ?  "0": "" ) + ( date.getMonth() + 1 )
        const day = ( date.getDate() < 10 ?  "0": "" ) + date.getDate()
        if(dateOnly){
            return year + "-" + month + "-" + day;
        }
        const hour =  (date.getHours() < 10 ?  "0": "") + date.getHours()
        const minutes = (date.getMinutes() < 10 ?  "0": "") + date.getMinutes()
        const seconds = (date.getSeconds() < 10 ?  "0": "") + date.getSeconds()
        if(timeOnly){
            return hour + ":" + minutes + ":" + seconds
        }
        return year + "-" + month + "-" + day + " " + hour + ":" + minutes + ":" + seconds
    }
}


// const objArr0 = Utils.splitObject({})
// console.log(objArr0)
// const objArr1 = Utils.splitObject({id:1})
// console.log(objArr1)
// const objArr2 = Utils.splitObject({id:[1,2]})
// console.log(objArr2)
// const objArr3 = Utils.splitObject({id:[1,2], name:[3,4]})
// console.log(objArr3)

export {
    Utils
}