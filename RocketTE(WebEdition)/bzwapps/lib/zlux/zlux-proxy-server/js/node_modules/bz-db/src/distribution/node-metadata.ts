/**
 * Handle logics that transforms data format for meta_node and meta_peers
 */

import type { PeerId } from '@libp2p/interface-peer-id'
import { peerIdFromKeys, peerIdFromString } from '@libp2p/peer-id'
import { multiaddr, Multiaddr } from '@multiformats/multiaddr'
import _ from 'lodash'
import { ClusterNodeType } from '../main/metadata'

interface INodeInfoBasic {
    id: string
    peerId?: IPeerIdJson
    port?: number
    version?: any
}

interface IPeerIdJson {
    id: string,
    pubKey: string,
    privKey?: string
}

// Metadata for the local node. _db_store/_metadata/node/node.json
export interface INodeMeta extends INodeInfoBasic {
    localAddrs: string
}


// JSON format of data for peer _db_store/_metadata/peer/xxx.json
export interface IPeerMeta extends INodeInfoBasic {
    multiaddrs:  string[]
    serverURL?: string
    developmentMode?: any
    localIp?: string
    timestamp?: number
    nodeType?: ClusterNodeType
}

export interface INodeMetaExtended extends INodeInfoBasic {
    localAddrs?: string
    multiaddrs?:  string[]
    serverURL?: string
    developmentMode?: any
    localIp?: string
    timestamp?: number
    peerIdInst?: PeerId
    nodeType?: ClusterNodeType
}

// Instance of nodeinfo
export class NodeMetadata {
    id: string
    peerId: IPeerIdJson
    peerIdInst: PeerId // 
    multiaddrs: Multiaddr[] = [] //
    privateKey: Uint8Array = new Uint8Array() //
    localAddrs: string = ''
    serverURL?: string
    port?: number
    version?: any
    developmentMode?: any
    localIp?: string
    timestamp?: number
    nodeType?: ClusterNodeType
    _nodeMetaExt: INodeMetaExtended
    _peerMeta?: IPeerMeta
    _nodeMeta?: INodeMeta

    constructor(){
    }

    static async fromJSON(nodeMetaExt: INodeMetaExtended){
        let nodemeta = new NodeMetadata()
        nodemeta._nodeMetaExt = _.cloneDeep(nodeMetaExt)
        nodemeta = Object.assign(nodemeta, nodemeta._nodeMetaExt)

        if (nodeMetaExt.peerId && nodeMetaExt.peerId.pubKey) { // Legal peer data with peerId
            const privateKey = nodeMetaExt.peerId.privKey? Buffer.from(nodeMetaExt.peerId.privKey, 'base64'): undefined
            nodemeta.peerIdInst = await peerIdFromKeys(Buffer.from(nodeMetaExt.peerId.pubKey, 'base64'), privateKey)
        } else if (nodeMetaExt.id && nodeMetaExt.id.length > 0) { // No peerId, this happens when the data is from a remote node that is not in the private net.
            nodemeta.peerIdInst = await peerIdFromString(nodeMetaExt.id)
        }

        if (nodemeta.localAddrs) { // It includes meta_node data
            nodemeta._nodeMeta = {
                id: nodemeta.id,
                peerId: nodemeta.peerId,
                port: nodemeta.port,
                version: nodemeta.version,
                localAddrs: nodemeta.localAddrs
            }
        }

        const multiaddrs: Multiaddr[] = []
        if (nodemeta._nodeMetaExt.multiaddrs) {
            nodemeta._nodeMetaExt.multiaddrs?.forEach((ma: any) => {
              multiaddrs.push(multiaddr(ma)) // Builds the Multiaddr instances
            })
        }
        nodemeta.multiaddrs = multiaddrs
        const peerMultiaddrs: string[] = nodemeta._nodeMetaExt.multiaddrs? nodemeta._nodeMetaExt.multiaddrs : []
        nodemeta._peerMeta = {
            id: nodemeta.id,
            peerId: { // here should exclude privateKey
                id: nodemeta.id,
                pubKey: nodemeta.peerId?.pubKey
            },
            port: nodemeta.port,
            version: nodemeta.version,
            multiaddrs: peerMultiaddrs,
            serverURL: nodemeta.serverURL,
            developmentMode: nodemeta.developmentMode,
            localIp: nodemeta.localIp,
            timestamp: nodemeta.timestamp,
            nodeType: nodemeta.nodeType
        }
        return nodemeta
    }

    updateMultiaddrs(multiaddrs: Multiaddr[]) {
        this.multiaddrs = multiaddrs
        if (this._peerMeta) {
            const mas: string[] = []
            multiaddrs.forEach(ma => {
                mas.push(ma.toString())
            })
            this._peerMeta.multiaddrs = mas
        }
    }

    updateTimestamp(ts: number) {
        this.timestamp = ts
        if (this._peerMeta) {
            this._peerMeta.timestamp = ts
        }
    }

    getPeerMeta(): IPeerMeta | undefined {
        return this._peerMeta
    }

    getNodeMeta(): INodeMeta | undefined {
        return this._nodeMeta
    }
}

export interface IProcessOptions {
    action: string
    handler: any
    data?: any
}

export interface ITaskMessage {
    peer: IPeerMeta
    taskid: string
    payload: any,
    isNotZipped: boolean
}

export interface IPeerState {
    id: string,
    peer: NodeMetadata,
    status?: string
}
