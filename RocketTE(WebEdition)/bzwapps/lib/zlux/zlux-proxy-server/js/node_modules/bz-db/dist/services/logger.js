import path from 'path';
import fse from 'fs-extra';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { CONFIG } from '../constants/config.js';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const DEFAULT_LOG_FILE = path.resolve(__dirname, '../log/bzdb.log');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["SILENT"] = -1] = "SILENT";
    LogLevel[LogLevel["SEVERE"] = 0] = "SEVERE";
    LogLevel[LogLevel["WARN"] = 1] = "WARN";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 3] = "DEBUG";
})(LogLevel || (LogLevel = {}));
/**
 * Writes log into a file
 */
class StreamLogWriter {
    constructor() {
        // this.writeStream = fs.createWriteStream(fileName, {flags: 'a', encoding: 'utf8', mode: 0o644});
    }
    /**
     * Change the file to write log.
     * @param fileName
     */
    getNewWriter(fileName) {
        let logWriteStreamOld = this.writeStream;
        this.writeStream = fse.createWriteStream(fileName, { flags: 'a', encoding: 'utf8', mode: 0o644 });
        if (logWriteStreamOld)
            this.streamCloseSafe(logWriteStreamOld);
        return this;
    }
    /**
     * A stream should be closed only when all the data in it is written into file
     * @param fileSteam
     * @param callback
     */
    streamCloseSafe(fileSteam, callback) {
        const endfileStream = () => {
            setTimeout(() => {
                if (fileSteam.writableLength > 0) {
                    endfileStream();
                }
                else {
                    fileSteam.end();
                    fileSteam.destroy();
                    if (callback)
                        callback();
                }
            }, 500);
        };
        endfileStream();
    }
    log(msg) {
        this.writeStream.write(msg + '\n');
    }
    warn(msg) {
        this.writeStream.write(msg + '\n');
    }
}
class InternalLogger {
    constructor(config) {
        // this.logLevel = (config && config.logLevel)? config.logLevel: LogLevel.INFO;
        // if (this.logLevel > 2) this.logLevel = LogLevel.DEBUG;
        this.streamWriter = new StreamLogWriter();
        this.setWriter(config);
    }
    /**
     * Process name will be written into log, so multiple processes can be distincted
     * @param name
     */
    setProcessName(name) {
        this.processName = name;
    }
    /**
     * Creates the dir and the parent dirs if not exist.
     * @param {string} dir
     */
    createDirs(dir) {
        const tmpPath = path.dirname(dir);
        if (!fse.existsSync(path.dirname(tmpPath))) {
            this.createDirs(path.dirname(tmpPath));
        }
        if (!fse.existsSync(tmpPath)) {
            fse.mkdirSync(tmpPath);
        }
    }
    /**
     * Set writing log to file or console
     * @param config
     */
    setWriter(config) {
        if (config && config.type === 'file') {
            const fileName = path.resolve(config.fileName ? config.fileName : DEFAULT_LOG_FILE);
            this.createDirs(fileName);
            this.writer = this.streamWriter.getNewWriter(fileName);
        }
        else {
            this.writer = console;
        }
    }
    // setLogLevel(logLevel: LogLevel): void{
    //     this.logLevel = logLevel;
    //     if (this.logLevel > 2) this.logLevel = LogLevel.DEBUG;
    //     if (this.logLevel < -1) this.logLevel = LogLevel.SILENT;
    // }
    /**
     * Prepend data to each line of log
     * @param level
     */
    _getLogPrefix(level) {
        const now = new Date();
        now.setTime(now.getTime() - now.getTimezoneOffset() * 60000);
        let nowStr = now.toISOString();
        nowStr = nowStr.substring(0, nowStr.length - 1).replace('T', ' ');
        const processName = this.processName ? `${this.processName}` : 'db';
        // return `[BZDB ${level} at ${nowStr}${processName}] - `;
        return `[${nowStr} ${processName} ${level}] - `;
    }
    logInfo(msg) {
        this.writer.log(this._getLogPrefix('INFO') + msg);
    }
    logWarn(msg) {
        this.writer.warn(this._getLogPrefix('WARN') + msg);
    }
    logSevere(msg) {
        this.writer.warn(this._getLogPrefix('SEVERE') + msg);
    }
    logError(e) {
        this.writer.warn(this._getLogPrefix('SEVERE') + (e.stack ? e.stack : e.message));
        console.error(e);
    }
    logDebug(msg) {
        this.writer.log(this._getLogPrefix('DEBUG') + msg);
    }
}
let _logger = new InternalLogger();
class LoggerConfigurer {
    static setProcessName(name) {
        _logger.setProcessName(name);
    }
    static setWriter(config) {
        _logger.setWriter(config);
    }
}
/**
 * Writes no log
 */
class SilentLogger {
    constructor() {
    }
    logError(_e, _logLevel = LogLevel.INFO) {
    }
    logSevere(_msg, _logLevel = LogLevel.INFO) {
    }
    logWarn(_msg, _logLevel = LogLevel.INFO) {
    }
    logInfo(_msg, _logLevel = LogLevel.INFO) {
    }
    logDebug(_msg, _logLevel = LogLevel.INFO) {
    }
}
/**
 * Writes severe logs
 */
class SevereLogger extends SilentLogger {
    constructor() {
        super();
    }
    logSevere(msg, logLevel = LogLevel.INFO) {
        if (logLevel >= LogLevel.SEVERE) {
            _logger.logSevere(msg);
        }
    }
    logError(e, logLevel = LogLevel.INFO) {
        if (logLevel >= LogLevel.SEVERE) {
            _logger.logError(e);
        }
    }
}
/**
 * Writes severe and warning logs
 */
class WarnLogger extends SevereLogger {
    constructor() {
        super();
    }
    logWarn(msg, logLevel = LogLevel.INFO) {
        if (logLevel >= LogLevel.WARN) {
            _logger.logWarn(msg);
        }
    }
}
/**
 * Writes severe, warning and info logs
 */
class InfoLogger extends WarnLogger {
    constructor() {
        super();
    }
    logInfo(msg, logLevel = LogLevel.INFO) {
        if (logLevel >= LogLevel.INFO) {
            _logger.logInfo(msg);
        }
    }
}
/**
 * Writes severe, warning and info logs
 */
class DebugLogger extends InfoLogger {
    constructor() {
        super();
    }
    logDebug(msg, logLevel = LogLevel.INFO) {
        if (logLevel >= LogLevel.DEBUG) {
            _logger.logDebug(msg);
        }
    }
}
const silentLogger = new SilentLogger();
const severeLogger = new SevereLogger();
const warnLogger = new WarnLogger();
const infoLogger = new InfoLogger();
const debugLogger = new DebugLogger();
class DefaultLogger {
    constructor(level = LogLevel.INFO) {
        this._level = level;
        this.setLogLevel(level);
    }
    setLogLevel(level) {
        switch (level) {
            case LogLevel.SILENT:
                this._logger = silentLogger;
                break;
            case LogLevel.SEVERE:
                this._logger = severeLogger;
                break;
            case LogLevel.WARN:
                this._logger = warnLogger;
                break;
            case LogLevel.INFO:
                this._logger = infoLogger;
                break;
            case LogLevel.DEBUG:
                this._logger = debugLogger;
                break;
            default:
                this._logger = infoLogger;
        }
        this._level = level;
    }
    logDebug(msg) {
        this._logger.logDebug(msg);
    }
    logInfo(msg) {
        this._logger.logInfo(msg);
    }
    logWarn(msg) {
        this._logger.logWarn(msg);
    }
    logSevere(msg) {
        this._logger.logSevere(msg);
    }
    logError(e) {
        this._logger.logSevere('Error encountered!');
        this._logger.logError(e);
    }
}
/**
 * Logger for specific topics. E.g. performance, transaction, network etc.
 */
class TopicLogger extends DefaultLogger {
    constructor(topic, level = LogLevel.INFO) {
        super(level);
        this._topic = topic;
    }
    appendTopicToMsg(msg, subTopic) {
        const subPrefix = subTopic ? `:${subTopic}` : '';
        return `${this._topic}${subPrefix} - ` + msg;
    }
    logDebug(msg, subTopic) {
        this._logger.logDebug(this.appendTopicToMsg(msg, subTopic));
    }
    logInfo(msg, subTopic) {
        this._logger.logInfo(this.appendTopicToMsg(msg, subTopic));
    }
    logWarn(msg, subTopic) {
        this._logger.logWarn(this.appendTopicToMsg(msg, subTopic));
    }
    logSevere(msg, subTopic) {
        this._logger.logSevere(this.appendTopicToMsg(msg, subTopic));
    }
    logError(e, subTopic) {
        this._logger.logSevere(this.appendTopicToMsg('Error encountered!', subTopic));
        this._logger.logError(e);
    }
}
const loggers = {
    default: new DefaultLogger(),
    performance: new TopicLogger('performance'),
    txn: new TopicLogger('txn'),
    metadata: new TopicLogger('metadata'),
    checkin: new TopicLogger('checkin'),
    pull: new TopicLogger('pull'),
    cluster: new TopicLogger('cluster')
};
class TimeTracer {
    constructor() {
        this.msgTimes = new Map();
    }
    trace(msg) {
        const ts = Date.now();
        const mt = this.msgTimes.get(msg);
        if (mt) {
            const tsdiff = ts - mt;
            loggers.performance.logWarn(msg + ` - ms spent (${tsdiff})`, 'TIME_TRACE');
            this.msgTimes.delete(msg);
        }
        else {
            loggers.performance.logWarn(msg, 'TIME_TRACE');
            this.msgTimes.set(msg, ts);
        }
    }
}
class SilentTimeTracer extends TimeTracer {
    trace(_msg) {
    }
}
let timeTracer;
if (CONFIG.LOG_ENABLE_TIME_TRACE) {
    timeTracer = new TimeTracer();
}
else {
    timeTracer = new SilentTimeTracer();
}
export { TopicLogger, loggers, LoggerConfigurer, DefaultLogger, timeTracer };
