// import { BzdbLogger, DefaultLogger } from '../services/logger';
import { Utils } from '../services/index.js'
import path from 'path';
// import { isNumber } from 'util';
import _ from 'lodash';

const DEFAULT_PERSIST_PARTITION_COUNT = 20

enum IntegratyLevel {
    INTEGRATY_STRONG = 1, // Default
    INTEGRATY_MIDIUM, // Not in use for now
    INTEGRATY_WEAK // Allow txn even in data conflict / out of date
}

enum AnalyzeMethod {
    ANALYZE_METHOD_SELECT = 1,
    ANALYZE_METHOD_FILE_SIZE
}

enum PersistMethod {
    PERSIST_METHOD_LIST_FILE = 1,
    PERSIST_METHOD_COMBINED_FILE = 2,
    PERSIST_METHOD_ONLY_MEMORY = 3
}

enum PersistType {  // The data format
    PERSIST_TYPE_ARRAY = 1, // JSON array
    PERSIST_TYPE_OBJECT, // JSON object
    PERSIST_TYPE_RAW, // No JSON
    PERSIST_TYPE_YAML
}

enum SyncMode {
    SYNC_ALL = 1, // default, sync to all nodes
    SYNC_LOCAL = 2 // don't sync data, just updat in current node
}

/**
 * Removed
 */
// enum ProcessPooling {
//     NONE = 0,
//     ONE = 1,
//     // TWO = 2,
//     // FOUR = 4,
//     // SIX = 6,
//     // EIGHT = 8,
//     // TEN = 10,
//     // SIXTEEN = 16,
//     // TWENTY = 20,
//     AUTO = 2  // CPU count - 1
// }

enum DataStrategy {
    FILE_NO_WATCH = 0, // Data is stored into file, doesn't watch for data file changes.
    FILE_WATCH = 1, // Data is stored into file, watch for data file changes and refresh the data in memory
    MEMORY_ONLY = 2, // Only run in memory, doesn't save data to file. Not implemented yet.
    NO_CACHE = 3 // TBD, Data is not in memory.
}

enum EntityType {
    PERSIST = 0, 
    TEMP = 1, // Only this type entity can be destoried
}

const enum SchemaType{
    PERSIST_ENTITY="ENTITY",
    TEMP_ENTITY="TEMP ENTITY"
}

// Cluster peer discovery methods.
export enum PeerDiscovery {
    MULTICAST_DNS = 'mdns',
    BOOTSTRAP = 'bootstrap'
}

export enum ClusterNodeType {
    PERSISTENT = 'persistent',
    SCALABLE = 'scalable'
}


export enum DATA_CONFLICT_POLICY {
    MARK_CONFLICT = 0, // Mark node as data conflict, no further action
    CUT_SHORTER_CHAIN // Take the longer chain as correct, force pull
}


// Cluster auto-scalling settings
export interface MetaAutoScaling {
    enabled: boolean
    discovery: PeerDiscovery
    nodeType: ClusterNodeType
    peerList: string[]
    pnetMasks: String[]
    ipBlackList: String[]
}

export interface ClusterProxy {
    protocol?: string
    ip?: string
    port?: string
}

export interface MetaCluster {
    enabled: boolean
    proxy?: ClusterProxy
    autoScaling: MetaAutoScaling
}

interface PerformanceOptions {
    workOnBusy?: boolean
}

class DatabaseMetadata {

    // private _processPooling: ProcessPooling;
    private _dataEntityMetadata: Map <string, DataEntityMetadata>
    private _storePath: string
    private _onLoadReady: (results:any[])=>void
    private _metadata: any
    private _dataStrategy: DataStrategy
    private _rejectPKonUpdate: boolean
    private _cluster: MetaCluster
    private _performance: PerformanceOptions
    private _conflictPolicy: DATA_CONFLICT_POLICY

    /**
     * @param metadata The database metadata
     * @param metadata.appName : string, the application name who is using BZDB
     * @param metadata.storePath : string
     * @param metadata.dataEntities : [DataEntityMetadata]
     * @param metadata.logging : logger.LoggerConfig
     * @param metadata.OnLoadReady : Function
     * @param metadata.memoryOnly : boolean
     * @param metadata.watchDataChanges : boolean
     * @param metadata.rejectPKonUpdate : boolean
     * @param metadata.enableWorkerThread: boolean. If true, the db-worker will run in a seperate thread.
     * @param metadata.cluster: MetaCluster
     * @param metadata.performance.workOnBusy: boolean. If true, the db won't reject any request even when process is busy
     * @param metadata.autoResolveConflict: auto resolve data conflict
     */
    constructor(metadata?: any){
        // console.log('_metadata: ' + JSON.stringify(metadata));
        this._metadata = metadata
        this._storePath = path.join(process.cwd(), './_db_store')
        if (metadata) {
            if (metadata.storePath && typeof(metadata.storePath) === 'string'){
                this._storePath = path.join(process.cwd(), metadata.storePath,  './_db_store')
            }
            // const inputPooling: number = metadata.processPooling;
            // if (inputPooling && inputPooling === 1){
            //     this._processPooling = ProcessPooling.ONE;
            // } else if (inputPooling && inputPooling >= 2){
            //     this._processPooling = ProcessPooling.AUTO;
            // } else {
            //     this._processPooling = ProcessPooling.NONE;
            // }
    
            this._dataEntityMetadata = new Map<string, DataEntityMetadata> ()
    
            const dataEntities =  metadata.dataEntities;
            if (dataEntities && Array.isArray(dataEntities)){
                dataEntities.forEach((de:any) => {
                    if (de.name){
                        this._dataEntityMetadata.set(de.name, new DataEntityMetadata(de))
                    }
                })
            }

            const onLoadReady = metadata.OnLoadReady;
            if (onLoadReady && typeof(onLoadReady) === 'function'){
                this._onLoadReady = onLoadReady;
            }else {
                this._onLoadReady = ()=>{};
            }

            this._dataStrategy = metadata.memoryOnly? DataStrategy.MEMORY_ONLY: 
                                                metadata.watchDataChanges? DataStrategy.FILE_WATCH : 
                                                    DataStrategy.FILE_NO_WATCH
            this._rejectPKonUpdate = metadata['rejectPKonUpdate'] ? true: false
            this.parseClusterSettings()
            this._performance = metadata.performance
            this._conflictPolicy=Number(this._metadata['conflictPolicy'] ?? 0) || 0
        }
    }

    /**
     * Here includes user configurations, and requires better validation.
     */
    parseClusterSettings() {
        this._cluster = { // Default value
            enabled: true, // Cluster is enabled or not
            autoScaling: {
                enabled: false, // Auto-scalling is enabled or not. Only works when  cluster.enabled === true
                discovery: PeerDiscovery.MULTICAST_DNS, // This is not configurable now
                nodeType: ClusterNodeType.PERSISTENT,
                peerList: [], // Used in case discovery is "bootstrap"
                pnetMasks: [], // Security control for the auto-scallilng. Only the nodes inside the sub network can join the cluster
                ipBlackList: [] // Exclude some specific IP addresses inside the sub network
            }
        }
        if (this._metadata.cluster !== undefined) {
            const clusterEnabled = this._metadata.cluster.enabled
            if (clusterEnabled !== undefined) {
                this._cluster.enabled = clusterEnabled === true // We only accept the boolean value "true"
            }
            if (this._metadata.cluster.proxy) {
                this._cluster.proxy = {}
                if (this._metadata.cluster.proxy.protocol && this._metadata.cluster.proxy.protocol.length > 0) {
                    this._cluster.proxy.protocol = this._metadata.cluster.proxy.protocol;
                }
                if (this._metadata.cluster.proxy.ip && this._metadata.cluster.proxy.ip.length > 0) {
                    this._cluster.proxy.ip = this._metadata.cluster.proxy.ip
                }
                if (this._metadata.cluster.proxy.port && this._metadata.cluster.proxy.port.length > 0) {
                    this._cluster.proxy.port = this._metadata.cluster.proxy.port
                }
            }
            if (this._metadata.cluster.autoScaling !== undefined) {
                const asEnabled = this._metadata.cluster.autoScaling.enabled
                if (asEnabled !== undefined) {
                    this._cluster.autoScaling.enabled = asEnabled === true // We only accept the boolean value "true"
                }
                if (this._cluster.autoScaling.enabled === true ) {
                    if (this._metadata.cluster.autoScaling.discovery !== undefined) {
                        if (this._metadata.cluster.autoScaling.discovery === PeerDiscovery.BOOTSTRAP){
                            this._cluster.autoScaling.discovery = this._metadata.cluster.autoScaling.discovery
                            this._cluster.autoScaling.peerList = this._metadata.cluster.autoScaling.peerList || []
                        } else {
                            // use the default value 'mdns'
                        }
                    }
                    const nodeType = this._metadata.cluster.autoScaling.nodeType
                    if (nodeType === ClusterNodeType.SCALABLE) {
                        this._cluster.autoScaling.nodeType = ClusterNodeType.SCALABLE
                    }
                    const pnetMasks = this._metadata.cluster.autoScaling.pnetMasks
                    if (pnetMasks !== undefined && Array.isArray(pnetMasks)) {
                        // TBD, validate subnet mask format
                    }
                    const ipBlackList = this._metadata.cluster.autoScaling.ipBlackList
                    if (ipBlackList !== undefined && Array.isArray(ipBlackList)) {
                        // TBD, validate IP address format
                    }
                }
            }
        }
    }
    
    get cluster() {
        return this._cluster
    }

    get logging() {
        return this._metadata.logging
    }

    isWorkOnBusy() {
        return this._performance?.workOnBusy === true
    }

    isWorkerThreadEnabled() {
        return this._metadata['enableWorkerThread'] === true
    }

    get conflictPolicy() {
        return this._conflictPolicy
    }

    getDataStrategy(): DataStrategy {
        return this._dataStrategy;
    }

    getMetaData(): any {
        return this._metadata;
    }

    setStorePath(relevantPathtoCwd: string): void {
        this._storePath = path.join(process.cwd(), relevantPathtoCwd, './_db_store');
    }

    getStorePath(): string{
        return this._storePath;
    }

    // setProcessPooling(pooling: ProcessPooling): void{
    //     this._processPooling = pooling;
    // }

    // getProcessPooling(): ProcessPooling{
    //     return this._processPooling
    // }

    setDataEntity(metadata: DataEntityMetadata): void{
        if (metadata && metadata.name){
            this._dataEntityMetadata.set(metadata.name, metadata);
        }
    }

    getDataEntities(): Map<string, DataEntityMetadata> {
        return this._dataEntityMetadata;
    }

    // overrideLogger(logger: BzdbLogger): void{
    //     this._logger = logger;
    // }

    // getLogger(): BzdbLogger {
    //     return this._logger;
    // }

    getOnLoadReady(): (results:any[])=>void {
        return this._onLoadReady;
    }

    setOnLoadReady(cb:(results:any[])=>void) {
        this._onLoadReady = cb;
    }

    setRejectPKonUpdate(val: boolean): void {
        this._rejectPKonUpdate = val;
    }

    getRejectPKonUpdate(): boolean {
        return this._rejectPKonUpdate;
    }
}

class DataEntityMetadata{
    name: string;
    primaryKeys: string[];
    uniqueKeys?: string[]; // TBD
    indexes?: any; //Map<string, string[]>; 
    // processPooling?: ProcessPooling; // DELETE
    sequenceFields?: string[]; // TBD, we already have uid, guess there is no need for this anymore
    persistMethod?: PersistMethod;
    persistType?: PersistType;
    syncMode?: SyncMode;
    constraintFileName?: string[];
    filePath?: string;
    fileName?: string; // 
    fileNamePrefix?: string;
    fileNameSurfix?: string;
    rejectPKonUpdate?: boolean;
    externalStorage?: string;
    dataStrategy?:DataStrategy;
    backupFilePaths?: string[];
    isAllowSubFolder?: boolean = false;
    partitions: PartitionSetting;
    isNonPKPartitioned: boolean = false;
    syncFile4Cluster?: boolean = false;
    requiredCols:string[];
    entityType?:EntityType;
    analyzeMethod?: AnalyzeMethod;
    integratyLevel?: IntegratyLevel;
    encryptAttrs?: string[];
    isNoPK?: boolean = false; // Has no PK or PK is empty
    isInternal?: boolean = false;
    owner?:string

    constructor(deObj: Object){
        Object.assign(this, deObj)
        if (this.primaryKeys === undefined) { // give primaryKeys a default value
            this.primaryKeys = []
        }
        if (!this.persistMethod) this.persistMethod = PersistMethod.PERSIST_METHOD_COMBINED_FILE

        this.isNoPK = _.isEmpty(this.primaryKeys)
        if (_.isEmpty(this.partitions)){
            if (!this.isNoPK){
                // Utils.cartesian([this.primaryKeys, [DEFAULT_PERSIST_PARTITION_COUNT]])
                this.partitions = _.fromPairs(Utils.cartesian([this.primaryKeys, [DEFAULT_PERSIST_PARTITION_COUNT]]))
                // console.log(this.partitions)
            } else {
                this.partitions = {}
            }
        } else {
            this.isNonPKPartitioned = !_.isEqual(Object.keys(this.partitions), this.primaryKeys)
        }
        if (!this.requiredCols) this.requiredCols = []
        this.primaryKeys?.forEach(pk => {
            if (!this.requiredCols.includes(pk)) this.requiredCols.push(pk)
        })
        this.getPartitionColumn().forEach(pc => {
            if (!this.requiredCols.includes(pc)) this.requiredCols.push(pc)
        })
    }

    validateRequiredCol(row: any){
        return _.difference(this.requiredCols, Object.keys(row)).length === 0
    }

    getPartitionColumn(): string[]{
        return Object.keys(this.partitions)
    }

    getPartitionCount(col:string): number{
        return this.partitions[col]
    }
}

const enum BulkLoadReplaceStrategy {
    DELETE_INSERT = 1,
    UPDATE,
    IGNORE
};

const enum SortOrder {
    ASC= 'asc',
    DESC= 'desc'
}

export interface OrderBy {
    fields: string[];
    orders?: SortOrder[]
}

export interface Pagination {
    size: number;
    page: number;
}


class SelectConstraints{

    ignoreCaseFields?: string [];
    orderBy?: OrderBy; // {fields: string[], orders: string['asc' | 'desc']}
    pagination?: Pagination; // {size: number, page: number}

    /**
     * 
     * @param options 
     * @param options.ignoreCaseFields: string []
     * @param options.orderBy: {fields: string[], order: 'asc' | 'desc'}
     * @param options.pagination: {size: number, page: number}
     */
    constructor( options? : any ){
        if (options && options.ignoreCaseFields && Array.isArray(options.ignoreCaseFields)){
            this.ignoreCaseFields = options.ignoreCaseFields;
        } else {
            this.ignoreCaseFields = [];
        }

        if (options && options.orderBy && options.orderBy.fields && Array.isArray(options.orderBy.fields)){
            const orders = [];
            if (options.orderBy.orders && Array.isArray(options.orderBy.orders)){
                for (let i = 0; i < options.orderBy.fields.length; i ++) {
                    let order = SortOrder.ASC;
                    let ord = options.orderBy.orders[i];
                    ord = ord? ord.toLowerCase() : 'asc';
                    if ('desc' === ord || 'descend' === ord || 'descending' === ord ){
                        order = SortOrder.DESC;
                    }
                    orders.push(order);
                }
            }
            this.orderBy = {fields: options.orderBy.fields, orders: orders};
        }

        if (options && options.pagination && !isNaN(options.pagination.size) && !isNaN(options.pagination.page)
            && options.pagination.size > 0 && options.pagination.page > 0 ){
            this.pagination = {size: options.pagination.size, page: options.pagination.page}
        }
    }

    public addIgnoreCaseFields(fieldName: string): SelectConstraints{
        if (!this.ignoreCaseFields) this.ignoreCaseFields = [];
        this.ignoreCaseFields.push(fieldName);
        return this;
    }
}


class BulkLoadConstraints{

    replaceStrategy: BulkLoadReplaceStrategy;

    constructor(){
        this.setReplaceAsDeleteInsert();
    }

    setReplaceAsDeleteInsert(){
        this.replaceStrategy = BulkLoadReplaceStrategy.DELETE_INSERT;
    }

    isReplaceAsDeleteInsert(){
        return this.replaceStrategy === BulkLoadReplaceStrategy.DELETE_INSERT;
    }

    setReplaceAsUpdate(){
        this.replaceStrategy = BulkLoadReplaceStrategy.UPDATE;
    }

    isReplaceAsUpdate(): boolean {
        return this.replaceStrategy === BulkLoadReplaceStrategy.UPDATE;
    }
    
    setReplaceAsIgnore(){
        this.replaceStrategy = BulkLoadReplaceStrategy.IGNORE;
    }

    isReplaceAsIgnore(): boolean{
        return this.replaceStrategy === BulkLoadReplaceStrategy.IGNORE;
    }
}

export interface TxnResult {
    status: boolean;
    message?: string;
    data?: any;
    results?: TxnResult[]
}

export interface PartitionSetting {
    [key: string]: number,
}

export interface DataEntity {

}

export interface TxnOps {
    txnId?: string
    isSilent?: boolean
    constraints?: SelectConstraints
    bulkloadConstraints?: BulkLoadConstraints
}

export {
    DataEntityMetadata, PersistMethod,  PersistType, SelectConstraints,
    BulkLoadConstraints, DatabaseMetadata, DataStrategy, SortOrder, 
    SyncMode, EntityType, SchemaType, AnalyzeMethod, IntegratyLevel, BulkLoadReplaceStrategy
    // ,ProcessPooling
}