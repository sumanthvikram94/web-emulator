
import { jest } from '@jest/globals'
import fse from 'fs-extra'
import path from 'path'

import { waitTime } from './utiles'
import {EntityType,SchemaType } from '../../dist/main/metadata';
import { VERSION } from '../constants/version.js'

const globalAny = global
const BZDB: any = (globalAny as any).BZDB

import { fileURLToPath } from 'url';
import { dirname } from 'path';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

let metadata1: any;
let metadata2: any;
let bzdb : any;
let bzdbpeer : any;
const logConfig = {
    type: process.env.BZ_LOGGER_TYPE,
    logLevels: { // -1-SILENT, 0-SEVERE, 1-WARN, 2-INFO, 3-DEBUG
        default: -1,
        txn: -1,
        metadata: -1,
        cluster: -1,
        checkin: -1,
        pull: -1,
        performance: -1
    }
}
class TestCmd{
    id: string
    constructor(id:string){
        this.id = id
    }
    fun(param: string) {
        return {
            status: true,
            id: this.id,
            param
        }
    }
}

jest.setTimeout(180000)

beforeAll(async () => {
    const meta_peer1 = {
        id: '12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic',
        peerId:{
            id:"12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic",
            pubKey:"CAESIEOhicVh+DS04dd78tW4Qp6cDvRMFVdiFdCqXxxlcaVV"
        },
        port: 8643,
        version: VERSION,
        multiaddrs:["/ip4/127.0.0.1/tcp/8643/p2p/12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic"],
        timestamp:1696831208446,
        nodeType:"persistent"
    }
    const meta_peer2 = {
        id: '12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3',
        peerId:{
            id:"12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3",
            pubKey:"CAESIOsMCYaP0+2wkf8S6aGlRbYv3O9yeym9CUEFbcsYpVts"
        },
        port: 8644,
        version: VERSION,
        multiaddrs:["/ip4/127.0.0.1/tcp/8644/p2p/12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3"],
        timestamp:1696831209890,
        nodeType:"persistent"
    }
    const peersPath1 = path.join(__dirname, '../../utdatacluster/peer1/_db_store/_metadata/peers')
    const peersPath2 = path.join(__dirname, '../../utdatacluster/peer2/_db_store/_metadata/peers')
    const peer1file = path.join(__dirname, '../../utdatacluster/peer1/_db_store/_metadata/peers/12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic.json')
    if (fse.existsSync(peer1file)){
        fse.unlinkSync(peer1file)
    }
    const peer2file = path.join(__dirname, '../../utdatacluster/peer2/_db_store/_metadata/peers/12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3.json')
    if (fse.existsSync(peer2file)){
        fse.unlinkSync(peer2file)
    }
    const removeFoders=[
        path.join(__dirname, '../../utdatacluster/peer1/_db_store/_metadata/block'),
        path.join(__dirname, '../../utdatacluster/peer1/_db_store/_metadata/chain'),
        path.join(__dirname, '../../utdatacluster/peer1/fileSyncTest'),
        path.join(__dirname, '../../utdatacluster/peer1/_db_store/_extend'),
        path.join(__dirname, '../../utdatacluster/peer2/_db_store/_metadata/block'),
        path.join(__dirname, '../../utdatacluster/peer2/_db_store/_metadata/chain'),
        path.join(__dirname, '../../utdatacluster/peer2/fileSyncTest'),
        path.join(__dirname, '../../utdatacluster/peer2/_db_store/_extend'),
        peersPath1,
        peersPath2,
    ]
    for await (let afolder of removeFoders){
        fse.removeSync(afolder);
    }
    
    fse.ensureDirSync(peersPath1)
    fse.ensureDirSync(peersPath2)

    fse.writeFileSync(peer1file, JSON.stringify(meta_peer1))
    fse.writeFileSync(peer2file, JSON.stringify(meta_peer2))

    /*const excludedDirs = ['node', 'peers', '_metadata'];
    const baseDir = path.join(__dirname, '../../utdatacluster/peer1');
    const dirs = [
        path.join(baseDir, 'peer1'),
        path.join(baseDir, 'peer1/_db_store'),
        path.join(baseDir, 'peer2'),
        path.join(baseDir, 'peer2/_db_store'),
    ]*/

    const metaobj = {
        appName: 'testCluster',
        storePath: './utdatacluster/peer1',
        processPooling: 0,
        rejectPKonUpdate: false,
        logging: logConfig,
        enableWorkerThread: false,
        isSingleton: false,
        cluster: {
            enabled: true,
            autoScaling: {
                enabled: false
            }
        },
        performance: {
            workOnBusy: true
        },
        dataEntities: [
            {name: 'testde', primaryKeys:['id']},
            {name: 'testde1', primaryKeys:['id']},
            {name: 'testde2', primaryKeys:['id']},
            {
                name: 'testGiveName', 
                primaryKeys:[],
                persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                filePath: '/testGiveName',
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
            },
            {
                name: 'upload',
                primaryKeys:[],
                persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                filePath: '/upload',
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
                persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
            },
            {name: 'testLocalData', primaryKeys:['id'], syncMode: BZDB.SyncMode.SYNC_LOCAL},
            {
                name: 'fileSync',
                primaryKeys: ['relative_path'],
                partitions: {
                    relative_path: 1
                },
                // persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                // persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,
                // fileName: 'fileSync.json',
                syncFile4Cluster: true
            }
        ],
        onLoadReady: (results: any) => {
            console.log('onLoadReady results: ' + JSON.stringify(results))
        }
    }
    
    metadata1 = new BZDB.DatabaseMetadata(metaobj)
    bzdb = BZDB.create(metadata1)
    const metaobj2 = JSON.parse(JSON.stringify(metaobj))
    metaobj2.storePath = './utdatacluster/peer2';
    metadata2 = new BZDB.DatabaseMetadata(metaobj2)
    bzdbpeer = BZDB.create(metadata2)
    await bzdb.waitLoadReady()
    await bzdbpeer.waitLoadReady()

    await bzdb.drop(SchemaType.PERSIST_ENTITY,'extendPeer_1'); 
    await bzdbpeer.drop(SchemaType.PERSIST_ENTITY,'extendPeer_2');
    const persist1={name: 'extendPeer_1',primaryKeys: ['id'],entityType:EntityType.PERSIST,filePath:'extendPeer1'}
    await bzdb.create(SchemaType.PERSIST_ENTITY,persist1);
    // const extend1=await bzdb.create(SchemaType.PERSIST_ENTITY,persist1); 
    // console.log(JSON.stringify(extend1));
    await bzdb.insert('extendPeer_1', {id: '1', name: 'Tom'});
    await bzdb.insert('extendPeer_1', {id: '2', name: 'Jerry'});

    const persist2={name: 'extendPeer_2',primaryKeys: ['id'],entityType:EntityType.PERSIST,filePath:'extendPeer2'}
    await bzdbpeer.create(SchemaType.PERSIST_ENTITY,persist2);
    // const extend2=await bzdbpeer.create(SchemaType.PERSIST_ENTITY,persist2);
    // console.log(JSON.stringify(extend2));
    await bzdbpeer.insert('extendPeer_2', {id: '1', name: 'Tom2'});
    await bzdbpeer.insert('extendPeer_2', {id: '2', name: 'Jerry2'});

})

// afterAll(async (done) => {
//     console.log('Done with index.js testing')
//     // if (bzdb) await bzdb.stop()
//     // if (bzdbpeer) await bzdbpeer.stop();
//     // setTimeout(() => {
//     //     // done()
//     //     console.log('exit')
//     //     // process.exit()
//     // }, 5000);
// })

describe('loading ', () => {

    test('Database should be loaded', async () => {
        await bzdb.waitLoadReady()
        await bzdbpeer.waitLoadReady()
        expect.assertions(2)
        expect(bzdb).toBeInstanceOf(BZDB.DbManager)
        expect(bzdbpeer).toBeInstanceOf(BZDB.DbManager)
        return
    })
    
    test('Data entity should be loaded', async () => {
        expect.assertions(6)
        const testData = await bzdb.select('testde')
        expect(testData).toBeTruthy()
        expect(testData.dataEntityName).toBe('testde')
        const extendEntity1 = await bzdb.select('extendPeer_1')
        expect(extendEntity1.dataEntityName).toBe('extendPeer_1')

        //peer
        const testDataPeer = await bzdbpeer.select('testde')
        expect(testDataPeer).toBeTruthy()
        expect(testDataPeer.dataEntityName).toBe('testde')
        const extendEntity2 = await bzdbpeer.select('extendPeer_2')
        expect(extendEntity2.dataEntityName).toBe('extendPeer_2')
        return
    })
})


/**
 * Introduce
 */

 describe('Introduce', () => {

    test('Introduce should check Application name', async () => {
        expect.assertions(3)
        await bzdbpeer.stop()
        metadata2.getMetaData().appName = 'testCluster different app'
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        // const bzdbpeerStatus = await bzdbpeer.checkStatus()
        // console.log(bzdbpeerStatus)
        // const bzdbStatus = await bzdb.checkStatus()
        // console.log(bzdbStatus)
        await waitTime(5000)
        // Do introduce
        const queryResult = await bzdbpeer.select('meta_peers')
        const result = await bzdb.introduceNode(queryResult.data[0])
        expect(result).toBeTruthy()
        expect(result.status).toBe(false)
        expect(result.message).toBe('Application not compatible')

        await bzdbpeer.stop()
        metadata2.getMetaData().appName = 'testCluster'
        // bzdbpeer = BZDB.create(metadata2)
        // await bzdbpeer.waitLoadReady()
    })

    test('Introduce should check version in metadata', async () => {
        expect.assertions(3)
        // await bzdbpeer.stop()
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        const peermeta = (await bzdbpeer.select('meta_peers')).data[0]
        peermeta.version = Object.assign({}, VERSION)
        const peermeta2 = Object.assign({}, peermeta)
        peermeta2.version.patch = 1000
        const filter = {id: peermeta.id}
        await bzdbpeer.update('meta_peers', filter, peermeta2)
        // Do introduce
        const queryResult = await bzdbpeer.select('meta_peers')
        const result = await bzdb.introduceNode(queryResult.data[0])
        expect(result).toBeTruthy()
        expect(result.status).toBe(false)
        expect(result.message).toBe('Application version not compatible')
        peermeta.version = Object.assign({}, VERSION)
        await bzdbpeer.update('meta_peers', filter, peermeta)
        // const updateResult = await bzdbpeer.update('meta_peers', filter, peermeta)
        // console.log(updateResult)
    })

    test('Introduce should check internal DB version', async () => {
        // currently not testable, both bzdb and bzdbpeer reads the same version file.
    })
    
    test('Introduce should succeed', async () => {
        expect.assertions(31)
        // Prepare for testing
        await bzdb.waitLoadReady()
        await bzdbpeer.waitLoadReady()
        await bzdb.delete('testde')
        await bzdbpeer.delete('testde')
        await bzdb.delete('testLocalData')
        await bzdbpeer.delete('testLocalData')
        // Insert 1 row to primary node before introduce.
        await bzdb.insert('testde', {id: 1, desc: 'should be synched'})
        let queryResult = await bzdb.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        queryResult = await bzdb.select('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toBeTruthy()
        queryResult = await bzdbpeer.select('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toBeTruthy()

        let tmp = 1
        const interval = setInterval(() => { // keep inserting data while doing pull
            bzdb.insert('testde', {id: ++ tmp, desc: 'should be synched'})
        }, 20)

        // Do introduce
        const result = await bzdb.introduceNode(queryResult.data[0])
        expect(result).toBeTruthy()
        expect(result.status).toBe(true)
        await waitTime(5000)

        clearInterval(interval)

        // Verify meta_peers
        queryResult = await bzdb.count('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(2)
        await bzdbpeer.waitStatusReady()
        queryResult = await bzdbpeer.count('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(2)
        // Verify data synch for pre exist data, this should cover the checkin and pull
        queryResult = await bzdbpeer.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // Delete the pre exist data in whole cluster
        await bzdb.delete('testde')
        queryResult = await bzdb.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(0)
        queryResult = await bzdbpeer.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(0)

        //check entend entity
        const extendEntity1_1 = await bzdb.select('extendPeer_1')
        expect(extendEntity1_1).toBeTruthy()
        expect(extendEntity1_1.rowCount).toBe(2)
        const extendEntity1_2 = await bzdb.select('extendPeer_2')
        expect(extendEntity1_2).toBeTruthy()
        expect(extendEntity1_2.rowCount).toBe(0)

        const extendEntity2_1 = await bzdbpeer.select('extendPeer_1')
        expect(extendEntity2_1).toBeTruthy()
        expect(extendEntity2_1.rowCount).toBe(2)
        const extendEntity2_2 = await bzdbpeer.select('extendPeer_2')
        expect(extendEntity2_2).toBeTruthy()
        expect(extendEntity2_2.rowCount).toBe(0)

        await bzdb.checkin()
        const status = await bzdb.checkStatus()
        expect(status.status).toBe(true)
        expect(status.data[0].status).toBe('ready')
        expect(status.data[1].status).toBe('ready')
    })

})

describe('Retrieve status', () => {
    test('Retrieve status should succeed', async() => {
        expect.assertions(5)
        const status = await bzdb.checkStatus()
        expect(status).toBeTruthy()
        expect(status.status).toBe(true)
        expect(status.data.length).toBe(2)
        expect(status.data[0]).toEqual({id: '12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic', status: 'ready', isLocal: true, inNet: true, listening: true, conflictDetails: []})
        expect(status.data[1]).toEqual({id: '12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3', status: 'ready', isLocal: false, inNet: true, listening: true, conflictDetails: []})
    })
    test('Retrieve status should show offline peer', async() => {
        expect.assertions(5)
        await bzdbpeer.stop()
        await waitTime(10000)
        const status = await bzdb.checkStatus()
        expect(status).toBeTruthy()
        expect(status.status).toBe(true)
        expect(status.data.length).toBe(2)
        expect(status.data[0]).toEqual({id: '12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic', status: 'lonely island', isLocal: true, inNet: true, listening: true, conflictDetails: []})
        expect(status.data[1]).toEqual({id: '12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3', status: 'offline', isLocal: false, inNet: true, listening: false, conflictDetails: []})
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        const tmp = await bzdb.checkStatus()
        console.log(tmp)
    })
})

describe('exec', () => {
    test('exec unknown command should have return', async() => {
        expect.assertions(6)
        let result = await bzdb.exec('unknown cmd') // execute locally
        expect(result).toBeTruthy()
        expect(result.status).toBe(false)
        expect(result.message).toBe('Unknown command')

        result = await bzdb.exec('unknown cmd', [], '12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic') // execute remotely
        expect(result).toBeTruthy()
        expect(result.status).toBe(false)
        expect(result.message).toBe('Unknown command')

        // result = await bzdb.exec('shutdown') // shutdown will kill the process, so, not testable yet.
    })

    
    test('exec registered command should success', async() => {
        expect.assertions(8)
        // await bzdbpeer.waitLoadReady()
        const tc1 = new TestCmd('test-cmd-1')
        const tc2 = new TestCmd('test-cmd-2')
        let result = await bzdb.registerCommand('whoami', tc1.fun.bind(tc1))
        result = await bzdbpeer.registerCommand('whoami', tc2.fun.bind(tc2))
        result = await bzdb.exec('whoami', ['param1']) // execute locally
        expect(result).toBeTruthy()
        expect(result.status).toBe(true)
        expect(result.id).toBe('test-cmd-1')
        expect(result.param).toBe('param1')

        result = await bzdb.exec('whoami', ['param2'], '12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3') // execute remotely
        expect(result).toBeTruthy()
        expect(result.status).toBe(true)
        expect(result.id).toBe('test-cmd-2')
        expect(result.param).toBe('param2')

        // result = await bzdb.exec('shutdown') // shutdown will kill the process, so, not testable yet.
    })
})

describe('Incremental pull', () => {
    test('Incremental pull should succeed', async() => {
        expect.assertions(5)
        // Prepare for testing
        await bzdb.delete('testde')
        await waitTime(1000)
        // stop peer node
        await bzdbpeer.stop()
        await waitTime()
        // insert into the active node
        await bzdb.insert('testde', {id: 1, desc: 'should be synched'})

        let tmp = 1
        const interval = setInterval(() => { // keep inserting data while doing pull
            bzdb.insert('testde', {id: ++ tmp, desc: 'should be synched'})
        }, 20)

        // start the peer node
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        await waitTime()
        await bzdbpeer.waitStatusReady()

        clearInterval(interval)
        // check the inserted row pulled to peer node
        let queryResult = await bzdbpeer.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        await waitTime()
        await bzdb.checkin()
        const status = await bzdb.checkStatus()
        expect(status.status).toBe(true)
        expect(status.data[0].status).toBe('ready')
        expect(status.data[1].status).toBe('ready')
    })
})

describe('Full pull', () => {
    test('Full pull should succeed', async() => {
        expect.assertions(7);
        // Prepare for testing
        await bzdb.delete('testde')
        await waitTime(1000)
        // stop peer node
        // console.log('>>>>>>> Stopping the peer node')
        await bzdbpeer.stop();
        await waitTime()
        // insert into the active node
        await bzdb.insert('testde', {id: 1, desc: 'should be synched'}); 
        await waitTime(1000)
        // stop primary node
        // console.log('>>>>>>> Stopping the primary node')
        await bzdb.stop()
        await waitTime()
        // start the peer node
        // console.log('>>>>>>> Start the peer node')
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        // insert into the peer node, introduce data conflict
        await bzdbpeer.insert('testde', {id: 2, desc: 'should be synched'}); 
        // start the primary node
        // console.log('>>>>>>> Start the primary node')
        bzdb = BZDB.create(metadata1)
        await bzdb.waitLoadReady()
        await waitTime()
        // check the data in primary node
        let queryResult = await bzdb.select('testde')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // check the data in peer node
        queryResult = await bzdbpeer.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(0)
        // Do full pull
        await bzdb.forcePullData('12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3')
        await waitTime(12000) // 5 seconds. Might need increase it if data volume is big.
        // check the data in peer node
        queryResult = await bzdbpeer.select('testde', {id: 1})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // verify status is 'ready'
        expect(await bzdb.getStatus()).toBe('ready');
    })
})

describe('Transactions', () => {
    beforeEach( async () => {
        await bzdb.waitStatusReady()
        await bzdbpeer.waitStatusReady()
        await bzdb.delete('testde')
    })

    test('Transactions should be queued up', async () => {
        expect.assertions(11)
        let queryResult = await bzdb.select('testde')
        expect(queryResult.rowCount).toBe(0)
        let queryResultPeer = await bzdb.select('testde')
        expect(queryResultPeer.rowCount).toBe(0)
        bzdb.updateOrInsert('testde', {id: 1})
        bzdb.updateOrInsert('testde', {id: 2})
        let txnResultPromise3 = bzdb.updateOrInsert('testde', {id: 3})
        let txnResult = await txnResultPromise3
        expect(txnResult.status).toBe(true)
        queryResult = await bzdb.select('testde')
        expect(queryResult.rowCount).toBe(3)
        expect(queryResult.data[0].id).toBe(1)
        expect(queryResult.data[1].id).toBe(2)
        expect(queryResult.data[2].id).toBe(3)
        await waitTime(1000)
        queryResultPeer = await bzdb.select('testde')
        expect(queryResultPeer.rowCount).toBe(3)
        expect(queryResultPeer.data[0].id).toBe(1)
        expect(queryResultPeer.data[1].id).toBe(2)
        expect(queryResultPeer.data[2].id).toBe(3)
    })

    test('Concurrent txns should succeed', async () => {
        expect.assertions(8)
        let queryResult = await bzdb.select('testde')
        expect(queryResult.rowCount).toBe(0)
        let queryResultPeer = await bzdb.select('testde')
        expect(queryResultPeer.rowCount).toBe(0)

        let txnResultPromise = bzdb.updateOrInsert('testde', {id: 1})
        await waitTime(1)
        let txnResultPeerPromise = bzdbpeer.updateOrInsert('testde', {id: 2})
        let txnResult = await txnResultPromise
        expect(txnResult.status).toBe(true)
        let txnResultPeer = await txnResultPeerPromise
        expect(txnResultPeer.status).toBe(true)
        await waitTime(1000)
        queryResult = await bzdb.select('testde')
        expect(queryResult.rowCount).toBe(2)
        expect(queryResult.data[0].id).toBe(1)
        
        queryResultPeer = await bzdb.select('testde')
        expect(queryResultPeer.rowCount).toBe(2)
        expect(queryResultPeer.data[1].id).toBe(2)
    })

    test('Sync Local mode should work in current node', async () => {
        expect.assertions(17)
        let queryResult = await bzdb.select('testLocalData')
        expect(queryResult.rowCount).toBe(0)
        let queryResultPeer = await bzdb.select('testLocalData')
        expect(queryResultPeer.rowCount).toBe(0)

        let txnResultPromise = bzdb.insert('testLocalData', {id: 1})
        let txnResultPeerPromise = bzdbpeer.updateOrInsert('testLocalData', {id: 2})
        let txnResult = await txnResultPromise
        expect(txnResult.status).toBe(true)
        let txnResultPeer = await txnResultPeerPromise
        expect(txnResultPeer.status).toBe(true)
        await waitTime(1000)
        queryResult = await bzdb.select('testLocalData')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0].id).toBe(1)
        
        queryResultPeer = await bzdbpeer.select('testLocalData')
        expect(queryResultPeer.rowCount).toBe(1)
        expect(queryResultPeer.data[0].id).toBe(2)

        txnResultPromise = bzdb.update('testLocalData', {id: 1}, {name: 'cmu'})
        txnResultPeerPromise = bzdbpeer.bulkLoad('testLocalData', [{id: 3}, {id: 4, name: 'Jerry'}])
        txnResult = await txnResultPromise
        expect(txnResult.status).toBe(true)
        txnResultPeer = await txnResultPeerPromise
        expect(txnResultPeer.status).toBe(true)
        await waitTime(1000)
        queryResult = await bzdb.select('testLocalData')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0].name).toBe('cmu')
        
        queryResultPeer = await bzdbpeer.select('testLocalData')
        expect(queryResultPeer.rowCount).toBe(3)
        expect(queryResultPeer.data[2].name).toBe('Jerry')

        queryResult = await bzdb.select('testLocalData', {}, {"selectCluster": "true"})
        expect(queryResult.rowCount).toBe(2)
        expect(queryResult.data[0].data.rowCount).toBe(3)
        expect(queryResult.data[1].data.data[0].id).toBe(1)
    })
})

describe('File sync', () => {
    test('File sync should work', async () => {  
        expect.assertions(8); 

        // Prepare for testing
        await bzdb.waitLoadReady();
        await bzdbpeer.waitLoadReady();
        // clear DB
        await bzdb.delete('fileSync');
        await bzdbpeer.delete('fileSync');
        // clear files
        const fsDir1 = path.join(__dirname, '../../utdatacluster/peer1/fileSyncTest');
        const fsDir2 = path.join(__dirname, '../../utdatacluster/peer2/fileSyncTest');
        const dirs = [fsDir1, fsDir2]
        for (const dir of dirs) {
            if (!fse.existsSync(dir)) {
                fse.mkdirsSync(dir)
            }
        }
        const fsFileName = 'testFS.txt';
        const fs1 = path.join(fsDir1, fsFileName);
        const fs2 = path.join(fsDir2, fsFileName);
        const fsFileName2 = 'testFS-force-pull.txt';
        const fsPull1 = path.join(fsDir1, fsFileName2);
        const fsPull2 = path.join(fsDir2, fsFileName2);
        const files = [fs1, fs2, fsPull1, fsPull2]
        for (const file of files) {
            if (fse.existsSync(file)) {
                fse.unlinkSync(file)
            }
        }
        // ==> test add sync
        // create a file in peer1
        const content = 'file sync ' + Date.now();
        fse.writeFileSync(fs1, content);
        // update DB in peer1
        let fsi = await bzdb.getFileSyncInfo(fs1, true);
        await bzdb.updateOrInsert('fileSync', fsi);        
        await waitTime(1000);
        // verify the file should be added in peer2
        expect(fse.existsSync(fs2)).toBeTruthy();
        expect(fse.readFileSync(fs2).toString()).toBe(content);

        // ==> test del sync
        // delete the file in peer2
        fse.unlinkSync(fs2);
        fsi = await bzdbpeer.getFileSyncInfo(fs2, false)
        await bzdbpeer.updateOrInsert('fileSync', fsi);
        await waitTime(1000);
        // verify the file should be deleted in peer1
        expect(fse.existsSync(fs1)).toBeFalsy();

        // ==> test pull
        // stop peer node
        // console.log('>>>>>>> Stopping the peer node')
        await bzdbpeer.stop();
        await waitTime();
        // create file in peer1 again
        fse.writeFileSync(fs1, content);
        // update DB in peer1
        fsi = await bzdb.getFileSyncInfo(fs1, true)
        await bzdb.updateOrInsert('fileSync', fsi);
        // start the peer node
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        await waitTime(6000)
        await bzdbpeer.checkin() // It sometimes get fake data conflict status during the data pulling is still in progress.
        await bzdbpeer.waitStatusReady()
        await bzdb.checkin() // It sometimes get fake data conflict status during the data pulling is still in progress.
        await bzdb.waitStatusReady()
        // verify the file should be added in peer2
        expect(fse.existsSync(fs2)).toBeTruthy();
        expect(fse.readFileSync(fs2).toString()).toBe(content);

        // ==> test data conflict
        const content2 = 'file sync force pull ' + Date.now();
        fse.writeFileSync(fsPull1, content2);
        fsi = await bzdb.getFileSyncInfo(fsPull1, true)
        await bzdb.updateOrInsert('fileSync', fsi);
        // const result = await bzdb.updateOrInsert('fileSync', fsi);
        // console.log(result)
        await waitTime(3000);
        // the new file should be sync to peer2
        expect(fse.existsSync(fsPull2)).toBeTruthy();
        // manually delete files to make conflict
        fse.unlinkSync(fsPull2)
        // checkin in peer1
        await bzdb.checkin();
        // verify status is 'data conflict'
        const status = await bzdb.getStatus()
        expect(status).toBe('data conflict');
        // Do full pull
        await bzdb.forcePullData('12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3');        
        await waitTime(12000);
        // verify status is 'ready'
        expect(await bzdb.getStatus()).toBe('ready');
    })


    test('Batch file sync should work', async () => {  
        expect.assertions(8); 

        // Prepare for testing
        await bzdb.waitLoadReady();
        await bzdbpeer.waitLoadReady();
        // clear DB
        await bzdb.delete('fileSync');
        await bzdbpeer.delete('fileSync');
        // clear files
        const fsDir1 = path.join(__dirname, '../../utdatacluster/peer1/fileSyncTest');
        const fsDir2 = path.join(__dirname, '../../utdatacluster/peer2/fileSyncTest');
        const dirs = [fsDir1, fsDir2]
        for (const dir of dirs) {
            if (!fse.existsSync(dir)) {
                fse.mkdirsSync(dir)
            }
        }
        const fsFileName = 'testFS.txt';
        const fs1 = path.join(fsDir1, fsFileName);
        const fs2 = path.join(fsDir2, fsFileName);
        const fsFileName2 = 'testFS-force-pull.txt';
        const fsPull1 = path.join(fsDir1, fsFileName2);
        const fsPull2 = path.join(fsDir2, fsFileName2);
        const files = [fs1, fs2, fsPull1, fsPull2]
        for (const file of files) {
            if (fse.existsSync(file)) {
                fse.unlinkSync(file)
            }
        }
        // ==> test add sync
        // create a file in peer1
        const content = 'file sync ' + Date.now();
        fse.writeFileSync(fs1, content);
        // update DB in peer1
        await bzdb.batchTxn([{dataEntityName: 'fileSync', action:'UPDATEORINSERT',value: await bzdb.getFileSyncInfo(fs1, true)}]);        
        await waitTime(1000);
        // verify the file should be added in peer2
        expect(fse.existsSync(fs2)).toBeTruthy();
        expect(fse.readFileSync(fs2).toString()).toBe(content);

        // ==> test del sync
        // delete the file in peer2
        fse.unlinkSync(fs2);
        await bzdbpeer.batchTxn([{dataEntityName: 'fileSync', action:'UPDATEORINSERT',value: await bzdbpeer.getFileSyncInfo(fs2, false)}]);    
        // await bzdbpeer.updateOrInsert('fileSync', bzdbpeer.getFileSyncInfo(fs2, false));
        await waitTime(1000);
        // verify the file should be deleted in peer1
        expect(fse.existsSync(fs1)).toBeFalsy();

        // ==> test pull
        // stop peer node
        // console.log('>>>>>>> Stopping the peer node')
        await bzdbpeer.stop();
        await waitTime();
        // create file in peer1 again
        fse.writeFileSync(fs1, content);
        // update DB in peer1
        await bzdb.batchTxn([{dataEntityName: 'fileSync', action:'UPDATEORINSERT',value: await bzdb.getFileSyncInfo(fs1, true)}]);      
        // await bzdb.updateOrInsert('fileSync', bzdb.getFileSyncInfo(fs1, true));
        // start the peer node
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        await waitTime()
        await bzdbpeer.checkin()
        await bzdbpeer.waitStatusReady()
        await bzdb.checkin()
        await bzdb.waitStatusReady()
        // await waitTime(1000);
        // verify the file should be added in peer2
        expect(fse.existsSync(fs2)).toBeTruthy();
        expect(fse.readFileSync(fs2).toString()).toBe(content);

        // ==> test data conflict
        const content2 = 'file sync force pull ' + Date.now();
        fse.writeFileSync(fsPull1, content2);
        await bzdb.batchTxn([{dataEntityName: 'fileSync', action:'UPDATEORINSERT',value: await bzdb.getFileSyncInfo(fsPull1, true)}]);    
        // const result = await bzdb.batchTxn([{dataEntityName: 'fileSync', action:'UPDATEORINSERT',value: await bzdb.getFileSyncInfo(fsPull1, true)}]);    
        // console.log(result) 
        // await bzdb.updateOrInsert('fileSync', bzdb.getFileSyncInfo(fsPull1, true));
        await waitTime(1000);
        // the new file should be sync to peer2
        expect(fse.existsSync(fsPull2)).toBeTruthy();
        // manually delete files to make conflict
        fse.unlinkSync(fsPull2)
        await waitTime(1000);
        // checkin in peer1
        await bzdb.checkin();
        // verify status is 'data conflict'
        expect(await bzdb.getStatus()).toBe('data conflict');
        // Do full pull
        await bzdb.forcePullData('12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3');        
        await waitTime(12000);
        // verify status is 'ready'
        expect(await bzdb.getStatus()).toBe('ready');
    })
})

describe('Kick node', () => {
    test('Kick should succeed', async () => {
        expect.assertions(16)
        // Prepare for testing
        await bzdb.waitLoadReady()
        await bzdbpeer.waitLoadReady()
        // Insert 1 row to cluster, this should prove txn works
        await bzdb.insert('testde', {id: 1, desc: 'should be synched'})
        let queryResult = await bzdb.select('testde', {id: '1'})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        await waitTime(1000)
        queryResult = await bzdbpeer.select('testde', {id: '1'})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // verify meta_peers before kick
        queryResult = await bzdb.select('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(2)
        queryResult = await bzdbpeer.select('meta_peers', {id: '12D3KooWRdtd7tQ1qgvVNDhfQPGn26mcSKmMYb9jNAhGNPtdbZa3'})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toBeTruthy()
        // Do Kick
        const result = await bzdb.kickNode(queryResult.data[0])
        expect(result).toBeTruthy()
        await waitTime()
        // Verify meta_peers after kick
        queryResult = await bzdb.count('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        queryResult = await bzdbpeer.count('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // Verify data not deleted by kicking node.
        queryResult = await bzdbpeer.select('testde', {id: '1'})
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        // Delete the pre exist data in whole cluster
        await bzdb.delete('testde')
        await bzdb.delete('testLocalData')
    })

    test('Kick should succeed even the peer is offline', async () => {
        expect.assertions(9)
        await waitTime(3000)
        // Do introduce
        let queryResult = await bzdbpeer.select('meta_peers')
        let result = await bzdb.introduceNode(queryResult.data[0])
        expect(result).toBeTruthy()
        expect(result.status).toBe(true)
        await waitTime()
        // Stop bzdbpeer
        await bzdbpeer.stop()
        await waitTime()
        // Do Kick
        result = await bzdb.kickNode(queryResult.data[0])
        expect(result).toBeTruthy()
        await waitTime(1000)
        // Verify meta_peers after kick
        queryResult = await bzdb.count('meta_peers')
        expect(queryResult).toBeTruthy()
        expect(queryResult.rowCount).toBe(1)
        
        queryResult = await bzdb.count('meta_peers')
        // Verify status after kick
        const status = await bzdb.checkStatus()
        expect(status).toBeTruthy()
        expect(status.status).toBe(true)
        expect(status.data.length).toBe(1)
        expect(status.data[0]).toEqual({id: '12D3KooWENNMEmArKZm3GiiXE2zmYzYDZDx9yW97cBXW6fDwgVic', status: 'ready', isLocal: true, inNet: false, listening: true, conflictDetails: []})
    })
})


describe('DB Stop',  () => {
    test('DB should stop', async () => {
        await bzdb.waitLoadReady();
        await bzdb.stop()
        await bzdbpeer.waitLoadReady();
        await bzdbpeer.stop()
        process.stdout.removeAllListeners()
        process.stderr.removeAllListeners()
        process.stdin.removeAllListeners()
        // process.stdin.push(Buffer.from([0x0D, 0x0A]))
        await waitTime(1000)
        // done()
        // process.stdin.push(Buffer.from([0x0D, 0x0A]))
        // process.exit(0) // The test doesn't stop, so forcing it to exit. // TBD, should research why it doesn't stop after bzdb.stop()
    })
})

