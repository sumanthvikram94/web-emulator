import { PeerId } from '@libp2p/interface-peer-id';
import { PrivateNetNode } from './private-net-node.js';
import { InternalDatabaseInterface } from '../main/db-interface.js';
import { IPeerMeta, NodeMetadata, IPeerState } from './node-metadata.js';
import { NodeMsgHandler } from './node-msg-handler.js';
import { DbWorker } from '../main/db-worker.js';
import { Task, Workflow } from '../workflow/index.js';
import { FileSyncTask } from '../main/file-sync.js';
import Queue from 'better-queue';
export declare enum AUTO_SCALE_STATUS {
    NONE = 0,
    ACCEPTING = 1,
    ACCEPTED = 2
}
declare class NodeStateHandler {
    _peers: Map<string, IPeerState>;
    _privateNet: PrivateNet;
    _interval: any;
    _connectedPeers: any;
    _debounceId: any;
    constructor(privateNet: PrivateNet);
    setPeerState(peerId: string, peerState: IPeerState): void;
    get connectedPeers(): any;
    get peers(): Map<string, IPeerState>;
    getPeerState(peerId: string): IPeerState | undefined;
    /**
     *
     * @returns All the active peers
     */
    getActivePeers(): IPeerMeta[];
    getActivePeersAndSelf(): IPeerMeta[];
    debounce(func: any, wait?: number): void;
    checkPeerState(): Promise<boolean>;
    setAddressBook(): Promise<void>;
    /**
     * Adds a peer into address book
     * @param peer
     * @returns
     */
    addAddressBook(peer: NodeMetadata): Promise<void>;
}
/**
 * Class to handle the private network logics
 */
declare class PrivateNet {
    _node: PrivateNetNode;
    _msgHandler: NodeMsgHandler;
    _internalDb: InternalDatabaseInterface;
    _worker: DbWorker;
    _peers: Map<string, IPeerState>;
    _pullingProm: Promise<any> | undefined;
    _autoScaleStatus: AUTO_SCALE_STATUS;
    _scalingNodeList: Map<string, any>;
    _clusterResolve: Function;
    _autoScaleQueue: Queue;
    _nodeStateHandler: NodeStateHandler;
    constructor(worker: DbWorker);
    get autoScaleStatus(): AUTO_SCALE_STATUS;
    set autoScaleStatus(val: AUTO_SCALE_STATUS);
    /**
     * Launch the local node.
     * @param forceReLaunch
     */
    private launchNode;
    /**
     * Send message to the specific peer for a task
     * @param peer
     * @param channel
     * @param taskid
     * @param payload
     * @returns
     */
    sendTask(peer: IPeerMeta, channel: string, taskid: string, payload: object, isUnknownPeer?: boolean, isNotZipped?: boolean): Promise<void | {
        status: boolean;
        message: any;
    }>;
    getPeerConnection(id: PeerId): any;
    private setTaskBroadcastStatus;
    showStatus(isInfo?: boolean): Promise<void>;
    /**
     * Broadcast message to all peers for a task
     * @param task
     * @param channel
     * @param payload
     */
    broadcast(task: Task, channel: string, payload: object, workflow?: Workflow, timeoutMs?: number, toPeerIds?: Array<string>): Promise<void>;
    getPeerMeta(peerId: any): Promise<NodeMetadata>;
    isAutoScalingEnabled(): boolean;
    isScalableNode(): boolean;
    /**
     * For auto-scaling clustering.
     * Persistent nodes send auto-scale request to new instance, and new instance will reply with its peer metadata.
     * @param peerId
     * @returns
     */
    autoScale(peerId: any): Promise<unknown>;
    /**
     * add remote peer into queue
     * @param peerId
     */
    pushAutoScale(peerId: any): void;
    /**
     * auto scale mode: check all nodes has added into cluster and max wait 20 seconds.
     * Ingore checking: 1. not autoscale mode; 2. the node which has in cluster; 3. no peer list; 4. one node in peerlist and which is itself
     */
    waitCluster(): Promise<void>;
    /**
     * Used in case of auto-scaling with bootstrap method
     * @returns The array of multiaddrs
     */
    getClusterNodeAddrs(): Promise<string[]>;
    /**
     * Process to ping a peer
     * @param peerInfo
     * @returns
     */
    ping(peerInfo: IPeerMeta): Promise<any>;
    /**
     * Process to ping a peer
     * @param peerInfo
     * @returns
     */
    checkStatus(peerInfo: IPeerMeta, isUnknownPeer: boolean | undefined, taskId: string): Promise<any>;
    /**
     * Process to pull chains and data from a peer
     * @param peerId
     * @returns
     */
    pull(peerId: string, entities?: Array<string>): Promise<any>;
    waitForPull(): Promise<any>;
    /**
     * Process to force pull all the chains and data from a peer
     * @param peerId
     * @returns
     */
    pullAll(peerId: string): Promise<{
        status: boolean;
        message: string;
    } | undefined>;
    /**
     * Process to check if FileSync is done
     * @param peerId
     * @returns
     */
    checkFileSync4PullAll(peerId: string): Promise<{
        status: boolean;
        message: string;
    } | undefined>;
    /**
     * Process to checkin to private network
     */
    checkin(isMustDo?: boolean, tskId?: string): Promise<any>;
    private createCheckinTask;
    /**
     * Books the automatic checkin process
     */
    bookAutoCheckin(interval?: number): void;
    cancelAutoCheckin(): void;
    /**
     * check whether auto resolve confict or not
     * @param metaName
     * @param correctPeerid
     * @returns
     */
    autoResolveConflict(conflictEntity: string, parameters?: object): Promise<boolean>;
    getPreferPeerId(parasObj?: any, ownerId?: string): string;
    /**
     * Is local node inside a cluster or not
     * @returns
     */
    isInCluster(): boolean;
    /**
     * Lonely island means, all the peers of the cluster are disconnected.
     * @returns
     */
    isLonelyIsland(): Promise<boolean>;
    /**
     *
     * @returns Summary of all chains size
     */
    getChainsSize(): number;
    /**
     * Start local node and checkin to private network
     */
    start(): Promise<void>;
    /**
     * Sends message to a specific peer and channel
     * @param peer
     * @param channel
     * @param msg
     * @returns
     */
    sendMsg(peer: IPeerMeta, channel: string, msg: string, isNotZipped?: boolean): Promise<void>;
    /**
     * BZ-15355, sync file for cluster
     * create read scream and sent file content
     */
    runFileSyncTask(task: FileSyncTask): Promise<any>;
    get worker(): DbWorker;
    /**
     * Sets addressbook and peer state for all the peers in meta_peers
     */
    /**
     * Dial all the peers
     */
    dialAll(): Promise<void>;
    refreshPeers(): Promise<void>;
    deletePeer(peer: NodeMetadata): Promise<void>;
}
export { PrivateNet, NodeStateHandler };
