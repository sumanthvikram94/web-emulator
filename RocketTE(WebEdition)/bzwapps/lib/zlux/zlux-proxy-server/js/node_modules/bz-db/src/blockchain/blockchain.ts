

import { Block, BlockData } from './block.js'
import { BlockError, OutOfBoundsError } from './error.js'
import { CONFIG } from '../constants/config.js'
import { Transaction } from './transaction.js';
import { Logger, uid, loggers } from '../services/index.js'
import { ACTION } from '../constants/actions.js'
import { EventEmitter } from 'events';

const txnLogger = loggers.txn

/** @private */
let prvProps = new WeakMap();

interface BlockChainData {
    subject: string,
    chain?: any[],
    size?: number,
    txnSize?:number,
    difficulty?: number,
    rootIndex?: number
}

interface BlockChainStat {
  subject: string,
  size: number,
  keptSize: number,
  txnSize: number,
  lastIndex: number,
  lastTimeStamp: number,
  lastHash: string,
  firstIndex: number,
  firstTimeStamp: number,
  firstHash: string
}

/**
 * @class BlockChain
 * @description Chain of cryptographic blocks.
 */
class BlockChain {

  _pendingBlocks: Map<number, Block>
  // _lockedIndexes: Set<number>
  _latestApprovedIdx: number // the index that I have approved for others
  _txn_redundancy_factor: number // To reduce furture block issue of cluster, add latest blocks data into a txn, so that the blocks can be appended when future block happens

  _event: EventEmitter
  // _addBlockProcesses: Promise<any>[]

  constructor(data: BlockChainData, txnRedundancyFactor = 0) {
    prvProps.set(this, data)
    // in case creating empty chain
    if (!data.chain){
        data.chain = []
        this.createGenesisBlock()
        data.size = 1
        data.txnSize = 0
        data.difficulty = CONFIG.DIFFICULTY
        data.rootIndex = 0
    }
    this._pendingBlocks = new Map()
    this._latestApprovedIdx = 0
    this._txn_redundancy_factor = txnRedundancyFactor
    // this._lockedIndexes = new Set()
    this._event = new EventEmitter()
    // this._addBlockProcesses = []
  }

  get txn_redundancy_factor(){
    return this._txn_redundancy_factor
  }

  set txn_redundancy_factor(length: number){
    this._txn_redundancy_factor = length
  }

  toJSONNoBlock(){
    const chainData = Object.assign({}, prvProps.get(this)) 
    chainData.chain = []
    return chainData
  }

  toJSON(){
    return prvProps.get(this)
  }

  /**
   * @description Create the first (genesis) block.
   * @param {string} [beneficiaryAddr] Address of the beneficiary
   * @return {Block} Genesis block
   * @memberof Blockchain
   */
  createGenesisBlock() {
    const block = new Block({index: 0, prevHash: CONFIG.ROOT_BLOCK_HASH, transactions: [], isGenesis: true});
    prvProps.get(this).chain.push(block.toJSON());
    return block
  }

  generateBlockCandidate(txns: Transaction[], createdBy: string, batchts?:number, competeFactor?:number){
    const chain = this.chain
    const tailBlock = chain[chain.length - 1]
    const idx = this.size
    const b = new Block({
      index: idx, 
      timestamp: batchts? batchts: Date.now(),
      prevHash: tailBlock.hash, 
      transactions: txns, 
      blockUID: uid.generate(), 
      competeFactor: competeFactor? competeFactor: Math.round(Math.random() * CONFIG.BLOCK_COMPETE_FACTOR_LENGTH),
      createdBy: createdBy
    })
    this._pendingBlocks.set(b.blockUID, b)
    return b
  }

  /**
   * @description Get the blockchain.
   * @return {Block[]} Chain
   * @memberof Blockchain
   */
  get chain(): Block[]{
    return prvProps.get(this).chain;
  }

  set chain(blocks: Block[]){
    prvProps.get(this).chain = blocks
  }

  /**
   * @description Get the hash difficulty.
   * @return {number} Difficulty
   * @memberof Blockchain
   */
  get difficulty() {
    return prvProps.get(this).difficulty;
  }

  get subject(){
    return prvProps.get(this).subject
  }

  /**
   * @description The accumulated count of blockes that have ever been added to the chain
   * @return {number} Size
   * @memberof Blockchain
   */
  get size() {
    return prvProps.get(this).size
  }

  set size(s: number){
    prvProps.get(this).size = s
  }

  /**
   * @description The accumulated count of transactions (records in transactions) that has ever been executed
   * @return {number} Size
   * @memberof Blockchain
   */
  get txnSize() {
    return prvProps.get(this).txnSize
  }

  /**
   * @description Get a specific block.
   * @param {number} index Index
   * @return {Block} Block
   * @memberof Blockchain
   * @throws {TypeError} Index needs to be an integer
   * @throws {OutOfBoundsError} Index out of bounds
   */
  getBlock(index:any): Block {
    if (!Number.isInteger(index)) throw new TypeError(`index (${index}) needs to be an integer`);
    const bc = prvProps.get(this)
    const chain = bc.chain
    const sz = bc.size
    const rootIdx = bc.rootIndex
    // let idx = index > 0? sz + index : index
    if (Math.abs(index) > sz) throw new OutOfBoundsError(`index (${index}) out of bounds`)
    /* eslint-disable security/detect-object-injection */
    else return (index < 0) ? chain[sz + index - rootIdx] : chain[Math.max(index - rootIdx, 0)]
    /* eslint-enable security/detect-object-injection */
  }

  replaceBlock(block: Block) {
    const index = block.index
    const bc = prvProps.get(this)
    const chain = bc.chain
    if (index > bc.size) {
      throw new OutOfBoundsError(`index (${index}) out of bounds`)
    }
    
    const arrIdx = index - bc.rootIndex
    if (arrIdx <= 0) {
      // ignore
      // <= 0 means, it's trying to replace a historical block which is already removed.
    } else { // Replace the block at the same position. 
      // bc.chain = [...chain.slice(0,arrIdx), block.toJSON(), ...chain.slice(arrIdx + 1)]
      chain[arrIdx] = block.toJSON()
    }
  }

  subChain(start: number, end?: number): any[]{
    const bc = prvProps.get(this)
    const chain: any[] = bc.chain
    const adjustedStart = chain.length - (bc.size - start)
    const offsetEnd = end !== undefined? chain.length - (bc.size - end): undefined
    return chain.slice(adjustedStart, offsetEnd)
  }

  /**
   * @description Get a block with a specific hash.
   * @param {string} hash Hash
   * @return {Block} Block
   * @memberof Blockchain
   */
  getBlockByHash(hash:any) {
    const bc = prvProps.get(this)
    let blocks = bc.chain.filter((block:any) => block.hash === hash);
    //It's not possible to get duplicate blocks so the check was removed
    return blocks[0];
  }

  /**
   * @description Validates the chain.
   * @return {boolean} Validity
   * @memberof Blockchain
   */
  isValid() {
    const bc = prvProps.get(this)
    let chain = bc.chain;
    for (let i = 1; i < chain.length; ++i) {
      /* eslint-disable security/detect-object-injection */
      const currentBlock = chain[i],
        prevBlock = chain[i - 1],
        pad = '0'.repeat(bc.difficulty);
      const incorrectPadding = (!currentBlock.hash.startsWith(pad) || !prevBlock.hash.startsWith(pad)),
        incorrectHash = currentBlock.hash !== currentBlock.calculateHash(),
        incorrectFollow = currentBlock.prevHash !== prevBlock.hash;
      /* istanbul ignore next */
      if (incorrectPadding || incorrectHash || incorrectFollow) return false; //It should be impossible for this branch to return
    }
    return true;
  }

  /**
   * @description Add blocks.
   * @param {Block[]} blocks blocks
   * @param {Boolean} keepPendingBlockWithSameIdx: whether to keep the pending block with same index as the incoming block.
   * @memberof Blockchain
   */
  addBlocks(blocks: Block[], keepPendingBlockWithSameIdx = false, txnId?: string) {
    const addedBlocks: Block[] = []
    try{
      if (!blocks || blocks.length === 0){
        txnLogger.logWarn(`Add blocks list is empty`, txnId)
        return addedBlocks
      }
      if (blocks[0].index > this.size){
        txnLogger.logWarn(`Adding futuer blocks, ingoring them.`, txnId)
        return addedBlocks
      }
      for (const block of blocks){
        const addedBlock = this.addBlock(block, keepPendingBlockWithSameIdx, txnId, true)
        if (addedBlock) {
          addedBlocks.push(addedBlock)
        }
      }
      this._event.emit('touch')
      return addedBlocks
    } catch (e) {
      Logger.logSevere('Error while adding blocks')
      Logger.logError(e)
      return addedBlocks
    }
  }

  /**
   * @description Add a block.
   * @param {Block} block block
   * @param {Boolean} keepPendingBlockWithSameIdx: whether to keep the pending block with same index as the incoming block.
   * @memberof Blockchain
   */
  addBlock(block: Block, keepPendingBlockWithSameIdx = false, txnId?: string, doWithoutTouch?: boolean): Block | undefined{
    const blockJson = block.toJSON()
    if (block.index < this.size){
      const existingBlock = this.getBlock(block.index)
      if (existingBlock) {
          if (!existingBlock.branches) {
              existingBlock.branches = []
          }
          existingBlock.branches.push(blockJson) // JSTE-18002, keep all blocks at same index on branches. 
          txnLogger.logWarn(`Adding branch to chain ${this.subject} at position ${block.index}. Branches after adding: ${existingBlock.branches.length}`, txnId)
          txnLogger.logWarn(`Chain data: ${JSON.stringify(this.chain)}; New block: ${JSON.stringify(blockJson)}`, txnId)
          return new Block(existingBlock)
      }
    } else if (block.index > this.size){
      txnLogger.logWarn(`Adding furture block to chain. Ignore it.`, txnId)
      return undefined
    }
    // Still need the validation?? It should have already passed claimBlock, and received by TXN_GO.
    if (!block.isValid()) throw new BlockError(`Invalid block: ${block.toJSON()}`);
    const prevBlock = this.getBlock(block.index - 1)
    if (block.prevHash !== prevBlock.hash ){
      if (prevBlock.branches && prevBlock.branches.length > 0) {  // Check branches of previous block
        const newBranches = [prevBlock.toJSON()]
        let newMainBranch: Block|undefined
        for (let blk of prevBlock.branches) {
          if (block.prevHash === blk.hash) {
            newMainBranch = new Block(blk)
          } else {
            newBranches.push(blk)
          }
        }
        if (newMainBranch) { // JSTE-18002, When next position block comes, check the previous block it links to, change the linked block as main block.
          newMainBranch.branches = newBranches
          this.replaceBlock(newMainBranch)
        } else { // Previous block has branches, and none of the branch can be linked.
          throw new BlockError(`Invalid hash of block: ${block.toJSON()}`);
        }
      } else { // Previous block has no branch, and link is invalid
        throw new BlockError(`Invalid hash of block: ${block.toJSON()}`);
      }
    }

    const data = prvProps.get(this)
    Logger.logDebug('Current chain size: ' + data.size)
    Logger.logDebug('Adding new block: ' + blockJson)
    data.chain.push(block.toJSON());
    data.size ++
    if (block.transactions && block.transactions.length > 0){ // accumulates the count of DB records in all TXNs
      for (const txn of block.transactions){
        if (txn.type === ACTION.DB_BULKLOAD){
          data.txnSize += txn.data.length
        } else {
          data.txnSize ++
        }
      }
    }
    if (!keepPendingBlockWithSameIdx){
      this.clearPendingBlock(block)
    }
    if (!doWithoutTouch) {
      this._event.emit('touch')
    }
    return block
  }

  onTouch(callback: Function){
    this._event.once('touch', () => {
      callback()
    })
  }

  /**
   * Wait for the touch event triggered or until the waitms
   * @param waitms 
   * @returns 
   */
  touched(waitms = 0, txnId?: string):Promise<any>{
    return new Promise((resolve) => {
      let resolved = false
      let timeout:any
      const callback = () => {
        txnLogger.logWarn('block chain touched - ' + this.subject, txnId)
        if (!resolved){
          resolve(true)
        }
        if (timeout){
          clearTimeout(timeout)
        }
      }
      this._event.once('touch', callback)
      if (waitms > 0){
        timeout = setTimeout(() => {
          txnLogger.logWarn('waiting for touch event timed out - ' + this.subject, txnId)
          this._event.removeListener('touch', callback)
          resolve(true)
          resolved = true
        }, waitms)
      }
    })
  }

  // Clears pending block once it's resolved or rejected
  clearPendingBlock(block: Block){
    if (this._pendingBlocks.has(block.blockUID)){
      this._pendingBlocks.delete(block.blockUID)
    }
  }

  // Clears pending block once it's resolved or rejected
  clearPendingBlocks(blocks: Block[]){
    for (const block of blocks){
      if (this._pendingBlocks.has(block.blockUID)){
        this._pendingBlocks.delete(block.blockUID)
      }
    }
  }

  // lockIndex(idx:number){
  //   this._lockedIndexes.add(idx)
  // }

  /**
   * clear the old blocks, but keep the chain[0] as the genesis block unchanged
   * @returns 
   */
  clearHistory(){
    const data = prvProps.get(this)
    const chain = data.chain
    const overflowIdx = chain.length - CONFIG.CLEAN_CHAIN_KEEP_LENGTH
    const mustCleanIdx = chain.length - CONFIG.CLEAN_CHAIN_KEEP_LENGTH_MAX
    if (overflowIdx <= 0) return // Keep at least 100 blocks in chain
    const timeTolerance = Date.now() - CONFIG.CLEAN_BLOCK_KEEP_TIME
    let clearIndex = 0
    for (let i = 1; i <= overflowIdx; i ++){
      const block:Block = chain[i]
      if (block.timestamp < timeTolerance || i < mustCleanIdx){
        clearIndex = i
      }else{
        break
      }
    }
    if (clearIndex > 0){
      chain.splice(1, clearIndex)
      chain[1].prevHash = chain[0].hash
      data.rootIndex += clearIndex
      Logger.logInfo(`Cleared ${clearIndex} historical blocks from ${data.subject} metadata`)
    }
    return clearIndex > 0
  }

  claimBlock(block: Block, peerId: string, txnId?: string){
    const valid = this.validateBlock(block, false, peerId, txnId)
    if (valid.isValid && block.index > this._latestApprovedIdx) {
      this._latestApprovedIdx = block.index
    }
    return valid
  }

  setApproved(block:Block){
    block.isApproved = true
    this._latestApprovedIdx = Math.max(this._latestApprovedIdx, block.index)
  }

  updateBlockIdx(block: Block, includesHash = true){
    // Calculate the new index. 
    // In case local size is 5, and I have approved index 5 for other peer, then my block should be index 6.
    const idxOffset = this.size - block.index
    // if (idxOffset !== 0) { // in case high concurrency, the block.index could be bigger than this.size.
      // const newMap = new Map<number, Block>()
      for (const pb of Array.from(this._pendingBlocks.values()) ){ // All pending blocks need update accordingly
        // const currentIdx = pb.index
        pb.index += idxOffset // change block index to new index
        // this._pendingBlocks.delete(currentIdx)
        // newMap.set(pb., pb)
      }
      // this._pendingBlocks = newMap
      const lastBlock = this.getBlock(-1)
      if (!lastBlock){
        Logger.logSevere('Invalid chain data: ' + JSON.stringify(this.toJSON()))
        throw Error('Invalid chain data! BlockChain:' + JSON.stringify(this.toJSONNoBlock()) + ', chain array length:' + this.chain.length)
      }
      if (includesHash) block.prevHash = this.getBlock(-1).hash
      block.isConflictWithApproved = false
      block.isApproved = false
      if (this.txn_redundancy_factor > 0){
        block.setRedundentBlocks(this.subChain(this.size - this.txn_redundancy_factor))
      }
    // }
  }

  isNoConflict(peerBCS: BlockChainStat){
    const myBCS = this.statistics
    if (peerBCS.subject !== myBCS.subject){
      throw Error('Can not compare different subjects')
    }
    if (myBCS.size === peerBCS.size){
      return myBCS.lastIndex === peerBCS.lastIndex && myBCS.lastHash === peerBCS.lastHash
    } else if (myBCS.size < peerBCS.size){
      return true // In case local is shorter, it can't be compared.
    } else {
      const checkBlock = this.getBlock(peerBCS.lastIndex)
      if (checkBlock.index === 0){ // The peer chain is too short, its last block is already cleared
        return true
      }
      return checkBlock.hash === peerBCS.lastHash
    }
  }

  /**
   * Log invalid block as warning.
   * @param block 
   * @param validateResult 
   */
  private logInvalidBlock(block: Block, validateResult:any = {}, txnId?: string){
    if (validateResult.isValid === false){
      txnLogger.logDebug(`Block rejected: ${JSON.stringify(validateResult)}, block data: ${JSON.stringify(block.toJSON())}`, txnId)
    }
  }

  /**
   * Validate block index
   * @param block 
   * @param validateResult? 
   * @returns {isValidIndex: boolean, blockIdx: number, chainSize: number, isValid: boolean}
   */
  private validateBlockIdx(block: Block, validateResult:any = {}, txnId?: string){
    validateResult.isValid = validateResult.isValidIndex = block.index >= this.size
    validateResult.blockIdx = block.index
    validateResult.chainSize = this.size
    txnLogger.logDebug('Index validation: ' + validateResult.isValidIndex, txnId)
    this.logInvalidBlock(block, validateResult, txnId)
    return validateResult
  }

  /**
   * 
   * @param block 
   * @param validateResult 
   * @returns {isCorrectLink: boolean, isFutureBlock: boolean, isValid: boolean}
   */
  private validateChainLink(block: Block, validateResult:any = {}, txnId?: string){
    let isCorrectLink = false
    let isFutureBlock = false
    const tailBlock = this.getBlock(-1);
    if (!tailBlock){
      txnLogger.logSevere('Failed to get tail block. Subject: ' + this.subject + ', chain: ' + JSON.stringify(this.chain) + ', new block: ' + JSON.stringify(block), txnId)
    }
    if (block.index === (tailBlock.index + 1)){
      isCorrectLink = block.prevHash === tailBlock.hash;
      txnLogger.logDebug('Prevhash validation: ' + isCorrectLink, txnId)
      if (!isCorrectLink){
        if (tailBlock.branches && tailBlock.branches.length > 0) { // Validate the link to branches.
          for (let branchBlock of tailBlock.branches) {
            if (block.prevHash === branchBlock.hash) { // Return valid in case the new block can link to any branch
              txnLogger.logSevere('Block can link to branch. Tail block: ' + JSON.stringify(tailBlock.toJSON()) + ', new block: ' + JSON.stringify(block), txnId)
              isCorrectLink = true
              break
            }
          }
        }
        txnLogger.logDebug('Invalid chain link. Tail block (index, hash): (' + tailBlock.index + ', ' + tailBlock.hash + '), new block (index, prevHash): (' + block.index + ', ' + block.prevHash + ')', txnId)
      }
    } else if (block.index > (tailBlock.index + 1)){
      isFutureBlock = true
    } else {
      // keep default value
    }
    validateResult.isCorrectLink = isCorrectLink
    validateResult.isFutureBlock = isFutureBlock
    validateResult.isValid = validateResult.isCorrectLink || validateResult.isFutureBlock  // Treat the block as valid if it's a future block.
    this.logInvalidBlock(block, validateResult, txnId)
    return validateResult
  }

  /**
   * 
   * @param block 
   * @param validateResult 
   * @returns {isBlockValid: boolean, isValid: boolean}
   */
  private blockSelfValidate(block: Block, validateResult:any = {}, txnId?:string){
    validateResult.isValid = validateResult.isBlockValid = block.isValid()
    txnLogger.logDebug('Block self validation: ' + validateResult.isBlockValid, txnId)
    this.logInvalidBlock(block, validateResult, txnId)
    return validateResult
  }

  /**
   * Validate block with local pending blocks
   * @param block 
   * @param validateResult 
   * @param isApproved 
   * @returns 
   */
  private validateWithPending(block: Block, validateResult:any = {}, isApproved = false, peerId?: string, txnId?: string){
    const pbarr = Array.from(this._pendingBlocks.values())
    let pb:any = undefined
    for (let pbele of pbarr){ // JERRY: this._pendingBlocks.get() directly?
      if (pbele.index === block.index){
        pb = pbele
        break
      }
    }
    if (pb !== undefined){
      if (isApproved){ // It's validating a block with TXN_GO. It should always be valid.
        validateResult.isValid = true
        validateResult.isConflictWithPendingBlock = false
        pb.isConflictWithApproved = true
        pb.isApproved = false
      } else if (pb.isApproved) { // The local pending block is already approved. Reject it.
        validateResult.isValid = false
        validateResult.isConflictWithPendingBlock = true
        txnLogger.logWarn('Block reject reason - Conflict with approved local block', txnId)
      } else if (pb.isConflictWithApproved) { // JSTE-18002, review block approval logics. The local pending block is already rejected. So, there must be another block already approved. Reject it.
        validateResult.isValid = false
        validateResult.isConflictWithPendingBlock = true
      } else if (pb.timestamp < block.timestamp) { // The local pending block is earlier. Reject it.
        validateResult.isValid = false
        validateResult.isConflictWithPendingBlock = true
        txnLogger.logWarn('Rejected block' + (peerId? ' From: ' + peerId : '') + '. Subject:' + this.subject + ' Local pending block: index: ' + pb.index + ', ts: ' + pb.timestamp + '. rejected block index: ' + block.index + ', ts: ' + block.timestamp, txnId)
      } else if (pb.timestamp === block.timestamp && pb.competeFactor && block.competeFactor && pb.competeFactor > block.competeFactor) { // when ts is same, check compete factor
        validateResult.isValid = false
        validateResult.isConflictWithPendingBlock = true
        txnLogger.logWarn('Rejected block' + (peerId? ' From: ' + peerId : '') + '. Subject:' + this.subject + ' Local pending block: index: ' + pb.index + ', competeFactor: ' + pb.competeFactor + '. rejected block index: ' + block.index + ', competeFactor: ' + block.competeFactor, txnId)
      } else { // The block is earlier than local pending block. Approve the block, and reject local pending block.
        validateResult.isValid = true
        validateResult.isConflictWithPendingBlock = false
        pb.isConflictWithApproved = true
        pb.isApproved = false
      }
      this.logInvalidBlock(block, validateResult, txnId)
    }
    // else { // pending blocks has earlier block than the coming one.
    //   if (this._pendingBlocks.size > 0){
    //     const firstPB = Array.from(this._pendingBlocks.values())[0]
    //     if (firstPB.timestamp <= block.timestamp){
    //       validateResult.isValid = false
    //       validateResult.isConflictWithPendingBlock = true
    //     }
    //   }
    // }
    return validateResult

  }

  /**
   * Validates the given block with the chain.
   * @param block 
   * @param isApproved 
   * @returns {isValid: boolean, isBlockValid: boolean, }
   */
  validateBlock(block: Block, isApproved = false, peerId?: string, txnId?: string){
    txnLogger.logDebug('Validating block: ' + JSON.stringify(block.toJSON()), txnId)
    const validateResult:any = {isValid: true}
    if (!this.blockSelfValidate(block, validateResult, txnId).isValid || !this.validateBlockIdx(block, validateResult, txnId).isValid 
        || !this.validateChainLink(block, validateResult, txnId).isValid || !this.validateWithPending(block, validateResult, isApproved, peerId, txnId).isValid){
      if (isApproved){
        // This should never happen except for validateWithPending which is already handled.
        txnLogger.logSevere('Approved block is Invalid. ' + JSON.stringify(validateResult), txnId)
      }
      return validateResult
    }
    txnLogger.logDebug('Block validation succeed: ' + JSON.stringify(validateResult), txnId)
    return validateResult
  }

  // Deprecated. Use this.validateBlock() instead.
  // isValidBlock(block: Block){
  //   // TBD, log more details when validation fails
  //   Logger.logDebug('Validating block: ' + block.toJSON())

  //   const isValidIndex = block.index >= this.size
  //   Logger.logDebug('Index validation: ' + isValidIndex)
  //   if (!isValidIndex){
  //     Logger.logWarn(`Block validation: invalid index. Chain size: ${this.size}, block data: ${JSON.stringify(block.toJSON())}`)
  //     return false
  //   }

  //   let isCorrectLink = true
  //   const tailBlock = this.getBlock(-1);
  //   if (block.index === (tailBlock.index + 1)){
  //     isCorrectLink = block.prevHash === tailBlock.hash;
  //     Logger.logDebug('Prevhash validation: ' + isCorrectLink)
  //   }
  //   const isBlockValid = block.isValid()
  //   Logger.logDebug('Block self validation: ' + isBlockValid)
  //   const isValidinChain = isBlockValid && isCorrectLink
  //   const pb = this._pendingBlocks.get(block.index)
  //   let isConflictWithPendingBlock = pb !== undefined && pb.timestamp < block.timestamp
  //   Logger.logDebug('Pending block conflict validation: ' + !isConflictWithPendingBlock)
  //   return isValidinChain && !isConflictWithPendingBlock
  // }

  get statistics(): BlockChainStat {
    const tailBlock = this.getBlock(-1);
    const headBlock = this.getBlock(0);
    if (!tailBlock || !headBlock){
      Logger.logSevere('Invalid chain data: ' + JSON.stringify(this.toJSON()))
      throw Error('Invalid chain data! BlockChain:' + JSON.stringify(this.toJSONNoBlock()) + ', chain array length:' + this.chain.length)
    }
    return {
      subject: this.subject,
      size: this.size,
      keptSize: prvProps.get(this).chain.length - 1, 
      txnSize: this.txnSize,
      lastIndex: tailBlock.index,
      lastTimeStamp: tailBlock.timestamp,
      lastHash: tailBlock.hash,
      firstIndex: headBlock.index,
      firstTimeStamp: headBlock.timestamp,
      firstHash: headBlock.hash
    }
  }

  isExistingBlock(block: Block): boolean {
    // TBD, need validate the existing block???
    // JERRY: should include the approved blocks. Avoid duplicated block index to be added.
    return block.index < this.size
  }

  isFurtureBlock(block: Block): boolean {
    const isFuture = block.index > this.size
    return isFuture
  }

  selfValidate(){
    Logger.logDebug('Doing fully validation for chain:' + this.subject)
    if (this.chain && this.chain.length > 0){
      const chainData = prvProps.get(this)
      const rootIdx = chainData.rootIndex? chainData.rootIndex: 0
      const cleanBlocks:BlockData[] = []
      let prevIdx = 0
      let prevHash = CONFIG.ROOT_BLOCK_HASH
      for (let i = 0; i < this.chain.length; i ++){
        const block = this.chain[i]
        if (i === 0){ // the 0 block
          prevIdx = block.index
          prevHash = block.hash
          cleanBlocks.push(block)
        } else if (i === 1){ // the one after index: 0. this can have different index/hash in case the chain history has been cleared. 
          prevIdx = block.index
          prevHash = block.hash
          cleanBlocks.push(block)
        } else if (block.index === ++ prevIdx && block.prevHash === prevHash){
          prevHash = block.hash
          cleanBlocks.push(block)
        } else {
          Logger.logSevere('Invalid block chain data spotted. Block: ' + JSON.stringify(block))
          Logger.logSevere('Previous block: ' + JSON.stringify(this.chain[i - 1]))
          Logger.logSevere('Chain data: ' + JSON.stringify(this.toJSON()))
          Logger.logSevere('Cutting the chain since last correct block!')
          this.size = i + rootIdx
          this.chain = this.chain.slice(0, i)
          return {
            status: false,
            cleanBlocks
          }
        }
      }
      if (this.size !== this.chain.length + rootIdx){
        Logger.logSevere(`Chain size mismatch! Subject: ${this.subject}, chain size: ${this.size}, blocks count: ${this.chain.length}. Resetted chain size.`)
        this.size = this.chain.length + rootIdx
        return {
          status: false
        }
      }
    }
    return {status: true}
  }

}

export {
    BlockChain, BlockChainData, BlockChainStat
}