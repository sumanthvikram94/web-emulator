import path from 'path';
import { WriteStream } from 'fs-extra';
import fse from 'fs-extra'

import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { CONFIG } from '../constants/config.js'

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const DEFAULT_LOG_FILE = path.resolve(__dirname, '../log/bzdb.log');

enum LogLevel{
    SILENT = -1,
    SEVERE = 0,
    WARN,
    INFO,
    DEBUG
}

interface IInternalLogger{
    logInfo(msg: string): void
    logWarn(msg: string): void
    logSevere(msg: string): void
    logError(e: Error): void
    logDebug(msg: string): void
    setWriter(config?: ILoggerConfig): void
    setProcessName(name: string): void
}

interface ITimeTracer{
    trace(msg: string): void
}

interface ILogger {
    setLogLevel(level: LogLevel): void
    logDebug(msg: string, subTopic?: string): void
    logInfo(msg: string, subTopic?: string): void
    logWarn(msg: string, subTopic?: string): void
    logSevere(msg: string, subTopic?: string): void
    logError(e: Error, subTopic?: string): void
}


interface ILevelLogger{
    logInfo(msg: string): void;
    logWarn(msg: string): void;
    logSevere(msg: string): void;
    logError(e: Error): void;
    logDebug(msg: string): void;
}

interface LogWriter{
    log(msg: string): void;
    warn(msg: string): void;
}

/**
 * WriteStream.writableLength is available in node.js, but unavailable in typescript.
 */
interface WriteStreamExt extends WriteStream {
    writableLength: number;
}

/**
 * Writes log into a file
 */
class StreamLogWriter implements LogWriter {
    private writeStream: WriteStreamExt;

    constructor(){
        // this.writeStream = fs.createWriteStream(fileName, {flags: 'a', encoding: 'utf8', mode: 0o644});
    }

    /**
     * Change the file to write log.
     * @param fileName 
     */
    getNewWriter(fileName: string){
        let logWriteStreamOld = this.writeStream;
        this.writeStream = fse.createWriteStream(fileName, {flags: 'a', encoding: 'utf8', mode: 0o644});
        if (logWriteStreamOld) this.streamCloseSafe(logWriteStreamOld);
        return this;
    }

    /**
     * A stream should be closed only when all the data in it is written into file
     * @param fileSteam 
     * @param callback 
     */
    streamCloseSafe(fileSteam: WriteStreamExt, callback?: Function){
        const endfileStream = () => {
            setTimeout(() => {
                if (fileSteam.writableLength > 0) {
                    endfileStream();
                } else {
                    fileSteam.end();
                    fileSteam.destroy();
                    if (callback) callback();
                }
            }, 500);
        }
        endfileStream();
    }

    log(msg: string): void{
        this.writeStream.write(msg + '\n');
    }
    warn(msg: string): void{
        this.writeStream.write(msg + '\n');
    }
}

interface ILoggerConfig{
    type: string;
    fileName?: string;
    logLevel?:LogLevel;
}

class InternalLogger implements IInternalLogger{

    // private logLevel: LogLevel;
    protected writer: LogWriter;
    private streamWriter: StreamLogWriter;
    private processName: string;

    constructor(config?:ILoggerConfig){
        // this.logLevel = (config && config.logLevel)? config.logLevel: LogLevel.INFO;
        // if (this.logLevel > 2) this.logLevel = LogLevel.DEBUG;
        this.streamWriter = new StreamLogWriter();
        this.setWriter(config);
    }

    /**
     * Process name will be written into log, so multiple processes can be distincted
     * @param name 
     */
    setProcessName(name: string) {
        this.processName = name;
    }

    /**
     * Creates the dir and the parent dirs if not exist.
     * @param {string} dir
     */
    createDirs(dir: string) {
        const tmpPath=path.dirname(dir); 
        if (!fse.existsSync(path.dirname(tmpPath))) {
            this.createDirs(path.dirname(tmpPath));
        }
        if (!fse.existsSync(tmpPath)) {
             fse.mkdirSync(tmpPath);
        }
     }

    /**
     * Set writing log to file or console
     * @param config 
     */
    setWriter(config?: ILoggerConfig){
        if (config && config.type === 'file'){
            const fileName = path.resolve(config.fileName? config.fileName: DEFAULT_LOG_FILE);
            this.createDirs(fileName);
            this.writer = this.streamWriter.getNewWriter(fileName);
        }else{
            this.writer = console;
        }
    }

    // setLogLevel(logLevel: LogLevel): void{
    //     this.logLevel = logLevel;
    //     if (this.logLevel > 2) this.logLevel = LogLevel.DEBUG;
    //     if (this.logLevel < -1) this.logLevel = LogLevel.SILENT;
    // }

    /**
     * Prepend data to each line of log
     * @param level 
     */
    private _getLogPrefix(level: string): string {
        const now = new Date();
        now.setTime(now.getTime() - now.getTimezoneOffset()*60000);
        let nowStr = now.toISOString();
        nowStr = nowStr.substring(0,nowStr.length-1).replace('T',' ');
        const processName = this.processName? `${this.processName}`:'db';
        // return `[BZDB ${level} at ${nowStr}${processName}] - `;
        return `[${nowStr} ${processName} ${level}] - `;
    }
    logInfo(msg: string): void {
        this.writer.log(this._getLogPrefix('INFO') + msg);
    }
    logWarn(msg: string): void {
        this.writer.warn(this._getLogPrefix('WARN') + msg);
    }
    logSevere(msg: string): void {
        this.writer.warn(this._getLogPrefix('SEVERE') + msg);
    }
    logError(e: Error): void {
        this.writer.warn(this._getLogPrefix('SEVERE') + (e.stack? e.stack: e.message));
        console.error(e)
    }
    logDebug(msg: string): void {
        this.writer.log(this._getLogPrefix('DEBUG') + msg);
    }
}


let _logger: IInternalLogger = new InternalLogger()

class LoggerConfigurer {
    static setProcessName (name: string){
        _logger.setProcessName(name)
    }
    static setWriter (config?: ILoggerConfig){
        _logger.setWriter(config)
    }
}

/**
 * Writes no log
 */
class SilentLogger implements ILevelLogger {

    constructor(){
    }
    logError(_e: Error, _logLevel: LogLevel = LogLevel.INFO): void {
    }
    logSevere(_msg: string, _logLevel: LogLevel = LogLevel.INFO): void {
    }
    logWarn(_msg: string, _logLevel: LogLevel = LogLevel.INFO): void {
    }
    logInfo(_msg: string, _logLevel: LogLevel = LogLevel.INFO): void {
    }
    logDebug(_msg: string, _logLevel: LogLevel = LogLevel.INFO): void {
    }
}

/**
 * Writes severe logs
 */
class SevereLogger extends SilentLogger {

    constructor() {
        super()
    }
    logSevere(msg: string, logLevel: LogLevel = LogLevel.INFO): void {
        if (logLevel >= LogLevel.SEVERE){
            _logger.logSevere(msg);
        }
    }
    logError(e: Error, logLevel: LogLevel = LogLevel.INFO): void {
        if (logLevel >= LogLevel.SEVERE){
            _logger.logError(e);
        }
    }
}

/**
 * Writes severe and warning logs
 */
class WarnLogger extends SevereLogger {
    constructor() {
        super()
    }
    logWarn(msg: string, logLevel: LogLevel = LogLevel.INFO): void {
        if (logLevel >= LogLevel.WARN){
            _logger.logWarn(msg);
        }
    }
}

/**
 * Writes severe, warning and info logs
 */
class InfoLogger extends WarnLogger {
    constructor() {
        super()
    }
    logInfo(msg: string, logLevel: LogLevel = LogLevel.INFO): void {
        if (logLevel >= LogLevel.INFO){
            _logger.logInfo(msg);
        }
    }
}

/**
 * Writes severe, warning and info logs
 */
class DebugLogger extends InfoLogger {
    constructor() {
        super()
    }
    logDebug(msg: string, logLevel: LogLevel = LogLevel.INFO): void {
        if (logLevel >= LogLevel.DEBUG){
            _logger.logDebug(msg);
        }
    }
}

const silentLogger = new SilentLogger()
const severeLogger = new SevereLogger()
const warnLogger = new WarnLogger()
const infoLogger = new InfoLogger()
const debugLogger = new DebugLogger()

class DefaultLogger implements ILogger{
    protected _level: LogLevel
    protected _logger: ILevelLogger

    constructor(level: LogLevel = LogLevel.INFO) {
        this._level = level
        this.setLogLevel(level)
    }
    
    public setLogLevel(level: LogLevel) {
        switch(level) {
            case LogLevel.SILENT: 
                this._logger = silentLogger
                break
            case LogLevel.SEVERE:
                this._logger = severeLogger
                break
            case LogLevel.WARN:
                this._logger = warnLogger
                break
            case LogLevel.INFO:
                this._logger = infoLogger
                break
            case LogLevel.DEBUG:
                this._logger = debugLogger
                break
            default:
                this._logger = infoLogger
        }
        this._level = level
    }
    
    logDebug(msg: string) {
        this._logger.logDebug(msg)
    }
    logInfo(msg: string) {
        this._logger.logInfo(msg)
    }
    logWarn(msg: string) {
        this._logger.logWarn(msg)
    }
    logSevere(msg: string) {
        this._logger.logSevere(msg)
    }
    logError(e: Error) {
        this._logger.logSevere('Error encountered!')
        this._logger.logError(e)
    }
}

/**
 * Logger for specific topics. E.g. performance, transaction, network etc.
 */
class TopicLogger extends DefaultLogger {

    protected _topic: string

    constructor(topic: string, level: LogLevel = LogLevel.INFO) {
        super(level)
        this._topic = topic
    }

    protected appendTopicToMsg(msg: string, subTopic?: string) {
        const subPrefix = subTopic? `:${subTopic}` : ''
        return `${this._topic}${subPrefix} - ` + msg
    }

    logDebug(msg: string, subTopic?: string) {
        this._logger.logDebug(this.appendTopicToMsg(msg, subTopic))
    }
    logInfo(msg: string, subTopic?: string) {
        this._logger.logInfo(this.appendTopicToMsg(msg, subTopic))
    }
    logWarn(msg: string, subTopic?: string) {
        this._logger.logWarn(this.appendTopicToMsg(msg, subTopic))
    }
    logSevere(msg: string, subTopic?: string) {
        this._logger.logSevere(this.appendTopicToMsg(msg, subTopic))
    }
    logError(e: Error, subTopic?: string) {
        this._logger.logSevere(this.appendTopicToMsg('Error encountered!', subTopic))
        this._logger.logError(e)
    }
}

interface ILoggers {
    [key: string]: ILogger
}

const loggers: ILoggers = {
    default: new DefaultLogger(),
    performance: new TopicLogger('performance'),
    txn: new TopicLogger('txn'),
    metadata: new TopicLogger('metadata'),
    checkin: new TopicLogger('checkin'),
    pull: new TopicLogger('pull'),
    cluster: new TopicLogger('cluster')
}


class TimeTracer implements ITimeTracer {

    private msgTimes: Map<string, number>;

    constructor() {
        this.msgTimes = new Map();
    }
    trace(msg: string): void {
        const ts = Date.now()
        const mt = this.msgTimes.get(msg)
        if (mt){
            const tsdiff = ts - mt
            loggers.performance.logWarn(msg+ ` - ms spent (${tsdiff})`, 'TIME_TRACE')
            this.msgTimes.delete(msg)
        } else {
            loggers.performance.logWarn(msg, 'TIME_TRACE')
            this.msgTimes.set(msg, ts)
        }
    }
}

class SilentTimeTracer extends TimeTracer {
    trace(_msg: string){
    }
}

let timeTracer: ITimeTracer
if (CONFIG.LOG_ENABLE_TIME_TRACE) {
    timeTracer = new TimeTracer()
} else {
    timeTracer = new SilentTimeTracer()
}

export {
    ILoggerConfig, TopicLogger, loggers, LoggerConfigurer, ILogger, DefaultLogger, timeTracer
}