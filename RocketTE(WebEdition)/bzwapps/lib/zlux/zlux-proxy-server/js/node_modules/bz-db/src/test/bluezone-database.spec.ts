import path from 'path'
import fse from 'fs-extra';
import { BlueZoneDatabase } from '../internal-db/bluezone-database.js';
import { DatabaseMetadata, PersistMethod, SelectConstraints, DataStrategy, DataEntityMetadata, EntityType,SchemaType, PersistType } from '../main/metadata.js';
// import { waitTime } from './utiles.js'
import { FileService } from '../services/files.service.js'
import { yaml } from '../services/yaml.js'

import _ from 'lodash'
import { fileURLToPath } from 'url';
import { dirname } from 'path';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// 
// const metadata = new DatabaseMetadata({
//     storePath: './testdata/',
//     processPooling: 0,
//     rejectPKonUpdate: true,
//     dataEntities: [
//         {name: 'testde', primaryKeys:['id']}
//     ],
//     onLoadReady: (results: any) => {
//         console.log('onLoadReady results: ' + JSON.stringify(results));
//     }
// });
let fileService: FileService;
let bzdb : BlueZoneDatabase;
let metadata: DatabaseMetadata;
const logConfig = {
    type: process.env.BZ_LOGGER_TYPE,
    logLevels: { // -1-SILENT, 0-SEVERE, 1-WARN, 2-INFO, 3-DEBUG
        default: -1,
        txn: -1,
        metadata: -1,
        cluster: -1,
        checkin: -1,
        pull: -1,
        performance: -1
    }
}

const testdata1:any = {
    id: 1,
    id1: 1, 
    id2: 1, 
    partcol1: 1,
    partcol2: 1,
    name: 'Jerry',
    obj: {col1: 1, col2: 1},
    arr1: [1,2,3],
    arr2: ['a', 'b', 'c'],
    arr3: [{col1: 1, col2: 1}, {col1: 2, col2: 2}, {col1: 3, col2: 3}],
    pwd:'password',
    secret:'secret'
}

const testdata1Tom = _.cloneDeep(testdata1)
testdata1Tom.name = 'Tom'
const testdata2:any = {
    id: 2,
    id1: 2, 
    id2: 2, 
    partcol1: 2,
    partcol2: 2,
    name: 'Tom',
    obj: {col1: 2, col2: 2},
    arr1: [1,2,3],
    arr2: ['a', 'b', 'c'],
    arr3: [{col1: 1, col2: 1}, {col1: 2, col2: 2}, {col1: 3, col2: 3}],
    pwd:'password',
    secret:'secret'
}
const testdata3:any = {
    id: 3,
    id1: 3, 
    id2: 3, 
    partcol1: 3,
    partcol2: 3,
    name: 'Tom',
    obj: {col1: 3, col2: 3},
    arr1: [1,2,3],
    arr2: ['a', 'b', 'c'],
    arr3: [{col1: 1, col2: 1}, {col1: 2, col2: 2}, {col1: 3, col2: 3}]
}


const tstJsonForYaml = {
    id: 'test', 
    arr: ['value1', 'value2', {'key1': 'value3'}],
    obj: {
        'key2': 'value4',
        'key3': ['value5', 'value6'],
        'key4': {
            'key5': 'value7'
        }
    },
    __bzdb_yaml_metadata: {
        comments: [
            {key: '', comment: 'Comment after all', commentBefore: 'Comment before all'},
            {key: ['arr', 2], commentBefore: 'Comment before key1 values'},
            {key: ['arr', 2, 'key1'], comment: 'Comment for key1'},
        ]
    }
};

beforeAll(() => {
    fileService = new FileService()
    const dbFolder = 'testdata'
    fse.removeSync(path.join(__dirname, `../../${dbFolder}`));
    metadata = new DatabaseMetadata({
        storePath: `./${dbFolder}`,
        processPooling: 0,
        logging: logConfig,
        rejectPKonUpdate: true,
        dataEntities: [
            {name: 'testde', primaryKeys:['id'], encryptAttrs:['pwd','secret']},
            {name: 'aDataEntity', primaryKeys:['id']},
            {
                name: 'testNoCache', 
                primaryKeys:['id'],
                dataStrategy: DataStrategy.NO_CACHE,
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                encryptAttrs:['pwd','secret']
            },
            {
                name: 'testNoCachePart', 
                primaryKeys:['id1', 'id2'],
                dataStrategy: DataStrategy.NO_CACHE,
                encryptAttrs:['pwd','secret']
            },
            {
                name: 'testPartCol', 
                primaryKeys:['id1', 'id2'],
                dataStrategy: DataStrategy.NO_CACHE,
                partitions: {
                    partcol1: 30,
                    partcol2: 30
                },
                encryptAttrs:['pwd','secret']
            },
            {
                name: 'testListFile', 
                primaryKeys:['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                encryptAttrs:['pwd','secret']
            },
            {
                name: 'testInMemory', 
                primaryKeys:['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_ONLY_MEMORY,
                encryptAttrs:['pwd','secret']
            },
            {
                name: 'testListFileYaml', 
                primaryKeys:['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                persistType: PersistType.PERSIST_TYPE_YAML
            }
        ],
        onLoadReady: (results: any) => {
            console.log('onLoadReady results: ' + JSON.stringify(results));
        }
    });
})

afterAll(async () => {
    // await waitTime()
    process.stdin.push(Buffer.from([0x0D, 0x0A]))
    // done()
    process.stdin.push(Buffer.from([0x0D, 0x0A]))
})

describe('loading ', () => {
    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
    })

    test('Database should be loaded', async () => {
        expect.assertions(1);
        expect(bzdb).toBeInstanceOf(BlueZoneDatabase);
    })
    
    test('Data entity should be loaded', async () => {
        expect.assertions(2);
        const testData = await bzdb.select('testde');
        expect(testData).toBeTruthy();
        expect(testData.dataEntityName).toBe('testde');
    })
});



/**
 * Insert
 */

describe('Insert', () => {
    
    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
    })
    // 20 ->    insert: 560ms      0.5s                             encryption with salt and constIV
    // 200 ->   insert: 4430ms     4s       read: 218ms  0.2s        200:   5967ms        200:   145ms 
    // 2000 ->  insert: 46171ms    46s      read: 2219ms  2s         2000:  59758ms       2000:  1023ms
    // 20000 -> insert: 447410ms   7.5min   read: 22395ms 22s        20000: 445783ms      20000: 11514ms     20000: 491561ms     20000:11927ms
    // 200000                      1.24h


    // test.only('encryption for 20000 times', async () => {
    //     jest.setTimeout(60*1000*100);
    //     expect.assertions(20000);
    //     // bzdb.delete('testNoCache');
    //     console.time('20000-read')
    //     for(let i=1; i<=20000 ; i++ ){
    //         testdata1.id = i
    //         const result = await bzdb.select('testNoCache', {"id":i});
    //         expect(result).toBeTruthy();
    //     }
    //     console.timeEnd('20000-read')
        
    //     // expect(result).toBeTruthy();
    //     // expect(result.status).toBeFalsy();
    //     // expect(result.message).toBe('Data entity not exist');
    //     // await bzdb.delete('testde');
    // })

    test('Insert should check data entity existance', async () => {
        expect.assertions(3);
        const result = await bzdb.insert('notExistDE', testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Data entity not exist');
        await bzdb.delete('testde');
    })
    
    test('Insert should check empty data', async () => {
        expect.assertions(3);
        const insertData = {};
        const result = await bzdb.insert('testde', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Data can not be empty');
        await bzdb.delete('testde');
    })
    
    test('Insert should check primary key', async () => {
        expect.assertions(3);
        const insertData = {name: 'Tom'};
        const result = await bzdb.insert('testde', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Insert data must contain all primary key fields');
        await bzdb.delete('testde');
    })

    test('Insert should check required columns', async () => {
        expect.assertions(3);
        const insertData = _.cloneDeep(testdata1);
        delete insertData['partcol1']
        const result = await bzdb.insert('testPartCol', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Required column missing from data');
        await bzdb.delete('testPartCol');
    })
    
    test('Insert should success', async () => {
        expect.assertions(5);
        await bzdb.delete('testde');
        const result = await bzdb.insert('testde', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testde', {id: '1'});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testde');
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testde');
    })

    test('Insert should success for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(5);
        await bzdb.delete('testPartCol');
        const result = await bzdb.insert('testPartCol', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testPartCol', {id: 1});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testPartCol');
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testPartCol');
    })

    test('Insert should success with duplicated PK for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(4);
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        const testdata2 = _.cloneDeep(testdata1)
        testdata2.partcol1 = 2
        const resultDup = await bzdb.insert('testPartCol', testdata2);
        expect(resultDup).toBeTruthy();
        expect(resultDup.status).toBeTruthy()
        const result = await bzdb.select('testPartCol', {id:1})
        expect(result).toBeTruthy();
        expect(result.rowCount).toBe(1)
        await bzdb.delete('testPartCol');
    })
    
    test('Insert should check duplicated PK', async () => {
        expect.assertions(3);
        await bzdb.delete('testde');
        await bzdb.insert('testde', testdata1);
        const resultDup = await bzdb.insert('testde', testdata1);
        expect(resultDup).toBeTruthy();
        expect(resultDup.status).toBeFalsy();
        expect(resultDup.message).toBe('Can not insert duplicated PK');
        await bzdb.delete('testde');
    })

    test('Insert should work for NO_CACHE', async () => {
        expect.assertions(5);
        await bzdb.delete('testNoCache');
        const result = await bzdb.insert('testNoCache', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testNoCache', {id: 1});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testNoCache');
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testNoCache');
    })
    
    test('Insert should check duplicated PK for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        const resultDup = await bzdb.insert('testNoCachePart', testdata1);
        expect(resultDup).toBeTruthy();
        expect(resultDup.status).toBeFalsy();
        expect(resultDup.message).toBe('Can not insert duplicated PK');
        await bzdb.delete('testNoCachePart');
    })

    test('Insert should work for partitioned NO_CACHE', async () => {
        expect.assertions(5);
        await bzdb.delete('testNoCachePart');
        const result = await bzdb.insert('testNoCachePart', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testNoCachePart', {id1: 1, id2:1});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testNoCachePart');
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testNoCachePart');
    })

    test('Insert should work for PERSIST_METHOD_ONLY_MEMORY', async () => {
        expect.assertions(5);
        await bzdb.delete('testInMemory');
        const result = await bzdb.insert('testInMemory', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testInMemory', {id: 1});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testInMemory');
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testInMemory');
    })

    test('Insert with encryption should success', async () => {
        expect.assertions(6);
        await bzdb.delete('testde');
        const result = await bzdb.insert('testde', testdata1);
        expect(result).toBeTruthy();
        const fileName = path.resolve(`${metadata.getStorePath()}/testde/9.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        const selData = await bzdb.select('testde', {id: '1'}); // select from cache. so the data is not encrypted.
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testde');
        expect(dataObj[testdata1.id].salt).toBeTruthy();
        expect(dataObj[testdata1.id].secret === selData.data[0].secret).toBe(false);
        await bzdb.delete('testde');
    })

    test('Insert with encryption should work for NO_CACHE', async () => {
        expect.assertions(7);
        await bzdb.delete('testNoCache');
        const result = await bzdb.insert('testNoCache', testdata1);
        expect(result).toBeTruthy();
        const fileName = path.resolve(`${metadata.getStorePath()}/testNoCache/1.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        const selData = await bzdb.select('testNoCache', {id: 1});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testNoCache');
        expect(dataObj.secret === selData.data[0].secret).toBe(false);
        expect(dataObj.salt).toBeTruthy();
        expect(selData.data[0]).toEqual(testdata1);
        await bzdb.delete('testNoCache');
    })

    test('Insert with encryption should work for partitioned NO_CACHE', async () => {
        expect.assertions(7);
        await bzdb.delete('testNoCachePart');
        const result = await bzdb.insert('testNoCachePart', testdata1);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testNoCachePart', {id1: 1, id2:1});
        expect(selData).toBeTruthy();
        const fileName = path.resolve(`${metadata.getStorePath()}/testNoCachePart/9ÿ9.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testNoCachePart');
        expect(selData.data[0]).toEqual(testdata1);
        expect(dataObj["1ÿ1"].secret === selData.data[0].secret).toBe(false);
        expect(dataObj["1ÿ1"].salt).toBeTruthy();
        await bzdb.delete('testNoCachePart');
    })

    test('Insert should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        const result = await bzdb.insert('testListFileYaml', tstJsonForYaml)
        expect(result.status).toBe(true)
        const filePath = path.join(__dirname, `../../testdata/_db_store/testListFileYaml/test.yaml`)
        expect(fse.existsSync(filePath)).toBe(true)
        const fileContent = fse.readFileSync(filePath).toString('utf8')
        const readJson = yaml.yamlStrToJson(fileContent)
        expect(readJson).toEqual(tstJsonForYaml)
        const queryResult = await bzdb.select('testListFileYaml')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toEqual(tstJsonForYaml)
        await bzdb.delete('testListFileYaml')
    })
});


/**
 * Update
 */
describe('Update', () => {
    
    beforeEach(async () => {
        metadata.setDataEntity(new DataEntityMetadata({name: 'testde-rej', primaryKeys:['id'], rejectPKonUpdate: false,encryptAttrs:['pwd','secret']}));
        metadata.setDataEntity(new DataEntityMetadata(
            {
                name: 'no-cache-part-rej', 
                primaryKeys:['id'], 
                rejectPKonUpdate: false,
                dataStrategy: DataStrategy.NO_CACHE
            }
        ));
        metadata.setDataEntity(new DataEntityMetadata(
            {
                name: 'no-cache-partcol-rej', 
                primaryKeys:['id'], 
                rejectPKonUpdate: false,
                dataStrategy: DataStrategy.NO_CACHE,
                partitions: {
                    partcol1: 30,
                    partcol2: 30
                }
            }
        ));
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
    })

    test('Update should check data entity existance', async () => {
        expect.assertions(3);
        const filter = {id: 1};
        const result = await bzdb.update('notExistDE', filter, testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Data entity not exist');
        await bzdb.delete('testde');
    })
    
    test('Update should check PK not changable', async () => {
        expect.assertions(3);
        const filter = {id: 1};
        await bzdb.insert('testde', testdata1);
        const result = await bzdb.update('testde', filter, testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Primary key can not be updated');
        await bzdb.delete('testde');
    })

    
    test('Update should check PK not changable for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id1: 1, id2: 1};
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        const result = await bzdb.update('testNoCachePart', filter, testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Primary key can not be updated');
        await bzdb.delete('testNoCachePart');
    })

    
    test('Update should check PK not changable for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id1: 1, id2: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        const result = await bzdb.update('testPartCol', filter, testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Primary key can not be updated');
        await bzdb.delete('testPartCol');
    })

    test('Update should ignore PK', async () => {
        expect.assertions(3);
        await bzdb.delete('testde-rej');
        const filter = {id: 1};
        await bzdb.insert('testde-rej', testdata1);
        const result = await bzdb.update('testde-rej', filter, {id: 1, name: 'tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const newdata = await bzdb.select('testde-rej', filter);
        expect(newdata.data[0]['name']).toEqual('tom');
        await bzdb.delete('testde-rej');
    })

    test('Update should ignore PK for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id: 1};
        await bzdb.insert('no-cache-part-rej', testdata1);
        const result = await bzdb.update('no-cache-part-rej', filter, {id: 1, name: 'tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const newdata = await bzdb.select('no-cache-part-rej', filter);
        expect(newdata.data[0]['name']).toEqual('tom');
        await bzdb.delete('no-cache-part-rej');
    })

    
    test('Update should ignore PK for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id: 1};
        await bzdb.insert('no-cache-partcol-rej', testdata1);
        const result = await bzdb.update('no-cache-partcol-rej', filter, {id: 1, name: 'tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const newdata = await bzdb.select('no-cache-partcol-rej', filter);
        expect(newdata.data[0]['name']).toEqual('tom');
        await bzdb.delete('no-cache-partcol-rej');
    })
    
    test('Update should check data exist', async () => {
        expect.assertions(3);
        const filter = {id: 1};
        await bzdb.delete('testde');
        await bzdb.insert('testde', testdata1);
        filter.id = 2;
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testde', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to update not exist');
        await bzdb.delete('testde');
    })

    test('Update should check data exist for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        filter.id1 = 2;
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testNoCachePart', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to update not exist');
        await bzdb.delete('testNoCachePart');
    })

    
    test('Update should check data exist for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        filter.id1 = 2;
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testPartCol', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to update not exist');
        await bzdb.delete('testPartCol');
    })
    
    test('Update should success', async () => {
        expect.assertions(5);
        const filter = {id: 1};
        await bzdb.delete('testde', filter);
        await bzdb.insert('testde', testdata1);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testde', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testde', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testde');
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testde');
    })

    test('Update should success for partitioned NO_CACHE', async () => {
        expect.assertions(5);
        const filter = {id1: 1, id2: 1};
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testNoCachePart', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testNoCachePart', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testNoCachePart');
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testNoCachePart');
    })

    test('Update should success for non-PK partitioned NO_CACHE, in same partition', async () => {
        expect.assertions(5);
        const filter = {id2: 1, partcol1: 1, partcol2: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        const row = _.cloneDeep(testdata1)
        row.id1 = 2
        await bzdb.insert('testPartCol', row);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testPartCol', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.rowCount).toBe(2);
        expect(selectResult.dataEntityName).toBe('testPartCol');
        expect(selectResult.data[0].name).toEqual('Tom');
        await bzdb.delete('testPartCol');
    })
    
    test('Update should success for non-PK partitioned NO_CACHE, in different partitions', async () => {
        expect.assertions(5);
        const filter = {id2: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        const row = _.cloneDeep(testdata1)
        row.id1 = 2
        row.partcol1 = 2
        await bzdb.insert('testPartCol', row);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testPartCol', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.rowCount).toBe(2);
        expect(selectResult.dataEntityName).toBe('testPartCol');
        expect(selectResult.data[0].name).toEqual('Tom');
        await bzdb.delete('testPartCol');
    })

    test('Update should success for non-PK partitioned NO_CACHE, in different partitions, filter includes part of partion columns', async () => {
        expect.assertions(5);
        const filter = {id2: 1, partcol2:1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        const row = _.cloneDeep(testdata1)
        row.id1 = 2
        row.partcol1 = 2
        await bzdb.insert('testPartCol', row);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testPartCol', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.rowCount).toBe(2);
        expect(selectResult.dataEntityName).toBe('testPartCol');
        expect(selectResult.data[0].name).toEqual('Tom');
        await bzdb.delete('testPartCol');
    })
    
    test('Update should success for PERSIST_METHOD_ONLY_MEMORY', async () => {
        expect.assertions(5);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testInMemory', 
                primaryKeys:['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_ONLY_MEMORY})
        );
        bzdb = new BlueZoneDatabase(metadata);
        const filter = {id: 1};
        await bzdb.delete('testInMemory', filter);
        await bzdb.insert('testInMemory', testdata1);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testInMemory', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testInMemory', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testInMemory');
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testInMemory');
    })

    test('Update should success for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(5);
        const filter = {id: 1};
        await bzdb.delete('testListFile', filter);
        await bzdb.insert('testListFile', testdata1);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testListFile', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testListFile', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testListFile');
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testListFile');
    })

    test('Update with encryption should success', async () => {
        expect.assertions(5);
        await bzdb.delete('testde-rej');
        const filter = {id: 1};
        await bzdb.insert('testde-rej', testdata1);
        
        const result = await bzdb.update('testde-rej', filter, {name: 'tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const newdata = await bzdb.select('testde-rej', filter);
        expect(newdata.data[0]['name']).toEqual('tom');
        const fileName = path.resolve(`${metadata.getStorePath()}/testde-rej/9.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj[testdata1.id].secret === newdata.data[0].secret).toBe(false);
        expect(dataObj[testdata1.id].salt).toBeTruthy();
        await bzdb.delete('testde-rej');
    })

    test('Update with encryption should success for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(7);
        const filter = {id: 1};
        await bzdb.delete('testListFile', filter);
        await bzdb.insert('testListFile', testdata1);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testListFile', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testListFile', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testListFile');
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        const fileName = path.resolve(`${metadata.getStorePath()}/testListFile/1.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj.secret === selectResult.data[0].secret).toBe(false);
        expect(dataObj.salt).toBeTruthy();
        await bzdb.delete('testListFile');
    })

    test('Update should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        await bzdb.insert('testListFileYaml', tstJsonForYaml)
        const result = await bzdb.update('testListFileYaml', {id: 'test'}, {name: 'test'})
        expect(result.status).toBe(true)
        const filePath = path.join(__dirname, `../../testdata/_db_store/testListFileYaml/test.yaml`)
        expect(fse.existsSync(filePath)).toBe(true)
        const fileContent = fse.readFileSync(filePath).toString('utf8')
        const readJson = yaml.yamlStrToJson(fileContent)
        expect(readJson.name).toBe('test')
        const queryResult = await bzdb.select('testListFileYaml')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0].name).toBe('test')
        await bzdb.delete('testListFileYaml')
    })

    //TBD, Update for NO_CACHE with PERSIST_METHOD_LIST_FILE is not supported yet.
    // test.only('Update should success for NO_CACHE with PERSIST_METHOD_LIST_FILE', async () => {
    //     expect.assertions(5);
    //     const filter = {id: '1'};
    //     const value = {id:'1', name:'Jerry'};
    //     await bzdb.delete('testNoCache', filter);
    //     await bzdb.insert('testNoCache', value);
    //     const updateValue = {name: 'Tom'};
    //     const result = await bzdb.update('testNoCache', filter, updateValue);
    //     expect(result).toBeTruthy();
    //     expect(result.status).toBeTruthy();
    //     const selectResult = await bzdb.select('testNoCache', filter);
    //     expect(selectResult.rowCount).toBe(1);
    //     expect(selectResult.dataEntityName).toBe('testNoCache');
    //     expect(selectResult.data[0]).toEqual({id:'1', name:'Tom'});
    //     await bzdb.delete('testNoCache');
    // })
});

/**
 * UpdateOrInsert
 */
describe('UpdateOrInsert', () => {
    
    beforeEach(async () => {
        metadata.setDataEntity(new DataEntityMetadata({
            name: 'de_list_file',
            primaryKeys: ['id'],
            persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: './newdir/newdir/newdir/newdir/newdir/newdir/data/',
            fileName: 'de_list_file.json'
        }));
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
    })

    test('UpdateOrInsert should check data entity existance', async () => {
        expect.assertions(3);
        const value = {id:'1', name:'Jerry'};
        const result = await bzdb.updateOrInsert('notExistDE', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Data entity not exist');
        await bzdb.delete('testde');
    })
    
    test('UpdateOrInsert should check primary key', async () => {
        expect.assertions(3);
        const insertData = {name: 'Tom'};
        const result = await bzdb.updateOrInsert('testde', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Insert data must contain all primary key fields');
        await bzdb.delete('testde');
    })
    
    test('UpdateOrInsert should check primary key for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const insertData = {name: 'Tom'};
        const result = await bzdb.updateOrInsert('testNoCachePart', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Insert data must contain all primary key fields');
        await bzdb.delete('testNoCachePart');
    })
    
    test('UpdateOrInsert should check primary key for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(3);
        const insertData = {name: 'Tom'};
        const result = await bzdb.updateOrInsert('testPartCol', insertData);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Insert data must contain all primary key fields');
        await bzdb.delete('testPartCol');
    })

    test('UpdateOrInsert should do Insert', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('testde', filter);
        const result = await bzdb.updateOrInsert('testde', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('testde');
    })

    test('UpdateOrInsert with encryption should success', async () => {
        expect.assertions(6);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('testde', filter);
        await bzdb.updateOrInsert('testde', testdata1);
        const result = await bzdb.updateOrInsert('testde', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0].name).toEqual(value.name);
        const fileName = path.resolve(`${metadata.getStorePath()}/testde/9.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj[filter.id].secret === selectResult.data[0].secret).toBe(false);
        expect(dataObj[filter.id].salt).toBeTruthy();
        await bzdb.delete('testde');
    })

    test('UpdateOrInsert with encryption should success for partitioned NO_CACHE', async () => {
        expect.assertions(6);
        const filter = {id1:1, id2:1};
        const value = {id1:1, id2:1, name: 'Tom'};
        await bzdb.delete('testNoCachePart');
        await bzdb.updateOrInsert('testNoCachePart',testdata1);
        const result = await bzdb.updateOrInsert('testNoCachePart', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0].name).toEqual(value.name);
        const fileName = path.resolve(`${metadata.getStorePath()}/testNoCachePart/9ÿ9.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj['1ÿ1'].secret === selectResult.data[0].secret).toBe(false);
        expect(dataObj['1ÿ1'].salt).toBeTruthy();
        await bzdb.delete('testNoCachePart');
    })

    test('UpdateOrInsert with encryption should success for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(6);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testPartCol');
        const result = await bzdb.updateOrInsert('testPartCol', testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0].name).toEqual(testdata1.name);
        const fileName = path.resolve(`${metadata.getStorePath()}/testPartCol/19ÿ19.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj['1ÿ1'].secret === selectResult.data[0].secret).toBe(false);
        expect(dataObj['1ÿ1'].salt).toBeTruthy();
        await bzdb.delete('testPartCol');
    })

    test('UpdateOrInsert should do Insert for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        const filter = {id1:1, id2:1};
        const value = {id1:1, id2:1, name: 'Tom'};
        await bzdb.delete('testNoCachePart');
        const result = await bzdb.updateOrInsert('testNoCachePart', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('testNoCachePart');
    })

    test('UpdateOrInsert should do Insert for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(4);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testPartCol');
        const result = await bzdb.updateOrInsert('testPartCol', testdata1);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(testdata1);
        await bzdb.delete('testPartCol');
    })
    
    test('UpdateOrInsert should check required columns for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(3);
        await bzdb.delete('testPartCol');
        const row = _.cloneDeep(testdata1)
        delete row['partcol1']
        const result = await bzdb.updateOrInsert('testPartCol', row);
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toEqual('Required column missing from data')
        await bzdb.delete('testPartCol');
    })
    
    test('UpdateOrInsert should do Insert for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(4);
        const testPath = './newdir';
        await fse.remove(testPath);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('de_list_file', filter);
        const result = await bzdb.updateOrInsert('de_list_file', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('de_list_file', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('de_list_file');
    })

    test('UpdateOrInsert should do Insert for NO_CACHE', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('testNoCache', filter);
        const result = await bzdb.updateOrInsert('testNoCache', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCache', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('testNoCache');
    })

    test('UpdateOrInsert should do Insert for PERSIST_METHOD_ONLY_MEMORY', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('testInMemory', filter);
        const result = await bzdb.updateOrInsert('testInMemory', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testInMemory', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('testInMemory');
    })
    
    test('UpdateOrInsert should do Update', async () => {
        expect.assertions(4);
        const filter = {id:1};1
        await bzdb.delete('testde', filter);
        await bzdb.insert('testde', testdata1);
        const result = await bzdb.updateOrInsert('testde', testdata1Tom);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testde');
    })
    
    test('UpdateOrInsert should do Update for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        const result = await bzdb.updateOrInsert('testNoCachePart', testdata1Tom);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testNoCachePart');
    })

    test('UpdateOrInsert should do Update for non-PK partitioned NO_CACHE in same partition', async () => {
        expect.assertions(4);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        const result = await bzdb.updateOrInsert('testPartCol', testdata1Tom);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testPartCol');
    })
    
    test('UpdateOrInsert should do Update for non-PK partitioned NO_CACHE in different partition', async () => {
        expect.assertions(4);
        const filter = {id1:1, id2:1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        const row = _.cloneDeep(testdata1)
        row.partcol1 = 2
        row.name = 'Nancy'
        const result = await bzdb.updateOrInsert('testPartCol', row);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(row);
        await bzdb.delete('testPartCol');
    })

    test('UpdateOrInsert should do Update for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(4);
        const filter = {id: 1};
        await bzdb.delete('testListFile');
        await bzdb.insert('testListFile', testdata1);
        const result = await bzdb.updateOrInsert('testListFile', testdata1Tom);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testListFile', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(testdata1Tom);
        await bzdb.delete('testListFile');
    })

    test('UpdateOrInsert should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        const result = await bzdb.updateOrInsert('testListFileYaml', tstJsonForYaml)
        expect(result.status).toBe(true)
        const filePath = path.join(__dirname, `../../testdata/_db_store/testListFileYaml/test.yaml`)
        expect(fse.existsSync(filePath)).toBe(true)
        const fileContent = fse.readFileSync(filePath).toString('utf8')
        const readJson = yaml.yamlStrToJson(fileContent)
        expect(readJson).toEqual(tstJsonForYaml)
        const queryResult = await bzdb.select('testListFileYaml')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toEqual(tstJsonForYaml)

        const updateData: any = Object.assign({}, tstJsonForYaml)
        updateData.name='test'
        const result1 = await bzdb.updateOrInsert('testListFileYaml', updateData)
        expect(result1.status).toBe(true)
        
        const queryResult1 = await bzdb.select('testListFileYaml')
        expect(queryResult1.rowCount).toBe(1)
        expect(queryResult1.data[0].name).toBe('test')

        await bzdb.delete('testListFileYaml')
    })

});

/**
 * Delete
 */
describe('Delete', () => {
    
    test('Delete should check data entity exist', async () => {
        expect.assertions(3);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id: 0, name: 'Tom'});
        await bzdb.insert('testde', {id: '2', name: 'Jerry'});
        await bzdb.insert('testde', {id: '3', name: 'Jim'});
        const result = await bzdb.delete('deNotExist', {id:'0'});
        expect(result).toBeTruthy();
        expect(result.status).toBeFalsy();
        expect(result.message).toBe('Data entity not exist')
        await bzdb.delete('testde');
    })
    
    test('Delete should success when filter with primary key', async () => {
        expect.assertions(4);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {id: 1};
        await bzdb.delete('testde');
        await bzdb.insert('testde', testdata1);
        await bzdb.insert('testde', testdata2);
        await bzdb.insert('testde', testdata3);
        const result = await bzdb.delete('testde', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testde');
    })

    test('Delete should success when filter with primary key for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {id1: 1, id2: 1};
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', testdata1);
        await bzdb.insert('testNoCachePart', testdata2);
        await bzdb.insert('testNoCachePart', testdata3);
        const result = await bzdb.delete('testNoCachePart', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testNoCachePart');
    })
    
    test('Delete should success when filter with primary key and partition columns for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {id1: 1, id2: 1, partcol1: 1, partcol2: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        const result = await bzdb.delete('testPartCol', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })

    test('Delete should success when filter with primary key and without partition columns for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {id1: 1, id2: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        const result = await bzdb.delete('testPartCol', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })

    
    test('Delete with encryption should success when filter with primary key and part of partition columns for partitioned NO_CACHE', async () => {
        expect.assertions(8);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {id1: 1, id2: 1, partcol1: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        const result = await bzdb.delete('testPartCol', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        selectResult = await bzdb.select('testPartCol');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        const fileName = path.resolve(`${metadata.getStorePath()}/testPartCol/20ÿ20.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj['2ÿ2'].secret === selectResult.data[0].secret).toBe(false);
        expect(dataObj['2ÿ2'].salt).toBeTruthy();
        await bzdb.delete('testPartCol');
    })
    
    test('Delete should success when filter without PK for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const filter = {partcol1: 1};
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        const result = await bzdb.delete('testPartCol', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })
    
    test('Delete should success when filter with index', async () => {
        expect.assertions(6);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testde', 
                primaryKeys:['id1', 'id2'], 
                indexes:{'id1':['id1']}})
        );
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        let selectResult;
        await bzdb.delete('testde');
        const filter = {id1:'1'};
        // await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.delete('testde', {id1:'1'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        selectResult = await bzdb.select('testde', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        await bzdb.delete('testde');
    })
    
    test('Delete should success when filter without pk or index', async () => {
        expect.assertions(6);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testde', 
                primaryKeys:['id1', 'id2'], 
                indexes:{'id1':['id1']}})
        );
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        // const filter = {id1:'1'};
        // await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.delete('testde', {name:'Tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', {name:'Tom'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        await bzdb.delete('testde');
    })
    
    test('Delete should success when filter without pk or index for partitioned NO_CACHE', async () => {
        expect.assertions(6);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart')
        await bzdb.insert('testNoCachePart', {id1: 1, id2:1, name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: 1, id2:2, name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: 3, id2:3, name: 'Jim'});
        const result = await bzdb.delete('testNoCachePart', {name:'Tom'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', {name:'Tom'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        selectResult = await bzdb.select('testNoCachePart');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        await bzdb.delete('testNoCachePart');
    })
    
    test('Delete should return when no data found by filter', async () => {
        expect.assertions(5);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testde', 
                primaryKeys:['id1', 'id2'], 
                indexes:{'id1':['id1']}})
        );
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        // const filter = {id1:'1'};
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.delete('testde', {name:'aaa'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to delete not exist');
        const selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(3);
        await bzdb.delete('testde');
    })

    test('Delete should return when no data found by filter for partitioned NO_CACHE', async () => {
        expect.assertions(5);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.delete('testNoCachePart', {name:'aaa'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to delete not exist');
        const selectResult = await bzdb.select('testNoCachePart');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(3);
        await bzdb.delete('testNoCachePart');
    })
    
    test('Delete should return when no data found by filter for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(5);
        await bzdb.waitLoadReady();
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.delete('testPartCol', {name:'aaa'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        expect(result.message).toBe('The data to delete not exist');
        const selectResult = await bzdb.select('testPartCol');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(3);
        await bzdb.delete('testPartCol');
    })
    
    test('Delete should work for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.insert('testListFile', value);
        const result = await bzdb.delete('testListFile', filter);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testListFile', filter);
        expect(selectResult.rowCount).toBe(0);
        expect(selectResult.data).toEqual([]);
        await bzdb.delete('testListFile');
    })

    test('Delete should success if the values is array in filter', async () => {
        expect.assertions(6);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testde', 
                primaryKeys:['id1', 'id2'], 
                indexes:{'id1':['id1']}})
        );
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const prepares = await bzdb.select('testde', {id1:['1','2']});
        expect(prepares).toBeTruthy();
        expect(prepares.rowCount).toEqual(2);
        const result = await bzdb.delete('testde', {id1:['2','3']});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        await bzdb.delete('testde');
    })
    
    test('Delete should success if the values is array in filter for partitioned NO_CACHES', async () => {
        expect.assertions(6);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const prepares = await bzdb.select('testNoCachePart', {id1:['1','2']});
        expect(prepares).toBeTruthy();
        expect(prepares.rowCount).toEqual(2);
        const result = await bzdb.delete('testNoCachePart', {id1:['2','3']});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testNoCachePart');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        await bzdb.delete('testNoCachePart');
    })
    
    test('Delete should success if the values is array in filter for non-PK partitioned NO_CACHES', async () => {
        expect.assertions(6);
        await bzdb.waitLoadReady();
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata1);
        await bzdb.insert('testPartCol', testdata2);
        await bzdb.insert('testPartCol', testdata3);
        const prepares = await bzdb.select('testPartCol', {id1:[1,2]});
        expect(prepares).toBeTruthy();
        expect(prepares.rowCount).toEqual(2);
        const result = await bzdb.delete('testPartCol', {id1:[2,3]});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testPartCol');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        await bzdb.delete('testPartCol');
    })

    test('Delete PERSIST_METHOD_ONLY_MEMORY via filter', async () => {
        expect.assertions(3);

        await bzdb.insert('testInMemory', {id: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testInMemory', {id: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testInMemory', {id: '3', id2:'3', name: 'Jim'});
        await bzdb.delete('testInMemory', {id: '1'});
        const data = await bzdb.select('testInMemory')
        expect(data).toBeTruthy();
        expect(data.rowCount).toBe(2);
        expect(data.data.length).toEqual(2);
        await bzdb.delete('testInMemory');
    })

    // TBD, currently, delete for NO_CACHE only supports data entities that has filename. 
    // test('Delete should work for NO_CACHE', async () => {
    //     expect.assertions(4);
    //     const filter = {id:'1'};
    //     const value = {id: '1', name: 'Tom'};
    //     await bzdb.insert('testNoCache', value);
    //     const result = await bzdb.delete('testNoCache', filter);
    //     expect(result).toBeTruthy();
    //     expect(result.status).toBeTruthy();
    //     let selectResult = await bzdb.select('testNoCache', filter);
    //     expect(selectResult.rowCount).toBe(0);
    //     expect(selectResult.data).toEqual([]);
    //     await bzdb.delete('testNoCache');
    // })

    test('Delete should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        await bzdb.updateOrInsert('testListFileYaml', tstJsonForYaml)
        const queryResult = await bzdb.select('testListFileYaml')
        expect(queryResult.rowCount).toBe(1)
        const result = await bzdb.delete('testListFileYaml', {id: 'test'})
        expect(result.status).toBe(true)
        const filePath = path.join(__dirname, `../../testdata/_db_store/testListFileYaml/test.yaml`)
        expect(fse.existsSync(filePath)).toBe(false)
        
        const queryResult1 = await bzdb.select('testListFileYaml')
        expect(queryResult1.rowCount).toBe(0)

        await bzdb.delete('testListFileYaml')
    })

});

/**
 * Bulkload
 */

describe('Bulkload', () => {

    test('Bulkload with encryption should success', async () => {
        expect.assertions(10);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testde', 
                primaryKeys:['id1', 'id2'], 
                indexes:{'id1':['id1']},
                encryptAttrs:['pwd','secret']})
        );
        const bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom',pwd:'password',secret:"secret"});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
    
        const loadData = [
            {id1: '1', id2: '1', name: 'Tom'},
            {id1: '1', id2: '2', name: 'Jerry1'},
            {id1: '2', id2: '2', name: 'Jerry',pwd:'password',secret:"secret"},
            {id1: '3', id2: '3', name: 'Jimmy'},
            {id1: '3', id2: '4', name: 'Nancy'},
            {id1: '4'}
        ];
        const result = await bzdb.bulkLoad('testde', loadData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testde', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        const fileName = path.resolve(`${metadata.getStorePath()}/testde/10ÿ10.json`);
        let dataText:string = await fileService.readFilePromise(fileName, 'utf8');
        let dataObj = JSON.parse(dataText);
        expect(dataObj["2ÿ2"].salt).toBeTruthy();
        expect(dataObj["2ÿ2"].secret === selectResult.data[0].secret).toBe(false);
        selectResult = await bzdb.select('testde', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        await bzdb.delete('testde');
    })

    
    test('Bulkload should success partitioned NO_CACHE', async () => {
        expect.assertions(8);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const loadData = [
            {id1: '1', id2: '1', name: 'Tom'},
            {id1: '1', id2: '2', name: 'Jerry1'},
            {id1: '2', id2: '2', name: 'Jerry'},
            {id1: '3', id2: '3', name: 'Jimmy'},
            {id1: '3', id2: '4', name: 'Nancy'},
            {id1: '4'},
            {id1: '5', id2: '5', partcol1: 1}
        ];
        const result = await bzdb.bulkLoad('testNoCachePart', loadData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testNoCachePart', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testNoCachePart', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testNoCachePart', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        await bzdb.delete('testNoCachePart');
    })

    
    test('Bulkload should success for non-PK partitioned NO_CACHE within same partition', async () => {
        expect.assertions(10);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', {id1: '1', id2:'1', partcol1: '1', partcol2:'1', name: 'Tom'});
        await bzdb.insert('testPartCol', {id1: '1', id2:'2', partcol1: '1', partcol2:'1', name: 'Jerry'});
        await bzdb.insert('testPartCol', {id1: '3', id2:'3', partcol1: '1', partcol2:'1', name: 'Jim'});
        const loadData = [
            {id1: '1', id2: '1', partcol1: '1', partcol2:'1', name: 'Tom'},
            {id1: '1', id2: '2', partcol1: '1', partcol2:'1', name: 'Jerry1'},
            {id1: '2', id2: '2', partcol1: '1', partcol2:'1', name: 'Jerry'},
            {id1: '3', id2: '3', partcol1: '1', partcol2:'1', name: 'Jimmy'},
            {id1: '3', id2: '4', partcol1: '1', partcol2:'1', name: 'Nancy'},
            {id1: '4'},
            {id1: '5', id2: '5', partcol1: 1}
        ];
        const result = await bzdb.bulkLoad('testPartCol', loadData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testPartCol', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testPartCol', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testPartCol', {id1: '4'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })

    
    test('Bulkload should success for non-PK partitioned NO_CACHE in different partitions', async () => {
        expect.assertions(10);
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', {id1: '1', id2:'1', partcol1: '1', partcol2:'1', name: 'Tom'});
        await bzdb.insert('testPartCol', {id1: '1', id2:'2', partcol1: '2', partcol2:'1', name: 'Jerry'});
        await bzdb.insert('testPartCol', {id1: '3', id2:'3', partcol1: '3', partcol2:'1', name: 'Jim'});
        const loadData = [
            {id1: '1', id2: '1', partcol1: '1', partcol2:'1', name: 'Tom'},
            {id1: '1', id2: '2', partcol1: '2', partcol2:'1', name: 'Jerry1'},
            {id1: '2', id2: '2', partcol1: '3', partcol2:'1', name: 'Jerry'},
            {id1: '3', id2: '3', partcol1: '4', partcol2:'1', name: 'Jimmy'},
            {id1: '3', id2: '4', partcol1: '5', partcol2:'1', name: 'Nancy'},
            {id1: '4'}
        ];
        const result = await bzdb.bulkLoad('testPartCol', loadData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testPartCol', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testPartCol', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testPartCol', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testPartCol', {id1: '4'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })
    
    test('Bulkload should success for PERSIST_METHOD_LIST_FILE', async () => {
        // expect.assertions(8);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testListFile', 
                primaryKeys:['id1', 'id2'],
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                indexes:{'id1':['id1']}})
        );
        const bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testListFile');
        await bzdb.insert('testListFile', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testListFile', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testListFile', {id1: '3', id2:'3', name: 'Jim'});
    
        const loadData = [
            {id1: '1', id2: '1', name: 'Tom'},
            {id1: '1', id2: '2', name: 'Jerry1'},
            {id1: '2', id2: '2', name: 'Jerry'},
            {id1: '3', id2: '3', name: 'Jimmy'},
            {id1: '3', id2: '4', name: 'Nancy'},
            {id1: '4'}
        ];
        const result = await bzdb.bulkLoad('testListFile', loadData);
        expect(result).toBeTruthy();
        // expect(result.status).toBeTruthy(); // TBD, currently, the result is an array. should change it to {status: true, results: [...]}
        let selectResult = await bzdb.select('testListFile', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        selectResult = await bzdb.select('testListFile', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testListFile', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(2);
        await bzdb.delete('testListFile');
    })

    
    test('Bulkload should success for NO_CACHE', async () => {
        // expect.assertions(8);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testNoCache', 
                primaryKeys:['id1', 'id2'], 
                dataStrategy: DataStrategy.NO_CACHE,
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                indexes:{'id1':['id1']}})
        );
        const bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCache');
        await bzdb.insert('testNoCache', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCache', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCache', {id1: '3', id2:'3', name: 'Jim'});
    
        const loadData = [
            {id1: '1', id2: '1', name: 'Tom'},
            {id1: '1', id2: '2', name: 'Jerry1'},
            {id1: '2', id2: '2', name: 'Jerry'},
            {id1: '3', id2: '3', name: 'Jimmy'},
            {id1: '3', id2: '4', name: 'Nancy'},
            {id1: '4'}
        ];
        const result = await bzdb.bulkLoad('testNoCache', loadData);
        expect(result).toBeTruthy();
        // expect(result.status).toBeTruthy(); // TBD, currently, the result is an array. should change it to {status: true, results: [...]}
        let selectResult = await bzdb.select('testNoCache', {id1: '1'});
        expect(selectResult).toBeTruthy();
        // expect(selectResult.rowCount).toEqual(2); // TBD, filter for NO_CACHE doesn't work.
        selectResult = await bzdb.select('testNoCache', {id1: '2'});
        expect(selectResult).toBeTruthy();
        // expect(selectResult.rowCount).toEqual(1); // TBD, filter for NO_CACHE doesn't work.
        selectResult = await bzdb.select('testNoCache', {id1: '3'});
        expect(selectResult).toBeTruthy();
        // expect(selectResult.rowCount).toEqual(2); // TBD, filter for NO_CACHE doesn't work.
        await bzdb.delete('testNoCache'); // TBD, delete for NO_CACHE doesn't work.
    })

    test('Bulkload should success for PERSIST_METHOD_ONLY_MEMORY', async () => {
        expect.assertions(13);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testInMemory', 
                primaryKeys:['id1'], 
                persistMethod: PersistMethod.PERSIST_METHOD_ONLY_MEMORY})
        );
        const bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        const count = await bzdb.count('testInMemory');
        expect(count).toBeTruthy();
        expect(count.rowCount).toBe(0);
    
        const loadData = [
            {id1: '1', id2: '1', name: 'Tom'},
            {id1: '1', id2: '2', name: 'Jerry1'},
            {id1: '2', id2: '2', name: 'Jerry'},
            {id1: '3', id2: '3', name: 'Jimmy'},
            {id1: '3', id2: '4', name: 'Nancy'},
            {id1: '4'}
        ];
        const result = await bzdb.bulkLoad('testInMemory', loadData);
        expect(result).toBeTruthy();
        let selectAll = await bzdb.select('testInMemory');
        expect(selectAll).toBeTruthy();
        expect(selectAll.rowCount).toBe(4);
        // expect(result.status).toBeTruthy(); // TBD, currently, the result is an array. should change it to {status: true, results: [...]}
        let selectResult = await bzdb.select('testInMemory', {id1: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.data[0]).toEqual({id1: '1', id2: '2', name: 'Jerry1'});
        selectResult = await bzdb.select('testInMemory', {id1: '2'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toBe(1);
        selectResult = await bzdb.select('testInMemory', {id1: '3'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.data[0]).toEqual({id1: '3', id2: '4', name: 'Nancy'});
        await bzdb.delete('testInMemory'); 
    })

    test('Bulkload should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        const result = await bzdb.bulkLoad('testListFileYaml', [tstJsonForYaml])
        expect(result[0].status).toBe(true)
        const filePath = path.join(__dirname, `../../testdata/_db_store/testListFileYaml/test.yaml`)
        expect(fse.existsSync(filePath)).toBe(true)
        const fileContent = fse.readFileSync(filePath).toString('utf8')
        const readJson = yaml.yamlStrToJson(fileContent)
        expect(readJson).toEqual(tstJsonForYaml)
        const queryResult = await bzdb.select('testListFileYaml')
        expect(queryResult.rowCount).toBe(1)
        expect(queryResult.data[0]).toEqual(tstJsonForYaml)

        await bzdb.delete('testListFileYaml')
    })
});

describe('count', () => {
    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
    })

    test('Unknown DE should return status false', async () => {
        expect.assertions(4);
        const data = await bzdb.count('unknown DE');
        expect(data).toBeTruthy();
        expect(data.status).toBe(false);
        expect(data.rowCount).toBe(0);
        expect(data.message).toBeTruthy();
    })
    
    test('count works for normal de', async () => { // This case uses the same metadata as bulkload, it must run together with bulkload 
        expect.assertions(3);
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.count('testde');
        expect(data).toBeTruthy();
        expect(data.status).toBe(true);
        expect(data.rowCount).toBe(3);
        await bzdb.delete('testde');
    })

    test('count works for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.count('testNoCachePart');
        expect(data).toBeTruthy();
        expect(data.status).toBe(true);
        expect(data.rowCount).toBe(3);
        await bzdb.delete('testNoCachePart');
    })

    test('count works for PERSIST_METHOD_LIST_FILE', async () => {
        expect.assertions(3);
        await bzdb.delete('testListFile');
        await bzdb.insert('testListFile', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testListFile', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testListFile', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.count('testListFile');
        expect(data).toBeTruthy();
        expect(data.status).toBe(true);
        expect(data.rowCount).toBe(3);
        await bzdb.delete('testListFile');
    })
    
    test('count should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        await bzdb.bulkLoad('testListFileYaml', [tstJsonForYaml])
        const data = await bzdb.count('testListFileYaml')
        expect(data).toBeTruthy();
        expect(data.status).toBe(true);
        expect(data.rowCount).toBe(1);
        await bzdb.delete('testListFileYaml')
    })
})


describe('select', () => {
    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
    })

    test('Select can return whole data entity', async () => {
        expect.assertions(2);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testde');
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        await bzdb.delete('testde');
    })
    
    test('Select can return whole data entity for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(2);
        await bzdb.delete('testPartCol')
        const testdata = _.cloneDeep(testdata1)
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        const data = await bzdb.select('testPartCol');
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        await bzdb.delete('testPartCol');
    })

    test('Select can return whole data entity for partitioned NO_CACHE', async () => {
        expect.assertions(2);
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart');
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        await bzdb.delete('testNoCachePart');
    })

    test('Select return 0 rows when no data match to filter', async () => {
        expect.assertions(2);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testde', {id1: '4'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(0);
        await bzdb.delete('testde');
    })


    test('Select return 0 rows when no data match to filter for partitioned NO_CACHE', async () => {
        expect.assertions(2);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart', {id1: '4'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(0);
        await bzdb.delete('testNoCachePart');
    })

    
    test('Select return 0 rows when no data match to filter for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(2);
        await bzdb.waitLoadReady();
        const testdata = _.cloneDeep(testdata1)
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        const data = await bzdb.select('testPartCol', {id1: '4'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(0);
        await bzdb.delete('testPartCol');
    })

    test('Select return correct data that match to filter', async () => {
        expect.assertions(3);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testde', {id1: '1'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data.length).toEqual(2);
        await bzdb.delete('testde');
    })

    test('Select return correct data that match to filter for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(9);
        await bzdb.waitLoadReady();
        const testdata = _.cloneDeep(testdata1)
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 4
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        let data = await bzdb.select('testPartCol', {id1: 1}); // select with part of PK
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0].partcol1).toEqual(1);
        data = await bzdb.select('testPartCol', {id1: 1, id2: 1}); // select with PK
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0].partcol1).toEqual(1);
        data = await bzdb.select('testPartCol', {partcol1: 3, partcol2: 1}); // select with partitioned column
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data[0].partcol1).toEqual(3);
        await bzdb.delete('testPartCol');
    })

    test('Select return correct data that match to filter for partitioned NO_CACHE', async () => {
        expect.assertions(3);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart', {id1: '1'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data.length).toEqual(2);
        await bzdb.delete('testNoCachePart');
    })
    
    test('Select return correct data that match to filter with ignore case fields', async () => {
        expect.assertions(3);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const options = new SelectConstraints().addIgnoreCaseFields('name');;
        const data = await bzdb.select('testde', {name: 'tom'}, options);
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0]['name']).toEqual('Tom');
        await bzdb.delete('testde');
    })

    // ignore case select is not supported for partitioned NO_CACHE yet
    // test('Select return correct data that match to filter with ignore case fields for partitioned NO_CACHE', async () => {
    //     expect.assertions(3);
    //     await bzdb.waitLoadReady();
    //     await bzdb.delete('testNoCachePart');
    //     await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
    //     await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
    //     await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
    //     const options = new SelectConstraints().addIgnoreCaseFields('name');
    //     const data = await bzdb.select('testNoCachePart', {name: 'tom'}, options);
    //     expect(data).toBeTruthy();
    //     expect(data.rowCount).toEqual(1);
    //     expect(data.data[0]['name']).toEqual('Tom');
    //     await bzdb.delete('testNoCachePart');
    // })

    test('Select return correct data that match to filter with array', async () => {
        expect.assertions(4);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testde', {id1: ['1','2']});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data[0]['name']).toEqual('Tom');
        expect(data.data[1]['name']).toEqual('Jerry');
        await bzdb.delete('testde');
    })
    
    test('Select return correct data that match to filter with array for partitioned NO_CACHE', async () => {
        expect.assertions(4);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart', {id1: ['1','2']});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data[0]['name']).toEqual('Tom');
        expect(data.data[1]['name']).toEqual('Jerry');
        await bzdb.delete('testNoCachePart');
    })
    
    test('Select return correct data that match to filter for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(2);
        await bzdb.waitLoadReady();
        const testdata = _.cloneDeep(testdata1)
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        const data = await bzdb.select('testPartCol', {id1: [1,2]});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        await bzdb.delete('testPartCol');
    })

    test('Select return correct data that match to filter with array in persist method ', async () => {
        expect.assertions(4);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testListFile', 
                primaryKeys:['id1', 'id2'],
                persistMethod: PersistMethod.PERSIST_METHOD_LIST_FILE,
                indexes:{'id1':['id1']}})
        );
        const bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testListFile');
        await bzdb.insert('testListFile', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testListFile', {id1: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testListFile', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testListFile', {id1: ['2','3']});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data[0]['name']).toEqual('Jerry');
        expect(data.data[1]['name']).toEqual('Jim');
        await bzdb.delete('testListFile');
    })
    
    test('Select return data in correct order', async () => {
        expect.assertions(8);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testde', {}, {orderBy:{fields:['id1','id2'], orders: ['asc', 'desc']}});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('2');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('1');
        expect(data.data[2]['id1']).toEqual('3');
        expect(data.data[2]['id2']).toEqual('3');
        await bzdb.delete('testde');
    })

    test('Select return data in correct order for partitioned NO_CACHE', async () => {
        expect.assertions(8);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart', {}, {orderBy:{fields:['id1','id2'], orders: ['asc', 'desc']}});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('2');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('1');
        expect(data.data[2]['id1']).toEqual('3');
        expect(data.data[2]['id2']).toEqual('3');
        await bzdb.delete('testNoCachePart');
    })

    test('Select return data in correct order for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(8);
        await bzdb.waitLoadReady();
        const testdata = _.cloneDeep(testdata1)
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        const data = await bzdb.select('testPartCol', {}, {orderBy:{fields:['id1','id2'], orders: ['asc', 'desc']}});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        expect(data.data[0]['id1']).toEqual(1);
        expect(data.data[0]['id2']).toEqual(1);
        expect(data.data[1]['id1']).toEqual(2);
        expect(data.data[1]['id2']).toEqual(1);
        expect(data.data[2]['id1']).toEqual(3);
        expect(data.data[2]['id2']).toEqual(1);
        await bzdb.delete('testPartCol');
    })
    
    test('Select return data with correct pagination', async () => {
        expect.assertions(14);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '1', id2:'3', name: 'Jim'});
        await bzdb.insert('testde', {id1: '1', id2:'4', name: 'Nancy'});
        await bzdb.insert('testde', {id1: '1', id2:'5', name: 'Kate'});
        await bzdb.insert('testde', {id1: '2', id2:'1', name: 'Will'});
        await bzdb.insert('testde', {id1: '2', id2:'2', name: 'Tom'});
        await bzdb.insert('testde', {id1: '2', id2:'3', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '2', id2:'4', name: 'Jim'});
        const data = await bzdb.select('testde', {}, {
            orderBy:{fields:['id1','id2'], orders: ['desc', 'desc']},
            pagination: {page: 2, size: 5}
        });
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(4);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('4');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('3');
        expect(data.data[2]['id1']).toEqual('1');
        expect(data.data[2]['id2']).toEqual('2');
        expect(data.data[3]['id1']).toEqual('1');
        expect(data.data[3]['id2']).toEqual('1');
        expect(data.total).toEqual(9);
        expect(data.page).toEqual(2);
        expect(data.pageSize).toEqual(5);
        expect(data.totalPages).toEqual(2);
        await bzdb.delete('testde');
    })
    
    test('Select return data with correct pagination for partitioned NO_CACHE', async () => {
        expect.assertions(14);
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCachePart');
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'3', name: 'Jim'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'4', name: 'Nancy'});
        await bzdb.insert('testNoCachePart', {id1: '1', id2:'5', name: 'Kate'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'1', name: 'Will'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'2', name: 'Tom'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'3', name: 'Jerry'});
        await bzdb.insert('testNoCachePart', {id1: '2', id2:'4', name: 'Jim'});
        const data = await bzdb.select('testNoCachePart', {}, {
            orderBy:{fields:['id1','id2'], orders: ['desc', 'desc']},
            pagination: {page: 2, size: 5}
        });
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(4);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('4');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('3');
        expect(data.data[2]['id1']).toEqual('1');
        expect(data.data[2]['id2']).toEqual('2');
        expect(data.data[3]['id1']).toEqual('1');
        expect(data.data[3]['id2']).toEqual('1');
        expect(data.total).toEqual(9);
        expect(data.page).toEqual(2);
        expect(data.pageSize).toEqual(5);
        expect(data.totalPages).toEqual(2);
        await bzdb.delete('testNoCachePart');
    })

    
    test('Select return data in correct pagination for non-PK partitioned NO_CACHE', async () => {
        expect.assertions(8);
        await bzdb.waitLoadReady();
        const testdata = _.cloneDeep(testdata1)
        await bzdb.delete('testPartCol');
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 2
        testdata.partcol1 =2
        await bzdb.insert('testPartCol', testdata);
        testdata.id1 = 3
        testdata.partcol1 =3
        await bzdb.insert('testPartCol', testdata);
        const data = await bzdb.select('testPartCol', {}, {orderBy:{fields:['id1','id2'], orders: ['asc', 'desc']}, pagination: {page: 2, size: 2}});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0]['id1']).toEqual(3);
        expect(data.data[0]['id2']).toEqual(1);
        expect(data.total).toEqual(3);
        expect(data.page).toEqual(2);
        expect(data.pageSize).toEqual(2);
        expect(data.totalPages).toEqual(2);
        await bzdb.delete('testPartCol');
    })

    test('Select return correct data for NO_CACHE + PERSIST_METHOD_LIST_FILE', async () => {
        await bzdb.waitLoadReady();
        await bzdb.delete('testNoCache');
        await bzdb.insert('testNoCache', testdata1);
        await bzdb.insert('testNoCache', testdata2);
        const dataAll = await bzdb.select('testNoCache');
        expect(dataAll.rowCount).toEqual(2);
        const data = await bzdb.select('testNoCache', {id:1});
        expect(data.rowCount).toEqual(1);
    })

    test('Select should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        await bzdb.bulkLoad('testListFileYaml', [tstJsonForYaml])
        const dataAll = await bzdb.select('testListFileYaml');
        expect(dataAll.rowCount).toEqual(1);
        const data = await bzdb.select('testListFileYaml', {id:1});
        expect(data.rowCount).toEqual(0);

        await bzdb.delete('testListFileYaml')
    })

});

describe('selectSync', () => {

    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testde');
    })

    test('SelectSync for partitioned NO_CACHE', () => {
        expect.assertions(3);
        const data = bzdb.selectSync('testNoCachePart');
        expect(data).toBeTruthy();
        expect(data.status).toBe(false);
        expect(data.message).toEqual('Function not implemented');
    })

    test('Select can return whole data entity', async () => {
        expect.assertions(2);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testde');
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        await bzdb.delete('testde');
    })

    test('Select return 0 rows when no data match to filter', async () => {
        expect.assertions(2);

        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testde', {id1: '4'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(0);
        await bzdb.delete('testde');
    })

    test('Select return correct data that match to filter', async () => {
        expect.assertions(3);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testde', {id1: '1'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(2);
        expect(data.data.length).toEqual(2);
        await bzdb.delete('testde');
    })

    
    test('Select return correct data that match to filter with ignore case fields', async () => {
        expect.assertions(3);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testde', {name: 'tom'}, {ignoreCaseFields:['name']});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0]['name']).toEqual('Tom');
        await bzdb.delete('testde');
    })

    
    test('Select return data in correct order', async () => {
        expect.assertions(8);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testde', {}, {orderBy:{fields:['id1','id2'], orders: ['asc', 'desc']}});
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(3);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('2');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('1');
        expect(data.data[2]['id1']).toEqual('3');
        expect(data.data[2]['id2']).toEqual('3');
        await bzdb.delete('testde');
    })

    
    test('Select return data with correct pagination', async () => {
        expect.assertions(14);
        await bzdb.insert('testde', {id1: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testde', {id1: '1', id2:'2', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '1', id2:'3', name: 'Jim'});
        await bzdb.insert('testde', {id1: '1', id2:'4', name: 'Nancy'});
        await bzdb.insert('testde', {id1: '1', id2:'5', name: 'Kate'});
        await bzdb.insert('testde', {id1: '2', id2:'1', name: 'Will'});
        await bzdb.insert('testde', {id1: '2', id2:'2', name: 'Tom'});
        await bzdb.insert('testde', {id1: '2', id2:'3', name: 'Jerry'});
        await bzdb.insert('testde', {id1: '2', id2:'4', name: 'Jim'});
        const data = await bzdb.selectSync('testde', {}, {
            orderBy:{fields:['id1','id2'], orders: ['desc', 'desc']},
            pagination: {page: 2, size: 5}
        });
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(4);
        expect(data.data[0]['id1']).toEqual('1');
        expect(data.data[0]['id2']).toEqual('4');
        expect(data.data[1]['id1']).toEqual('1');
        expect(data.data[1]['id2']).toEqual('3');
        expect(data.data[2]['id1']).toEqual('1');
        expect(data.data[2]['id2']).toEqual('2');
        expect(data.data[3]['id1']).toEqual('1');
        expect(data.data[3]['id2']).toEqual('1');
        expect(data.total).toEqual(9);
        expect(data.page).toEqual(2);
        expect(data.pageSize).toEqual(5);
        expect(data.totalPages).toEqual(2);
        await bzdb.delete('testde');
    })

    test('Select PERSIST_METHOD_ONLY_MEMORY via filter', async () => {
        expect.assertions(3);
        metadata.setDataEntity(
            new DataEntityMetadata({name:'testInMemory', 
                primaryKeys:['id'],
                persistMethod: PersistMethod.PERSIST_METHOD_ONLY_MEMORY})
        );
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('testInMemory');
        await bzdb.insert('testInMemory', {id: '1', id2:'1', name: 'Tom'});
        await bzdb.insert('testInMemory', {id: '2', id2:'2', name: 'Jerry'});
        await bzdb.insert('testInMemory', {id: '3', id2:'3', name: 'Jim'});
        const data = await bzdb.selectSync('testInMemory', {id: '1'});
        expect(data).toBeTruthy();
        expect(data.rowCount).toBe(1);
        expect(data.data.length).toBe(1);
        await bzdb.delete('testInMemory');
    })

    test('Select should work for yaml', async () => {
        await bzdb.delete('testListFileYaml')
        await bzdb.bulkLoad('testListFileYaml', [tstJsonForYaml])
        const dataAll = await bzdb.selectSync('testListFileYaml');
        expect(dataAll.rowCount).toEqual(1);

        await bzdb.delete('testListFileYaml')
    })
});

describe('test extend entity',  () => {
    beforeEach(async () => {
        bzdb = new BlueZoneDatabase(metadata);
        await bzdb.waitLoadReady();
        await bzdb.delete('aDataEntity');
    })
    test('can create persist entity', async () => {
        expect.assertions(4);
        const persist={
            name: 'persistDataEntity',
            primaryKeys: ['id'],
            dataStrategy: DataStrategy.NO_CACHE,
            entityType:EntityType.PERSIST,
            filePath:'persistDataEntity'
        }
        const rtn1=await bzdb.create(SchemaType.PERSIST_ENTITY,persist); //frist
        expect(rtn1.status).toBeTruthy(); 
        const rtn2=await bzdb.create(SchemaType.PERSIST_ENTITY,persist);
        expect(rtn2.status).toBeFalsy();
        const data1 = await bzdb.select('persistDataEntity');
        expect(data1.rowCount).toEqual(0);
        await bzdb.insert('persistDataEntity', {id: '1', name: 'Tom'});
        await bzdb.insert('persistDataEntity', {id: '2', name: 'Jerry'});
        await bzdb.insert('persistDataEntity', {id: '3', name: 'Jim'});
        const data2 = await bzdb.select('persistDataEntity');
        expect(data2.rowCount).toEqual(3);
    })
    test('can destroy persist entity', async () => {
        expect.assertions(5);
        const data1 = await bzdb.select('persistDataEntity');
        expect(data1.rowCount).toEqual(3);
        const result1= await bzdb.drop(SchemaType.PERSIST_ENTITY,'persistDataEntity'); //frist
        expect(result1.status).toBeTruthy();
        const persist={
            name: 'persistDataEntity',
            primaryKeys: ['id'],
            dataStrategy: DataStrategy.NO_CACHE,
            entityType:EntityType.PERSIST,
            filePath:'persistDataEntity'
        }
        const rtn1=await bzdb.create(SchemaType.PERSIST_ENTITY,persist); //frist
        expect(rtn1.status).toBeTruthy(); 
        const data2 = await bzdb.select('persistDataEntity');
        expect(data2.rowCount).toEqual(0);
        const result2= await bzdb.drop(SchemaType.PERSIST_ENTITY,'persistDataEntity'); //frist
        expect(result2.status).toBeTruthy();
        
    })
    test('can create temp entity', async () => {
        expect.assertions(4);
        await bzdb.insert('aDataEntity', {id: '1', name: 'Tom'});
        await bzdb.insert('aDataEntity', {id: '2', name: 'Jerry'});
        await bzdb.insert('aDataEntity', {id: '3', name: 'Jim'});
        const data1 = await bzdb.select('aDataEntity');
        const temp={
            name: 'tempDataEntity',
            primaryKeys: ['id'],
            dataStrategy: DataStrategy.NO_CACHE,
            entityType:EntityType.TEMP,
            filePath:'aDataEntity'
        }
        const rtn1=await bzdb.create(SchemaType.TEMP_ENTITY,temp);  //first
        expect(rtn1.status).toBeTruthy();
        const rtn2=await bzdb.create(SchemaType.TEMP_ENTITY,temp);  //second
        expect(rtn2.status).toBeFalsy();
        const data2 = await bzdb.select('tempDataEntity');
        expect(data2).toBeTruthy();
        expect(data2.rowCount).toEqual(data1.rowCount);
        
    })
    test('can destroy temp entity', async () => {
        expect.assertions(6);
        await bzdb.insert('tempDataEntity', {id: '1', name: 'Tom'});
        await bzdb.insert('tempDataEntity', {id: '2', name: 'Jerry'});
        await bzdb.insert('tempDataEntity', {id: '3', name: 'Jim'});
        const data1 = await bzdb.select('tempDataEntity');
        expect(data1).toBeTruthy();
        expect(data1.rowCount).toEqual(3);
        const result1= await bzdb.drop(SchemaType.TEMP_ENTITY,'tempDataEntity');  //first
        expect(result1.status).toBeTruthy();
        const temp={
            name: 'tempDataEntity',
            primaryKeys: ['id'],
            dataStrategy: DataStrategy.NO_CACHE,
            entityType:EntityType.TEMP,
            filePath:'aDataEntity'
        }
        const rtn1=await bzdb.create(SchemaType.TEMP_ENTITY,temp);  //first
        expect(rtn1.status).toBeTruthy();
        const data2 = await bzdb.select('tempDataEntity');
        expect(data2.rowCount).toEqual(3);
        const result2= await bzdb.drop(SchemaType.TEMP_ENTITY,'tempDataEntity'); //frist
        expect(result2.status).toBeTruthy();
        
    })
})


/**
 * Log to file
 */

// it('Log should write to file by metadata', async () => {
//     expect.assertions(1);
//     const testFileName = './log/bzdbtest1.log';
//     // if (fs.existsSync(testFileName)) fs.unlinkSync(testFileName);
//     metadata['logging'] = {type:'file', fileName:testFileName}
//     const bzdb = new BlueZoneDatabase(metadata);
//     await bzdb.waitLoadReady();
//     const insertData = {id: '1', name: 'Tom'};
//     await bzdb.delete('testde', {id: '1'});
//     await bzdb.insert('testde', insertData);
//     const result = fs.existsSync(testFileName);
//     expect(result).toBeTruthy();
// });

// it('Log should write to file by changeLogger', async () => {
//     expect.assertions(1);
//     const testFileName = './log/bzdbtest2.log';
//     if (fs.existsSync(testFileName)) fs.unlinkSync(testFileName);
//     delete metadata['logging'];
//     const bzdb = new BlueZoneDatabase(metadata);
//     await bzdb.waitLoadReady();
//     bzdb.changeLogger({type:'file', fileName:testFileName});
//     const insertData = {id: '1', name: 'Tom'};
//     await bzdb.delete('testde', {id: '1'});
//     await bzdb.insert('testde', insertData);
//     const result = fs.existsSync(testFileName);
//     expect(result).toBeTruthy();
// });
