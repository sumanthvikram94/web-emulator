import { Logger } from './index.js'
import { STATUS } from '../constants/status.js'
import { eventHandler } from '../event/event-handler.js'

class Status {

    _status: string = STATUS.LOADING
    _promise: Promise<any> // The promise for loading
    _resolver: Function
    _promiseStatus: Promise<any> // The promise for status
    _resolverStatus: Function
    _ready: boolean = false
    _timing: number = 0
    _observer: any;

    constructor(){
        this._promise = new Promise<any>(resolve => {
            this._resolver = resolve
        })
        this._promiseStatus = new Promise<any>(resolve => {
            this._resolverStatus = resolve
        })
    }

    setObserver(observer: any) {
        this._observer = observer;
    }

    setUnresolvedPromise(){
        if (this._ready === true ){ // make a unresolved promise if it's ready status
            this._promiseStatus = new Promise<any>(resolve => {
                this._resolverStatus = resolve
            })
            this._ready = false
        }
    }

    resolvePromise(){
        this._resolver()
    }

    
    resolveStatusPromise(){
        if (this._ready === false){
            this._resolverStatus()
            this._ready = true
            Logger.logInfo(`Ready flag is now: ${this._ready}`)
        }
    }

    get status(){
        return this._status
    }

    set status(s: string){
        if (s === this._status) return
        Logger.logDebug(`Changing local node status from "${this._status}" to "${s}", current ready flag is: ${this._ready}`)
        this._status = s
        switch(s){
            case STATUS.LONELY_ISLAND:
            case STATUS.READY:{
                this.resolvePromise()
                this.resolveStatusPromise()
                if(eventHandler.listenStatusMap){
                    eventHandler.occuredEventMap[STATUS.DATA_CONFLICT] = [];
                }
                this._observer?.next(this._status)
                break
            }
            case STATUS.DATA_CONFLICT:{
                this.resolvePromise()
                break
            }
            default:{
                this.setUnresolvedPromise()
            }
        }
            
    }

    markLoadReady(){
        this.resolvePromise()
    }
    
    async waitStatusReady(){
        if (!this._ready){
            const interval = 10000
            const timing = setInterval(() => {
                this._timing +=  interval / 1000 // count the seconds waited.
                Logger.logInfo('Awaiting for ready status, seconds: ' + this._timing + ', current status: ' + this._status)
            }, interval)
            await this._promiseStatus
            clearInterval(timing)
            this._timing = 0
        }
        return this._status
    }

    async waitLoadReady(){
        if (!this._ready){
            const interval = 10000
            const timing = setInterval(() => {
                this._timing +=  interval / 1000 // count the seconds waited.
                Logger.logInfo('Awaiting for ready status, seconds: ' + this._timing + ', current status: ' + this._status)
            }, interval)
            await this._promise
            clearInterval(timing)
            this._timing = 0
        }
        return this._status
    }

    get ready(){
        return this._ready
    }

}

export {
    Status
}