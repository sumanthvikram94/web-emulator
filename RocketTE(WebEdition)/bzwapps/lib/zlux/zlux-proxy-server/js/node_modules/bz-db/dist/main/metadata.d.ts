declare enum IntegratyLevel {
    INTEGRATY_STRONG = 1,
    INTEGRATY_MIDIUM = 2,
    INTEGRATY_WEAK = 3
}
declare enum AnalyzeMethod {
    ANALYZE_METHOD_SELECT = 1,
    ANALYZE_METHOD_FILE_SIZE = 2
}
declare enum PersistMethod {
    PERSIST_METHOD_LIST_FILE = 1,
    PERSIST_METHOD_COMBINED_FILE = 2,
    PERSIST_METHOD_ONLY_MEMORY = 3
}
declare enum PersistType {
    PERSIST_TYPE_ARRAY = 1,
    PERSIST_TYPE_OBJECT = 2,
    PERSIST_TYPE_RAW = 3,
    PERSIST_TYPE_YAML = 4
}
declare enum SyncMode {
    SYNC_ALL = 1,
    SYNC_LOCAL = 2
}
/**
 * Removed
 */
declare enum DataStrategy {
    FILE_NO_WATCH = 0,
    FILE_WATCH = 1,
    MEMORY_ONLY = 2,
    NO_CACHE = 3
}
declare enum EntityType {
    PERSIST = 0,
    TEMP = 1
}
declare const enum SchemaType {
    PERSIST_ENTITY = "ENTITY",
    TEMP_ENTITY = "TEMP ENTITY"
}
export declare enum PeerDiscovery {
    MULTICAST_DNS = "mdns",
    BOOTSTRAP = "bootstrap"
}
export declare enum ClusterNodeType {
    PERSISTENT = "persistent",
    SCALABLE = "scalable"
}
export declare enum DATA_CONFLICT_POLICY {
    MARK_CONFLICT = 0,
    CUT_SHORTER_CHAIN = 1
}
export interface MetaAutoScaling {
    enabled: boolean;
    discovery: PeerDiscovery;
    nodeType: ClusterNodeType;
    peerList: string[];
    pnetMasks: String[];
    ipBlackList: String[];
}
export interface ClusterProxy {
    protocol?: string;
    ip?: string;
    port?: string;
}
export interface MetaCluster {
    enabled: boolean;
    proxy?: ClusterProxy;
    autoScaling: MetaAutoScaling;
}
declare class DatabaseMetadata {
    private _dataEntityMetadata;
    private _storePath;
    private _onLoadReady;
    private _metadata;
    private _dataStrategy;
    private _rejectPKonUpdate;
    private _cluster;
    private _performance;
    private _conflictPolicy;
    /**
     * @param metadata The database metadata
     * @param metadata.appName : string, the application name who is using BZDB
     * @param metadata.storePath : string
     * @param metadata.dataEntities : [DataEntityMetadata]
     * @param metadata.logging : logger.LoggerConfig
     * @param metadata.OnLoadReady : Function
     * @param metadata.memoryOnly : boolean
     * @param metadata.watchDataChanges : boolean
     * @param metadata.rejectPKonUpdate : boolean
     * @param metadata.enableWorkerThread: boolean. If true, the db-worker will run in a seperate thread.
     * @param metadata.cluster: MetaCluster
     * @param metadata.performance.workOnBusy: boolean. If true, the db won't reject any request even when process is busy
     * @param metadata.autoResolveConflict: auto resolve data conflict
     */
    constructor(metadata?: any);
    /**
     * Here includes user configurations, and requires better validation.
     */
    parseClusterSettings(): void;
    get cluster(): MetaCluster;
    get logging(): any;
    isWorkOnBusy(): boolean;
    isWorkerThreadEnabled(): boolean;
    get conflictPolicy(): DATA_CONFLICT_POLICY;
    getDataStrategy(): DataStrategy;
    getMetaData(): any;
    setStorePath(relevantPathtoCwd: string): void;
    getStorePath(): string;
    setDataEntity(metadata: DataEntityMetadata): void;
    getDataEntities(): Map<string, DataEntityMetadata>;
    getOnLoadReady(): (results: any[]) => void;
    setOnLoadReady(cb: (results: any[]) => void): void;
    setRejectPKonUpdate(val: boolean): void;
    getRejectPKonUpdate(): boolean;
}
declare class DataEntityMetadata {
    name: string;
    primaryKeys: string[];
    uniqueKeys?: string[];
    indexes?: any;
    sequenceFields?: string[];
    persistMethod?: PersistMethod;
    persistType?: PersistType;
    syncMode?: SyncMode;
    constraintFileName?: string[];
    filePath?: string;
    fileName?: string;
    fileNamePrefix?: string;
    fileNameSurfix?: string;
    rejectPKonUpdate?: boolean;
    externalStorage?: string;
    dataStrategy?: DataStrategy;
    backupFilePaths?: string[];
    isAllowSubFolder?: boolean;
    partitions: PartitionSetting;
    isNonPKPartitioned: boolean;
    syncFile4Cluster?: boolean;
    requiredCols: string[];
    entityType?: EntityType;
    analyzeMethod?: AnalyzeMethod;
    integratyLevel?: IntegratyLevel;
    encryptAttrs?: string[];
    isNoPK?: boolean;
    isInternal?: boolean;
    owner?: string;
    constructor(deObj: Object);
    validateRequiredCol(row: any): boolean;
    getPartitionColumn(): string[];
    getPartitionCount(col: string): number;
}
declare const enum BulkLoadReplaceStrategy {
    DELETE_INSERT = 1,
    UPDATE = 2,
    IGNORE = 3
}
declare const enum SortOrder {
    ASC = "asc",
    DESC = "desc"
}
export interface OrderBy {
    fields: string[];
    orders?: SortOrder[];
}
export interface Pagination {
    size: number;
    page: number;
}
declare class SelectConstraints {
    ignoreCaseFields?: string[];
    orderBy?: OrderBy;
    pagination?: Pagination;
    /**
     *
     * @param options
     * @param options.ignoreCaseFields: string []
     * @param options.orderBy: {fields: string[], order: 'asc' | 'desc'}
     * @param options.pagination: {size: number, page: number}
     */
    constructor(options?: any);
    addIgnoreCaseFields(fieldName: string): SelectConstraints;
}
declare class BulkLoadConstraints {
    replaceStrategy: BulkLoadReplaceStrategy;
    constructor();
    setReplaceAsDeleteInsert(): void;
    isReplaceAsDeleteInsert(): boolean;
    setReplaceAsUpdate(): void;
    isReplaceAsUpdate(): boolean;
    setReplaceAsIgnore(): void;
    isReplaceAsIgnore(): boolean;
}
export interface TxnResult {
    status: boolean;
    message?: string;
    data?: any;
    results?: TxnResult[];
}
export interface PartitionSetting {
    [key: string]: number;
}
export interface DataEntity {
}
export interface TxnOps {
    txnId?: string;
    isSilent?: boolean;
    constraints?: SelectConstraints;
    bulkloadConstraints?: BulkLoadConstraints;
}
export { DataEntityMetadata, PersistMethod, PersistType, SelectConstraints, BulkLoadConstraints, DatabaseMetadata, DataStrategy, SortOrder, SyncMode, EntityType, SchemaType, AnalyzeMethod, IntegratyLevel, BulkLoadReplaceStrategy };
