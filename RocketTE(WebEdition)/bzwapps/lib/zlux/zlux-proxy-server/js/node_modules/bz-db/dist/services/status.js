import { Logger } from './index.js';
import { STATUS } from '../constants/status.js';
import { eventHandler } from '../event/event-handler.js';
class Status {
    constructor() {
        this._status = STATUS.LOADING;
        this._ready = false;
        this._timing = 0;
        this._promise = new Promise(resolve => {
            this._resolver = resolve;
        });
        this._promiseStatus = new Promise(resolve => {
            this._resolverStatus = resolve;
        });
    }
    setObserver(observer) {
        this._observer = observer;
    }
    setUnresolvedPromise() {
        if (this._ready === true) { // make a unresolved promise if it's ready status
            this._promiseStatus = new Promise(resolve => {
                this._resolverStatus = resolve;
            });
            this._ready = false;
        }
    }
    resolvePromise() {
        this._resolver();
    }
    resolveStatusPromise() {
        if (this._ready === false) {
            this._resolverStatus();
            this._ready = true;
            Logger.logInfo(`Ready flag is now: ${this._ready}`);
        }
    }
    get status() {
        return this._status;
    }
    set status(s) {
        if (s === this._status)
            return;
        Logger.logDebug(`Changing local node status from "${this._status}" to "${s}", current ready flag is: ${this._ready}`);
        this._status = s;
        switch (s) {
            case STATUS.LONELY_ISLAND:
            case STATUS.READY: {
                this.resolvePromise();
                this.resolveStatusPromise();
                if (eventHandler.listenStatusMap) {
                    eventHandler.occuredEventMap[STATUS.DATA_CONFLICT] = [];
                }
                this._observer?.next(this._status);
                break;
            }
            case STATUS.DATA_CONFLICT: {
                this.resolvePromise();
                break;
            }
            default: {
                this.setUnresolvedPromise();
            }
        }
    }
    markLoadReady() {
        this.resolvePromise();
    }
    async waitStatusReady() {
        if (!this._ready) {
            const interval = 10000;
            const timing = setInterval(() => {
                this._timing += interval / 1000; // count the seconds waited.
                Logger.logInfo('Awaiting for ready status, seconds: ' + this._timing + ', current status: ' + this._status);
            }, interval);
            await this._promiseStatus;
            clearInterval(timing);
            this._timing = 0;
        }
        return this._status;
    }
    async waitLoadReady() {
        if (!this._ready) {
            const interval = 10000;
            const timing = setInterval(() => {
                this._timing += interval / 1000; // count the seconds waited.
                Logger.logInfo('Awaiting for ready status, seconds: ' + this._timing + ', current status: ' + this._status);
            }, interval);
            await this._promise;
            clearInterval(timing);
            this._timing = 0;
        }
        return this._status;
    }
    get ready() {
        return this._ready;
    }
}
export { Status };
