import { jest } from '@jest/globals'
import path from 'path'
import fse from 'fs-extra'
import { waitTime } from './utiles'
import { fileURLToPath } from 'url'
import { dirname } from 'path'
import { yaml } from '../services/yaml'
import { stringify, parse } from 'yaml'
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const globalAny = global
const BZDB: any = (globalAny as any).BZDB


let metadata: typeof BZDB.DatabaseMetadata;
let bzdb : typeof BZDB.DbManager;
const logConfig = {
    type: process.env.BZ_LOGGER_TYPE,
    logLevels: { // -1-SILENT, 0-SEVERE, 1-WARN, 2-INFO, 3-DEBUG
        default: -1,
        txn: -1,
        metadata: -1,
        cluster: -1,
        checkin: -1,
        pull: -1,
        performance: -1
    }
}

jest.setTimeout(20000)

beforeAll(async () => {
    const dbFolder = 'utdata'
    fse.removeSync(path.join(__dirname, `../../${dbFolder}`));
    metadata = new BZDB.DatabaseMetadata({
        storePath: `./${dbFolder}`,
        processPooling: 0,
        logging: logConfig,
        rejectPKonUpdate: true,
        dataEntities: [
            {name: 'testde', primaryKeys:['id']},
            {
                name: 'testNoCache', 
                primaryKeys:['id'],
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
            },
            {
                name: 'testGiveName', 
                persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                filePath: '/testGiveName',
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
            },
            {
                name: 'upload',
                persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                filePath: '/upload',
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
                persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
            },
            {
                // BZ-15480, support single raw file entity 
                name: 'upload-single',
                primaryKeys: [],
                persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
                filePath: 'upload-single',
                fileName: 'bluezone.lic',
                dataStrategy: BZDB.DataStrategy.NO_CACHE,
                persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
            }
        ],
        onLoadReady: (results: any) => {
            console.log('onLoadReady results: ' + JSON.stringify(results));
        }
    });
    bzdb = BZDB.loadDatabase(metadata)
    await bzdb.waitLoadReady();
})

// afterAll(async (done) => {
//     console.log('Done with index.js testing')
//     done()
//     await waitTime()
//     // process.exit(0) // The test doesn't stop, so forcing it to exit. // TBD, should research why it doesn't stop after bzdb.stop()
// })

describe('loading ', () => {

    test('Database should be loaded', async () => {
        await bzdb.waitLoadReady();
        expect.assertions(1);
        expect(bzdb).toBeInstanceOf(BZDB.DbManager);
        return
    })
    
    test('Data entity should be loaded', async () => {
        expect.assertions(2);
        const testData = await bzdb.select('testde');
        expect(testData).toBeTruthy();
        expect(testData.dataEntityName).toBe('testde');
        return
    })
});


/**
 * Insert
 */

  describe('Insert', () => {
    
     test('Insert should success', async () => {
         expect.assertions(5);
         const insertData = {id: '1', name: 'Tom'};
         await bzdb.delete('testde', {id: '1'});
         const result = await bzdb.insert('testde', insertData);
         expect(result).toBeTruthy();
         const selData = await bzdb.select('testde', {id: '1'});
        //  console.log('selData: ' + JSON.stringify(selData));
         expect(selData).toBeTruthy();
         expect(selData.rowCount).toBe(1);
         expect(selData.dataEntityName).toBe('testde');
         expect(selData.data[0]).toEqual(insertData);
         await bzdb.delete('testde');
     })
    
 });

describe('Insert with fileName', () => {
    
    test('Insert with fileName should success', async () => {
        expect.assertions(7);
        const insertData = {fileName:'giveAname.json', data:{id: '1', name: 'Tom'}};
        const result = await bzdb.insert('testGiveName', insertData);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('testGiveName', {fileName:insertData.fileName});
        // console.log('selData: ' + JSON.stringify(selData));
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('testGiveName');
        expect(selData.data[0]).toEqual(insertData.data);
        await bzdb.delete('testGiveName',{fileName:insertData.fileName});
        const selData0 = await bzdb.select('testGiveName', {fileName:insertData.fileName});
        // console.log('selData0: ' + JSON.stringify(selData0));
        expect(selData0).toBeTruthy();
        expect(selData0.rowCount).toBe(0);
    });
    test('delete by file name should success', async () => {
        expect.assertions(2);
        const insertData = {fileName:'giveAname.json'};
        await bzdb.delete('testGiveName',{fileName:insertData.fileName});
        const selData = await bzdb.select('testGiveName', {fileName:insertData.fileName});
        // console.log('selData0: ' + JSON.stringify(selData));
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(0);
    })
    
});

describe('raw file', () => {
    
    test('insert raw file should success', async () => {
        expect.assertions(5);
        let testStr="this is a file upload test"
        let bufData = Buffer.from(testStr,'utf8');
        let bufDataStr=JSON.stringify(bufData);
        const insertData = {fileName:'giveAname.txt', data:bufDataStr};
        const result = await bzdb.insert('upload', insertData);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload', {fileName:insertData.fileName});
        // console.log('==========selData: ' + JSON.stringify(selData));
        // console.log('======bufDataStr: ' + bufDataStr);
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.dataEntityName).toBe('upload');
        expect(selData.data[0].data).toEqual(bufDataStr);
    });
    test('delete raw file should success', async () => {
        expect.assertions(2);
        const insertData = {fileName:'giveAname.txt'};
        await bzdb.delete('upload',{fileName:insertData.fileName});
        const selData = await bzdb.select('upload', {fileName:insertData.fileName});
        // console.log('selData0: ' + JSON.stringify(selData));
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(0);
    });
    test('insert again should success', async () => {
        expect.assertions(3);
        let testStr="this is test for insert again"
        let bufData = Buffer.from(testStr,'utf8');
        let bufDataStr=JSON.stringify(bufData);
        const insertData = {fileName:'insertAgain.txt', data:bufDataStr};
        const result = await bzdb.insert('upload', insertData);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload', {fileName:insertData.fileName});
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
    });
    
});

describe('single raw file', () => {
    
    test('insert should work well', async () => {
        expect.assertions(4);
        const bufData = { data: JSON.stringify(Buffer.from("11111111",'utf8')) };
        //const testData = { data: bufDataStr };
        // insert
        const result = await bzdb.insert('upload-single', bufData);
        expect(result).toBeTruthy();
        // select
        const selData = await bzdb.select('upload-single');
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.data[0].data).toEqual(bufData.data);
    });
    test('updateOrInsert should work well', async () => {
        // updateOrinsert
        expect.assertions(4);
        const bufData = { data: JSON.stringify(Buffer.from("2222222",'utf8'))};
        const result = await bzdb.updateOrInsert('upload-single', bufData);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload-single');
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.data[0].data).toEqual(bufData.data);
    });
    test('delete should work well', async () => {
        // delete
        expect.assertions(3);
        const result = await bzdb.delete('upload-single'); 
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload-single');
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(0);
    });
    test('bulkload should work', async () => {
        // bulkload
        expect.assertions(4);
        const bufData = { data: JSON.stringify(Buffer.from("333333333",'utf8'))};
        const data:any[] = [];
        data.push(bufData);
        const result = await bzdb.bulkLoad('upload-single', data);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload-single');
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.data[0].data).toEqual(bufData.data);
    });
    test('insert again should work well', async () => {
        // insert again
        expect.assertions(4);
        const bufData = { data: JSON.stringify(Buffer.from("4444444444",'utf8'))};
        const result = await bzdb.insert('upload-single', bufData);
        expect(result).toBeTruthy();
        const selData = await bzdb.select('upload-single');
        expect(selData).toBeTruthy();
        expect(selData.rowCount).toBe(1);
        expect(selData.data[0].data).toEqual(bufData.data);
        await bzdb.delete('upload-single'); 
    });
});

/**
 * Update
 */
describe('Update', () => {
    
    test('Update should success', async () => {
        expect.assertions(5);
        const filter = {id: '1'};
        const value = {id:'1', name:'Jerry'};
        await bzdb.delete('testde', filter);
        await bzdb.insert('testde', value);
        const updateValue = {name: 'Tom'};
        const result = await bzdb.update('testde', filter, updateValue);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        const selectResult = await bzdb.select('testde', filter);
        expect(selectResult.rowCount).toBe(1);
        expect(selectResult.dataEntityName).toBe('testde');
        expect(selectResult.data[0].name).toEqual('Tom');
        await bzdb.delete('testde');
    })
});

/**
 * UpdateOrInsert
 */
describe('UpdateOrInsert', () => {

    test('UpdateOrInsert should do Insert', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        await bzdb.delete('testde', filter);
        const result = await bzdb.updateOrInsert('testde', value);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(value);
        await bzdb.delete('testde');
    })
    
    
    test('UpdateOrInsert should do Update', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        const value = {id: '1', name: 'Tom'};
        const valueUpdate = {id: '1', name: 'Jerry'};
        await bzdb.delete('testde', filter);
        await bzdb.insert('testde', value);
        const result = await bzdb.updateOrInsert('testde', valueUpdate);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult.data).toBeTruthy();
        expect(selectResult.data[0]).toEqual(valueUpdate);
        await bzdb.delete('testde');
    })

});

/**
 * Delete
 */
describe('Delete', () => {
    
    test('Delete should success when filter with primary key', async () => {
        expect.assertions(4);
        const filter = {id:'1'};
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id: '1', name: 'Tom'});
        await bzdb.insert('testde', {id: '2', name: 'Jerry'});
        await bzdb.insert('testde', {id: '3', name: 'Jim'});
        const result = await bzdb.delete('testde', {id:'1'});
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', filter);
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(0);
        await bzdb.delete('testde');
    })

});

/**
 * Bulkload
 */

describe('Bulkload', () => {
    test('Bulkload should success', async () => {
        expect.assertions(6);
        // metadata.setDataEntity(
        //     {name:'testde', 
        //     primaryKeys:['id1', 'id2'], 
        //     indexes:{'id1':['id1']}}
        // );
        // bzdb = await BZDB.loadDatabase(metadata);
        // const filter = {id1:'1'};
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id: '1', name: 'Tom'});
        await bzdb.insert('testde', {id: '2', name: 'Jim'});
    
        const loadData = [
            {id: '1', name: 'Tom'},
            {id: '1', name: 'Jerry1'},
            {id: '2', name: 'Jerry'},
            {id: '3', name: 'Jimmy'},
            {id: '3', name: 'Nancy'},
            {id: '4'}
        ];
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.bulkLoad('testde', loadData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', {id: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(4);
        await bzdb.delete('testde');
    })

});


/**
 * Bulkload
 */

 describe('BatchTxn', () => {
    test('BatchTxn should success', async () => {
        expect.assertions(7);
        await bzdb.delete('testde');
    
        const batchTxnData: (typeof BZDB.BatchTxnData)[] = [
            {dataEntityName:"testde", action:"DELETE"},
            {dataEntityName:"testde", action:"INSERT", value:{id: '1', name: 'Jimmy'}},
            {dataEntityName:"testde", action:"INSERT", value:{id: '2', name: 'Jerry'}},
            {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '3', name: 'Nancy'}},
            {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '1', name: 'Tom'}},
            {dataEntityName:"testde", action:"UPDATEORINSERT", value:{id: '4', name: 'Jimmy'}},
            {dataEntityName:"testde", action:"DELETE", value:{}, options:{filter:{id: '4'}}}
        ];
        // let selectResult1 = bzdb.selectSync('testde');
        // console.log('selectResult1: ' + selectResult1);
        const result = await bzdb.batchTxn(batchTxnData);
        expect(result).toBeTruthy();
        expect(result.status).toBeTruthy();
        let selectResult = await bzdb.select('testde', {id: '1'});
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(1);
        selectResult = await bzdb.select('testde');
        expect(selectResult).toBeTruthy();
        expect(selectResult.rowCount).toEqual(3);
        const tom = selectResult.data[0].name
        expect(tom).toEqual('Tom');
        await bzdb.delete('testde');
    });

});


describe('select', () => {
    
    test('Select return correct data that match to filter with ignore case fields', async () => {
        expect.assertions(3);
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id: '1', name: 'Tom'});
        await bzdb.insert('testde', {id: '2', name: 'Jerry'});
        await bzdb.insert('testde', {id: '3', name: 'Jim'});
        const options = new BZDB.SelectConstraints().addIgnoreCaseFields('name');;
        const data = await bzdb.select('testde', {name: 'tom'}, options);
        expect(data).toBeTruthy();
        expect(data.rowCount).toEqual(1);
        expect(data.data[0]['name']).toEqual('Tom');
        await bzdb.delete('testde');
    })

    
});

describe('count', () => {
    
    test('count works for normal DE', async () => {
        expect.assertions(3);
        await bzdb.delete('testde');
        await bzdb.insert('testde', {id: '1', name: 'Tom'});
        await bzdb.insert('testde', {id: '2', name: 'Jerry'});
        await bzdb.insert('testde', {id: '3', name: 'Jim'});
        const data = await bzdb.count('testde');
        expect(data).toBeTruthy();
        expect(data.status).toBe(true);
        expect(data.rowCount).toBe(3);
        await bzdb.delete('testde');
    })

    // TBD, count not working for NO_CACHE
    // test('count works for NO_CACHE DE', async () => {
    //     expect.assertions(2);
    //     console.log('11111111111111111111111');
    //     await bzdb.delete('upload');
    //     console.log('22222222222222222222222');
    //     let testStr="this is a file upload test"
    //     let bufData = Buffer.from(testStr,'utf8');
    //     let bufDataStr=JSON.stringify(bufData);
    //     await bzdb.insert('upload', {fileName:'giveAname.txt', data:bufDataStr});
    //     await bzdb.insert('upload', {fileName:'giveAname1.txt', data:bufDataStr});
    //     const selData = await bzdb.count('upload');
    //     console.log('selData: ' + JSON.stringify(selData));
    //     expect(selData).toBeTruthy();
    //     expect(selData.status).toBe(true);
    //     // expect(selData.rowCount).toBe(2); // TBD, should be fixed
    // })
    
});

describe('uid', () => {
    test('UID should be an unique string', () => {
        expect.assertions(100)
        const uids:string[] = []
        for (let i = 0; i < 100; i ++){
            const uid = bzdb.getUIDSync()
            expect(uids.includes(uid)).toBe(false)
            uids.push(uid)
        }
    })
    
    test('UID could accept radix', () => {
        expect.assertions(3)
        expect(bzdb.getUIDSync(10)).toBeTruthy()
        expect(bzdb.getUIDSync(1)).toBeTruthy()
        expect(bzdb.getUIDSync(37)).toBeTruthy()
    })
    
    test('UID could accept level', () => {
        expect.assertions(18)
        let uid = bzdb.getUIDSync(36, 0)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(2)
        uid = bzdb.getUIDSync(36, 1)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(2)
        uid = bzdb.getUIDSync(36, 2)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(3)
        uid = bzdb.getUIDSync(36, 3)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(4)
        uid = bzdb.getUIDSync(36, 4)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(5)
        uid = bzdb.getUIDSync(36, 5)
        expect(uid).toBeTruthy()
        expect(typeof(uid)).toBe('string')
        expect(uid.split('-').length).toBe(5)
    })
})


describe('yaml', () => {

    const yaml_str = 
`# A commented document

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ss-rtew # name of ss
  namespace: termbz
spec:
  selector:
    matchLabels:
      app: rtew
  serviceName: svc-rtew-headless
  replicas: 1
  minReadySeconds: 10
  template:
    metadata:
      labels:
        app: rtew
    spec:
      # specification for pod
      terminationGracePeriodSeconds: 10
      containers:
        - name: rtew
          image: 363261076729.dkr.ecr.us-east-1.amazonaws.com/termbz:latest
          ports:
            - containerPort: 8543 # http
            - containerPort: 8643 # cluster
`

    test('bzdb.yamlStrToJson', async () => {
        const json = await bzdb.yamlStrToJson(yaml_str)
        expect(Object.keys(json).length).toBe(5)
        expect(json.kind).toBe('StatefulSet')
        expect(json.spec.template.spec.containers.length).toBe(1)
        expect(json.spec.template.spec.containers[0].ports[0].containerPort).toBe(8543)
        expect(json.__bzdb_yaml_metadata.comments.length).toBe(5)
    })

    test('bzdb.jsonToYAMLStr', async () => {
        const json = await bzdb.yamlStrToJson(yaml_str)
        const yamlStr = yaml.jsonToYAMLStr(json)
        expect(yamlStr).toEqual(yaml_str)
    })

    test('bzdb.yamlParse', async () => {
        const json = await bzdb.yamlParse(yaml_str)
        const json1 = parse(yaml_str)
        expect(json).toEqual(json1)
    })

    test('bzdb.yamlStringify', async () => {
        const json = await bzdb.yamlParse(yaml_str)
        const str = await bzdb.yamlStringify(json)
        const str2 = stringify(json)
        expect(str).toBe(str2)
    })
})


describe('DB Stop',  () => {
    test('DB should stop', async () => {
        await bzdb.waitLoadReady();
        await bzdb.stop()
        process.stdout.removeAllListeners()
        process.stderr.removeAllListeners()
        process.stdin.removeAllListeners()
        process.stdin.push(Buffer.from([0x0D, 0x0A]))
        await waitTime()
        // done()
        // process.exit(0) // The test doesn't stop, so forcing it to exit. // TBD, should research why it doesn't stop after bzdb.stop()
    })
})
