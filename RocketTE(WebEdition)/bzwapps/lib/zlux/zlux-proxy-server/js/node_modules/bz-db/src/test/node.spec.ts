import { jest } from '@jest/globals'
import fse from 'fs-extra'
import path from 'path'
// import { waitTime } from './utiles'

import { fileURLToPath } from 'url';
import { dirname } from 'path';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const globalAny = global
const BZDB: any = (globalAny as any).BZDB

jest.setTimeout(120000)


let metadata1: any;
let metadata2: any;
let bzdb : any;
let bzdbpeer : any;
const logConfig = {
    type: process.env.BZ_LOGGER_TYPE,
    logLevels: { // -1-SILENT, 0-SEVERE, 1-WARN, 2-INFO, 3-DEBUG
        default: -1,
        txn: -1,
        metadata: -1,
        cluster: -1,
        checkin: -1,
        pull: -1,
        performance: -1
    }
}

const metaobj = {
    storePath: './utdatanode/peer1',
    processPooling: 0,
    rejectPKonUpdate: true,
    logging: logConfig,
    enableWorkerThread: false,
    dataEntities: [
        {name: 'testde', primaryKeys:['id']},
        {name: 'testde1', primaryKeys:['id']},
        {name: 'testde2', primaryKeys:['id']},
        {
            name: 'testGiveName', 
            primaryKeys:[],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: '/testGiveName',
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
        },
        {
            name: 'upload',
            primaryKeys:[],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            filePath: '/upload',
            dataStrategy: BZDB.DataStrategy.NO_CACHE,
            persistType:BZDB.PersistType.PERSIST_TYPE_RAW,
        },
        {name: 'testLocalData', primaryKeys:['id'], syncMode: BZDB.SyncMode.SYNC_LOCAL},
        {
            name: 'fileSync',
            primaryKeys: ['relative_path'],
            persistMethod: BZDB.PersistMethod.PERSIST_METHOD_LIST_FILE,
            persistType: BZDB.PersistType.PERSIST_TYPE_ARRAY,
            fileName: 'fileSync.json',
            syncFile4Cluster: true
        }
    ],
    onLoadReady: (results: any) => {
        console.log('onLoadReady results: ' + JSON.stringify(results))
    }
}
const metaobj2 = JSON.parse(JSON.stringify(metaobj))
metaobj2.storePath = './utdatanode/peer2'
// console.log(metaobj)
// console.log(metaobj2)
metadata1 = new BZDB.DatabaseMetadata(metaobj)
metadata2 = new BZDB.DatabaseMetadata(metaobj2)

const peer1dir = path.resolve(__dirname, '../../utdatanode/peer1')
const peer2dir = path.resolve(__dirname, '../../utdatanode/peer2')


beforeAll(() => {
    if (fse.existsSync(peer1dir)){
        fse.removeSync(peer1dir)
    }
    if (fse.existsSync(peer2dir)){
        fse.removeSync(peer2dir)
    }
}, 30000)

describe('Port', () => {

    test('Port should be 8643 for first startup', async () => {
        expect.assertions(1)
        bzdb = BZDB.create(metadata1)
        await bzdb.waitLoadReady()
        const nodeInfo = (await bzdb.select('meta_node')).data[0]
        expect(nodeInfo.port).toBe(8643)
    })
    
    test('Port should be 8644 for first startup of peer', async () => {
        expect.assertions(1)
        bzdbpeer = BZDB.create(metadata2)
        await bzdbpeer.waitLoadReady()
        const nodeInfo = (await bzdbpeer.select('meta_node')).data[0]
        expect(nodeInfo.port).toBe(8644)
    }, 30000)

    test('Singleton should start in case port in use', async () => {
        expect.assertions(8)
        await bzdb.stop()
        await bzdbpeer.stop()
        
        if (fse.existsSync(peer2dir)){ // clear the data of bzdbpeer
            fse.removeSync(peer2dir)
        }

        bzdbpeer = BZDB.create(metadata2) // let bzdbpeer listen to 8643
        await bzdbpeer.waitLoadReady()

        const nodeInfoPeer = (await bzdbpeer.select('meta_node')).data[0]
        expect(nodeInfoPeer.port).toBe(8643)

        bzdb = BZDB.create(metadata1) // start bzdb on the same port
        await bzdb.waitLoadReady()

        const nodeInfo = (await bzdb.select('meta_node')).data[0]
        expect(nodeInfo.port).toBe(8643)
        
        const bzdbStatus = await bzdb.getStatus()
        expect(bzdbStatus).toBe('ready')
        
        const bzdbStatus1 = await bzdb.checkStatus()
        expect(bzdbStatus1).toBeTruthy()
        expect(bzdbStatus1.status).toBe(true)
        expect(bzdbStatus1.data[0].listening).toBe(false)
        expect(bzdbStatus1.data[0].inNet).toBe(false)
        expect(bzdbStatus1.data[0].isLocal).toBe(true)
    }, 30000)
})

afterAll((done) => {
    // console.log('Node testing done')
    done()
})