import { Logger, uid } from '../services/index.js'
import { ITaskOptions, Task } from './task.js'
import { TaskQueue } from './task-queue.js'
import { CONFIG } from '../constants/config.js'

export interface ITaskCreationOptions {
    timeoutMs?: number
    desc?: string
    workflow?: Workflow
    parentId?: string
    groups?: string[]
}

class Workflow {

    _queue: TaskQueue
    _tasks: Map<string, Task>
    _timeouts: Map<string, any>
    _tasksLifeTime: Map<string, number>
    _groups: Map<string, Map<string, Task>>

    constructor(){
        this._queue = new TaskQueue()
        this._tasks = new Map()
        this._timeouts = new Map()
        this._tasksLifeTime = new Map()
        this._groups = new Map()
    }

    createTask(id: string, options: ITaskCreationOptions, fun: Function) {
        options['workflow'] = this
        const t = new Task(id, options as ITaskOptions, fun)
        const groups = options.groups && options.groups.length > 0 ? options.groups: undefined
        if (groups) { // The task is in group
            for (const group of groups) {
                let tasksInGroup = this._groups.get(group)
                if (!tasksInGroup) {
                    tasksInGroup = new Map<string, Task>()
                    this._groups.set(group, tasksInGroup)
                }
                tasksInGroup.set(t.id, t) // Records the task into group.
            }
        }
        t.once('finally', () => {
            Logger.logDebug('Finally of task: ' + t.description)
            if (groups) { // The task is in group
                for (const group of groups) {
                    let tasksInGroup = this._groups.get(group)
                    if (tasksInGroup) {
                        tasksInGroup.delete(t.id) // Delete the task from group when it's resolved.
                    }
                }
            }
            t.destroy()
            Logger.logDebug('Task size: ' + this.getTaskSize())
            this.describeTasks(false)
            Logger.logDebug('Queue stats: ' + JSON.stringify(this.getQueueStats()))
        })
        this._tasks.set(id, t)
        Logger.logDebug('Task size: ' + this.getTaskSize())
        this.describeTasks(false)
        return t
    }

    // Gets all the tasks currently in the group.
    getGroupTasks(groups: string[]) {
        const result: any = {}
        if (groups && groups.length > 0) {
            for (const group in groups) {
                const tasksInGroup = this._groups.get(group)
                if (tasksInGroup) {
                    result[group] =  Array.from(tasksInGroup.values())
                }
            }
        }
        return result
    }

    // Waits for the groups of tasks to finish.
    async waitForTaskGroups(groups: string[]) {
        const proms = []
        let msg = 'Waiting for task groups:'
        for (const group of groups){
            const tasksInGroup = this._groups.get(group)
            if (tasksInGroup && tasksInGroup.size > 0) {
                msg += ' > ' + group + ' - ' + tasksInGroup.size
                for (const task of tasksInGroup.values()) {
                    proms.push(task.getPromise())
                }
            }
        }
        if (proms.length > 0){
            Logger.logInfo(msg)
            await Promise.all(proms)
        }
    }

    /**
     * Generate a new task to run the given function. Use the given ID or otherwise generate an id if it's not provided.
     */
    generateTask(options: ITaskCreationOptions, fun: Function, id?: string){
        // let tid = Date.now().toString()
        // while(this.getTask(tid)){ // avoid duplicated id of task
        //     tid += '+'
        // }
        const tid = id? id: uid.generate(CONFIG.UID_NUMBER_STR_RADIX, 1) // tid is: timestamp + internal sequence
        return this.createTask(tid, options, fun)
    }

    getTask(id: string){
        return this._tasks.get(id)
    }

    isOverwhelmed(){
        Logger.logDebug('Tasks size: ' + this._tasks.size)
        return this._tasks.size > CONFIG.TASK_MAX_COUNT
    }

    describeTasks(isInfo = true){
        const size = this.getTaskSize()
        const keys = Array.from(this._tasks.keys()).sort()
        let desc = 'Describing tasks: \n'
        desc += 'Count: ' + size
        keys.forEach(key => {
            desc += '\nTask ID: ' + key +' - ' + this.getTask(key)?.description
        })
        if (isInfo){
            Logger.logInfo(desc)
        } else {
            Logger.logDebug(desc)
        }
    }

    existsTaskDesc(desc: string){
        for (const t of Array.from(this._tasks.values())){
            const desct = t.description
            if (desct.includes(desc)){
                return true
            }
        }
        return false;
    }

    searchTaskDesc(desc: string): Task[]{
        const tasksArr: Task[] = []
        for (const t of Array.from(this._tasks.values())){
            const desct = t.description
            if (desct.includes(desc)){
                tasksArr.push(t)
            }
        }
        return tasksArr;
    }

    async enqueueTask(task: Task){
        return await this._queue.push(task)
    }

    async executeTask(task: Task){
        return await task.execute()
    }

    async bookTask(task: Task, timeout: number){
        const tmo = setTimeout(async () => {
            await task.execute()
            task.resolve({status: true})
        }, timeout)
        this._timeouts.set(task.id, tmo)
        task.once('destroy', () => {
            this._timeouts.delete(task.id)
            clearTimeout(tmo)
        })
    }

    getTaskSize(){
        return this._tasks.size
    }

    getQueueStats(){
        return this._queue._q.getStats()
    }

    destroy(){
        this._tasks.forEach((task) => {
            task.destroy()
        })
    }

    getPerfRecords(){
        return this._tasksLifeTime
    }
}

export {
    Workflow
}