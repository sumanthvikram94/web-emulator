/**
 * Main entry for bz-db functions. This worker could run in seperate thread or in the main thread.
 */
import { Observable } from 'threads/observable';
import { DatabaseInterface, BatchTxnData, InternalDatabaseInterface } from './db-interface.js';
import { DatabaseMetadata, DataEntityMetadata } from './metadata.js';
import { PrivateNet } from '../distribution/private-net.js';
import { Task, Workflow } from '../workflow/index.js';
import { BlockChain, BlockChainStat } from '../blockchain/blockchain.js';
import { Block } from '../blockchain/block.js';
import { Status, ILoggerConfig } from '../services/index.js';
import { SelectConstraints, BulkLoadConstraints } from './metadata.js';
import { IPeerMeta } from '../distribution/node-metadata.js';
import { DEPartitions, DEStatistics } from '../internal-db/data-entity.js';
import { FileSyncInfo, FileSyncMsg, FileSync } from './file-sync.js';
declare class DbWorker implements DatabaseInterface {
    [key: string]: any;
    _dbMeta: DatabaseMetadata;
    _metaNames: string[];
    _internalDb: InternalDatabaseInterface;
    _externalDb: InternalDatabaseInterface;
    _pNet: PrivateNet;
    _workflow: Workflow;
    _workflow_exec: Workflow;
    _chains: Map<string, BlockChain>;
    _fileSync: FileSync;
    _status: Status;
    _regCmd: Map<string, Function>;
    _txnRedundent: number;
    _executingBlocks: Map<string, any>;
    _executingStats: Map<string, any>;
    _taskSender: TaskSender;
    _conflictManager: ConflictManager;
    constructor();
    get taskSender(): TaskSender;
    get statusService(): Status;
    get appName(): string;
    get hostSpicificIp(): string;
    configLogging(logging: any): void;
    private initProperties;
    /**
     * Starts the db worker
     * @param dbMeta
     * @returns
     */
    start(dbMeta: object): Promise<string>;
    getStatusObservable(): Observable<unknown>;
    /**
     * Stops the node listener
     */
    stop(): Promise<void>;
    get workflow(): Workflow;
    get workflowExec(): Workflow;
    private addNetMeta;
    private loadExtendEntity;
    private _setBlockEntity;
    /**
     * Parse the chains data as BlockChains, and store in memory
     */
    private loadChains;
    private loadChain;
    /**
     * Replace the local chains with the chains provided
     * @param chains
     * @returns
     */
    replaceChains(chains: Array<any>, taskId: string): Promise<any>;
    /**
     * updates the txn redundent for all chains
     */
    updateBCRedundents(): void;
    /**
     * Append the missed blocks to the local chains
     * @param peer: BZ-15355, sync file for cluster
     * @param chains
     */
    appendChains(peer: IPeerMeta, chains: Array<any>, txnId: string): Promise<void>;
    execFileTransferForBlock(blocks: Block[], subject: string): Promise<void>;
    waitForExecutingBlocks(): Promise<true | any[]>;
    /**
     * Append the missed blocks to the local chains
     * @param chains
     */
    appendBlocks(blocks: Map<string, Block[]>, txnId: string): Promise<{
        status: boolean;
        message: string;
        results: any[];
    }>;
    clearChainsHist(): Promise<void>;
    /**
     * Replace local data with the data provided
     * @param peer: BZ-15355, sync file for cluster
     * @param data
     */
    replaceData(peer: IPeerMeta, data: any, taskId: string): Promise<void>;
    get chains(): Map<string, BlockChain>;
    /**
     * calculates the BlockChainStat for block chains comparison
     * @returns
     */
    doGetChainsStat(peerChainsStat?: Map<string, BlockChainStat>, peerId?: string, taskId?: string): Promise<{
        stats: Map<string, BlockChainStat>;
        isConflict: boolean;
    }>;
    /**
     *
     * @param type : 'db' or 'chain' or 'both'
     * @param peerChainsStat
     * @returns
     */
    getStatistics(type: string | undefined, taskId: string, peerChainsStat?: Map<string, BlockChainStat>, peerId?: string): Promise<any>;
    waitForStatistics(): Promise<true | any[]>;
    /**
     * Calculates the BlockChainStat and DBStat for data comparison
     * @returns
     */
    doGetChainsAndDBStat(peerChainsStat?: Map<string, BlockChainStat>, peerId?: string, taskId?: string): Promise<{
        chain: {
            stats: Map<string, BlockChainStat>;
            isConflict: boolean;
        };
        db: Map<string, DEStatistics>;
    }>;
    /**
     * calculates the BlockChainStat for block chains comparison
     * @returns
     */
    /**
     * Summary the total size of all chains.
     */
    get chainsSize(): number;
    getStatus(): string;
    printClusterStatus(): Promise<void>;
    set status(s: string);
    findChain(subject: string): BlockChain;
    /**
     * Starts the local node and checkin
     */
    joinPNet(): Promise<void>;
    waitCluster(): Promise<void>;
    /**
     * Get whether the dataentity stores in internal DB
     * @param de
     * @returns
     */
    isInternalDb(de: string): boolean | undefined;
    private isTxnApproved;
    private isBatchTxnApproved;
    private getRejectedChain;
    private blocksNotRejected;
    clearPendingBlockForBatchTxn(blocks: Map<string, Block[]>): void;
    createBatchTxnProcess(blocks: Map<string, Block[]>, txnId: string): Promise<Task>;
    /**
     * Creates the task for a transaction, like insert, updateOrInsert etc.
     * @param block
     * @param chain
     * @returns
     */
    createTxnProcess(block: Block, chain: BlockChain, txnId: string, neverGiveUp?: boolean): Promise<Task>;
    private isWeekIntegraty;
    /**
     * Handling a transaction, e.g. insert, updateOrInsert etc.
     * @param dataEntityName
     * @param action
     * @param value
     * @param options
     * @returns
     */
    handleTxn(dataEntityName: string, action: string, value: any, options: any): Promise<any>;
    appendLostBlocks(chain: BlockChain, block: Block, txnId: string): Promise<{
        status: boolean;
        message: string;
    } | {
        status: boolean;
        message?: undefined;
    }>;
    validateBlock(chain: BlockChain, block: Block, txnId: string): Promise<{
        status: boolean;
        message: string;
    } | {
        status: boolean;
        message?: undefined;
    }>;
    /**
     * Appends a block to chain, and do the transaction of the block
     * @param chain
     * @param block
     * @param isFromPeer: whether the block is sent from other peer
     * @returns
     */
    appendBlock(chain: BlockChain, block: Block, isFromPeer: boolean | undefined, txnId: string): Promise<any[]>;
    /**
     * BZ-15355, sync file for cluster
     * Check if entity support file sync
     * @param subject: entity name
     */
    private isSupportFileSync;
    /**
    * BZ-15355, sync file for cluster
    * Perform file sync action
    * @param peer
    * @param dataArr
    */
    sendFileSyncMsg(peer: IPeerMeta, fsiMsgArr: FileSyncMsg[]): Promise<void>;
    /**
     * BZ-15355, sync file for cluster
     * Perform file sync action
     * @param peer
     * @param dataArr
     */
    private performFileSync;
    /**
     * BZ-15355, sync file for cluster
     * check the block if we need sync files
     * @param peer
     * @param subject: entity name
     * @param block: block
     */
    checkFileSync4Block(/*peer: NodeInfo,*/ subject: string, block: Block): FileSyncMsg[];
    /**
     * BZ-15355, sync file for cluster
     * check file sync for blukLoad
     * @param peer
     * @param subject: entity name
     * @param dataArr
     */
    checkFileSync4BulkLoad(/*peer: NodeInfo,*/ subject: string, dataArr: Array<any>): FileSyncMsg[];
    /**
     * Expose the getFileSyncInfo function to db manager.
     * @param filePath
     * @param isSync4Add
     * @returns
     */
    getFileSyncInfo(filePath: string, isSync4Add?: boolean): FileSyncInfo;
    /**
     * BZ-15355, sync file for cluster
     * sync [add/update/delete] arbitrary file to other cluster nodes
     * @param filePath absulute file path
     */
    testSyncArbitraryFile(filePath: string, subject: string, isAdd: boolean): Promise<any>;
    /**
     * Generates ID for transaction.
     * @returns
     */
    genTaskId(): string;
    genTaskIdShort(): string;
    batchTxn(txns: BatchTxnData[]): Promise<any>;
    injectTimestamp(dataEntityName: string, value: any): void;
    refreshDataEntity(dataEntityName: string): Promise<any>;
    /**
     * API entry of DB, insert
     * @param dataEntityName
     * @param value
     * @returns
     */
    insert(dataEntityName: string, value: any, isSilent?: boolean, taskId?: string, neverGiveUp?: boolean): Promise<any>;
    /**
     * API entry of DB, update
     * @param dataEntityName
     * @param filter
     * @param value
     * @param constraints
     * @returns
     */
    update(dataEntityName: string, filter: any, value: any, constraints?: SelectConstraints, isSilent?: boolean): Promise<any>;
    /**
     * API entry of DB, delete
     * @param dataEntityName
     * @param filter
     * @param constraints
     * @returns
     */
    delete(dataEntityName: string, filter?: any, constraints?: SelectConstraints, isSilent?: boolean, taskId?: string): Promise<any>;
    /**
     * API entry of DB, updateOrInsert
     * @param dataEntityName
     * @param value
     * @returns
     */
    updateOrInsert(dataEntityName: any, value: any, isSilent?: boolean): Promise<any>;
    /**
     * API entry of DB, bulkLoad
     * @param dataEntityName
     * @param values
     * @param constraints
     * @returns
     */
    bulkLoad(dataEntityName: string, values: any[], constraints?: BulkLoadConstraints, isSilent?: boolean): Promise<any>;
    /**
     * !!!!  Deprecated !!!!
     * This should be used inside BZDB only. We will not expose a sycn function for select.
     * @param dataEntityName
     * @param filter
     * @param options
     * @returns
     */
    selectSync(dataEntityName: string, filter?: Object, options?: Object): any;
    /**
     * API entry of DB, select
     * @param dataEntityName
     * @param filter
     * @param options
     * @returns
     */
    select(dataEntityName: string, filter?: Object, options?: any): Promise<any>;
    partitions(dataEntityName: string): Promise<DEPartitions>;
    writePartitions(parts: DEPartitions): Promise<any>;
    /**
     * API entry of DB, select
     * @param dataEntityName
     * @returns
     * return data with fileName
     */
    selectNoPKData(dataEntityName: string): Promise<any>;
    /**
     * API entry of DB, count
     * @param dataEntityName
     * @returns
     * return data with fileName
     */
    count(dataEntityName: string): Promise<any>;
    /**
     * API entry of DB, waitLoadReady.
     * Resolves a promise when the DB loading completes, includes internal DB loading, local node starting, and network checkin
     * @returns
     */
    waitLoadReady(): Promise<string>;
    waitStatusReady(): Promise<string>;
    getUID(radix?: number, level?: number): Promise<string>;
    /**
     * In case you want to execute a function on other peers, you can register the function as a command, then call it with exec(cmd)
     * @param cmd
     * @param execFunction
     * @returns
     */
    registerCommand(cmd: string, execFunction: Function): Promise<Map<string, Function>>;
    /**
     * Executes a command on a node and return the output
     * @param cmd
     * @param peerId
     */
    exec(cmd: string, parames?: any[], peerId?: string): Promise<any>;
    /**
     * Creates the Transaction instance. This is the transaction inside Block
     * @param subject
     * @param type
     * @param data
     * @param options
     * @returns
     */
    private createTxn;
    /**
     * Check whether the data entity can use partitions for force pull
     * @param metadata
     * @returns
     */
    isApplyToPartition(metadata: DataEntityMetadata): boolean;
    /**
     * Returns the whole data of internalDB, purpose is to provide whole data for full pull.
     */
    getDbSnapshot(): Promise<any[]>;
    /**
     * Kick a node out of private net
     * @param peerInfo
     * @returns
     */
    kickNode(peerInfo: IPeerMeta): Promise<any>;
    /**
     * deleta all data in the data entities of memory only and local.
     */
    clearLocalDE(): Promise<void>;
    /**
     * Introduce a new node into the private net
     * @param peerInfo
     * @returns
     */
    introduceNode(peerInfo: IPeerMeta): Promise<{
        status: boolean;
        message?: undefined;
    } | {
        status: boolean;
        message: any;
    }>;
    checkStatus(): Promise<any>;
    forcePull(peerId: string): Promise<{
        status: boolean;
        data: any;
        message: string;
    } | {
        status: boolean;
        message: any;
        data?: undefined;
    }>;
    pushToPeers(entities?: Array<string>, checkInFlag?: boolean, toPeerIds?: Array<string>): Promise<void>;
    resolvePeers(correctPeerid: string): Promise<void>;
    checkinAll(): Promise<void>;
    changeLogger(config: ILoggerConfig): Promise<any>;
    isLocalUpdate(dataEntityName: string, action?: string): any;
    selectInMemory(dataEntityName: string, action?: string): any;
    private doCreateEntity;
    createEntities(dMetaDatas: Array<DataEntityMetadata>): Promise<string[]>;
    create(type: string, dMetaData: any): Promise<any>;
    drop(type: string, dataEntityName: string): Promise<any>;
    analyzeDataEntity(de: string, isIncludeRows: boolean, isDoHash: boolean): Promise<any>;
    isBusy(): Promise<boolean>;
    isCrazyBusy(): Promise<boolean>;
    checkin(): Promise<any>;
    getNodeAddrs(): Promise<string[]>;
    /**
     * Expose the function yamlStrToJson
     * @param yamlStr
     * @returns
     */
    yamlStrToJson(yamlStr: string): Promise<any>;
    /**
     * Expose the function jsonToYAMLStr
     * @param obj
     * @returns
     */
    jsonToYAMLStr(obj: object): Promise<string>;
    /**
     * Expose the parse function of yaml package. It doesn't keep comments in object.
     * @param yamlStr
     * @returns
     */
    yamlParse(yamlStr: string): Promise<object>;
    /**
     * Expose the stringify function of yaml package. It doesn't convert the obj.__bzdb_yaml_metadata.comments to yaml comments
     * @param obj
     * @returns
     */
    yamlStringify(obj: object): Promise<string>;
    /**
     * Just for testing purpose. Provide some settings through stdin.
     * @param testType
     */
    setTestStatus(testType: string): Promise<void>;
    /**
     * Just for testing purpose. Invoke this to hangup (disconnect) the connection with a peer
     * @param peerId
     */
    hangup(peerId: string): Promise<void>;
}
declare function startWorker(dbMeta: any): Promise<DbWorker>;
declare class ConflictManager {
    worker: DbWorker;
    _conflictObserver: Promise<any>;
    _conflictObserverResolve: Function;
    constructor(worker: DbWorker);
    waitForconflictObserverSetting(): Promise<void>;
    saveConflictData(data: any): Promise<void>;
    updateDataConflictStatus(): Promise<void>;
    clearDataConflict(): Promise<void>;
    getCorrectId(conflictData: any): string;
}
declare class TaskSender {
    observer: any;
    worker: DbWorker;
    tasks: Map<string, any>;
    _observable: Observable<any>;
    _observerProm: Promise<any>;
    _observerResolve: Function;
    constructor(worker: DbWorker);
    getObservable(): Observable<any>;
    setObserver(observer: any): void;
    waitForObserverSetting(): Promise<void>;
    send(data: any): Promise<unknown>;
    sendEvent(data: any, sendFlag?: boolean): Promise<void>;
    replyToWorker(id: string, data: any): Promise<void>;
}
export { DbWorker, startWorker };
