import crypto from 'crypto';
import { CONFIG } from '../constants/config.js';
import { ACTION } from '../constants/actions.js';
import { loggers } from '../services/index.js';
const txnLogger = loggers.txn;
/** @private */
let prvProps = new WeakMap();
/**
 * @class Transaction
 */
class Transaction {
    /**
     * @description Crypto transaction.
     * @param {Object} obj Details of the transaction
     * @param {string} obj.fromAddr Address of the sender
     * @param {Key} obj.fromPubKey Public key of the sender
     * @param {string} obj.toAddr Address of the receiver
     * @param {number} [obj.amount=0] Amount of coins
     * @param {string=} [obj.sig] Signature of the sender
     * @param {number} [obj.fee=0] Transaction fee
     * @version 3
     * @memberof Transaction
     * @throws {Error} No fromAddr/fromPubKey/toAddr property
     */
    constructor(data) {
        const txnData = {
            type: data.type,
            subject: data.subject,
            data: data.data,
            options: data.options ? data.options : {},
            timestamp: data.timestamp ? data.timestamp : Date.now(),
            hash: data.hash
            // signature
        };
        prvProps.set(this, txnData);
        if (!data.hash) {
            this.updateHash();
        }
        // if (!fromAddr || !fromPubKey || !toAddr) throw new Error('A transaction needs to have a fromAddr, fromPubKey and toAddr property');
        // prvProps.set(this, {
        //   fromAddr,
        //   fromPubKey,
        //   toAddr,
        //   amount,
        // sig,
        // hash: null,
        // timestamp: Date.now(),
        //   fee
        // });
    }
    /**
     * @description Calculate the hash of the transaction.
     * @return {string} Hash
     * @memberof Transaction
     */
    calculateHash() {
        const txnData = prvProps.get(this);
        const hmac = crypto.createHmac(CONFIG.HASH_ALGORITHM, CONFIG.HASH_KEY);
        hmac.update(txnData.type + txnData.subject + JSON.stringify(txnData.options) + txnData.timestamp + JSON.stringify(txnData.data));
        return hmac.digest('hex');
    }
    /**
     * @description Update the hash of the block.
     * @memberof Transaction
     */
    updateHash() {
        prvProps.get(this).hash = this.calculateHash();
    }
    toJSON() {
        return prvProps.get(this);
    }
    async execute(db) {
        const txnData = prvProps.get(this);
        const deName = txnData.subject;
        const action = txnData.type;
        const value = txnData.data;
        const options = txnData.options;
        const txnId = options?.txnId;
        txnLogger.logDebug(`Txn executed for ${deName}, action: ${action}`, txnId);
        switch (action) {
            case ACTION.DB_INSERT:
                return await db.insert(deName, value, options);
            case ACTION.DB_UPDATE:
                return await db.update(deName, options?.filter, value, options);
            case ACTION.DB_DELETE:
                return await db.delete(deName, options?.filter, options);
            case ACTION.DB_UPDATE_OR_INSERT:
                return await db.updateOrInsert(deName, value, options);
            case ACTION.DB_BULKLOAD:
                return await db.bulkLoad(deName, value, options);
            case ACTION.DB_CREATE:
                return await db.create(deName, value, options);
            default:
                return Promise.reject({ status: false, message: 'Unknown DB action' });
        }
    }
    //   /**
    //    * @description Get the sender's address.
    //    * @return {string} Address of the origin
    //    * @memberof Transaction
    //    */
    //   get fromAddr() {
    //     return prvProps.get(this).fromAddr;
    //   }
    //   /**
    //    * @description Get the receiver's address.
    //    * @return {string} Address of the destination
    //    * @memberof Transaction
    //    */
    //   get toAddr() {
    //     return prvProps.get(this).toAddr;
    //   }
    //   /**
    //    * @description Get the public key the transaction comes from.
    //    * @return {Key} Origin
    //    * @memberof Transaction
    //    */
    //   get fromPubKey() {
    //     return prvProps.get(this).fromPubKey;
    //   }
    //   /**
    //    * @description Get the transaction's amount.
    //    * @return {number} Coins
    //    * @memberof Transaction
    //    */
    //   get amount() {
    //     return prvProps.get(this).amount;
    //   }
    /**
     * @description Get the transaction's timestamp.
     * @return {number} Timestamp
     * @memberof Transaction
     */
    get timestamp() {
        return prvProps.get(this).timestamp;
    }
    /**
     * @description Get the transaction's hash.
     * @return {string} Hash
     * @memberof Transaction
     */
    get hash() {
        return prvProps.get(this).hash;
    }
    get subject() {
        return prvProps.get(this).subject;
    }
    get type() {
        return prvProps.get(this).type;
    }
    get data() {
        return prvProps.get(this).data;
    }
    //   /**
    //    * @description Get the transaction's fee.
    //    * @return {number} Fee
    //    * @memberof Transaction
    //    */
    //   get fee() {
    //     return prvProps.get(this).fee;
    //   }
    //   /**
    //    * @description Change the transaction fee.
    //    * @param {number} val New fee
    //    * @memberof Transaction
    //    */
    //   set fee(val) {
    //     prvProps.get(this).fee = val;
    //   }
    //   /**
    //    * @description Get the transaction's signature.
    //    * @return {string} Signature
    //    * @memberof Transaction
    //    */
    //   get sig() {
    //     return prvProps.get(this).sig;
    //   }
    //   /**
    //    * @description Sign this transaction with a given private key.
    //    * @param {Key} sk Secret key
    //    * @memberof Transaction
    //    */
    //   sign(sk) {
    //     prvProps.get(this).sig = sign(sk, this.hash);
    //   }
    /**
     * @description Check if the hash is valid.
     * @return {boolean} Validity
     * @memberof Transaction
     */
    isValid() {
        // return this.hash === this.calculateHash() && this.hasValidSignature() // && this.amount > 0 && this.fee >= 0
        return true;
        // TBD, Validations to do: 
        // validate the action in DB
        // validate the signature
    }
    /**
     * @description Check if the signature is valid.
     * @return {boolean} Validity
     * @memberof Transaction
     */
    hasValidSignature() {
        return true;
        // return this.sig && verify({
        //   pubKey: this.fromPubKey,
        //   msg: this.hash,
        //   sig: this.sig
        // });
    }
}
export { Transaction };
