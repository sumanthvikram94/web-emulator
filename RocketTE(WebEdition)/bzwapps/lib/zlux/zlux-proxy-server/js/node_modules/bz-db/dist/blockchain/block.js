import { TransactionError } from './error.js';
import { CONFIG } from '../constants/config.js';
import { Transaction } from './transaction.js';
import { Logger } from '../services/index.js';
/** @private */
let prvProps = new WeakMap();
class Block {
    // competeFactor: number
    constructor(data) {
        // Set to true if a pending block conflicts to an approved block
        this.isConflictWithApproved = false;
        // Set to true if a block is approved by all nodes
        this.isApproved = false;
        const blockData = {
            index: data.index,
            prevHash: data.prevHash,
            transactions: [],
            timestamp: data.timestamp ? data.timestamp : Date.now(),
            difficulty: data.difficulty ? data.difficulty : CONFIG.DIFFICULTY,
            hash: data.hash,
            nonce: data.nonce ? data.nonce : 0,
            blockUID: data.blockUID,
            competeFactor: data.competeFactor,
            createdBy: data.createdBy,
            branches: undefined
        };
        // validate transactions
        if (data.transactions.length) {
            for (let txnJson of data.transactions) {
                const txn = new Transaction(txnJson);
                if (!txn.isValid())
                    throw new TransactionError(`Invalid transaction ant-Block creation: ${txnJson.toString()}`);
                blockData.transactions.push(txn);
            }
        }
        this.redundentBlocks = data.redundentBlocks ? data.redundentBlocks : [];
        // this.competeFactor = Math.random() * 100
        prvProps.set(this, blockData);
        if (data.isGenesis) {
            blockData.hash = data.prevHash;
        }
        else if (!data.hash) {
            this.proofOfWork();
        }
    }
    get createdBy() {
        const blockData = prvProps.get(this);
        return blockData.createdBy;
    }
    get competeFactor() {
        const blockData = prvProps.get(this);
        return blockData.competeFactor;
    }
    get branches() {
        const blockData = prvProps.get(this);
        return blockData.branches;
    }
    set branches(branches) {
        prvProps.get(this).branches = branches;
    }
    setRedundentBlocks(blocks) {
        this.redundentBlocks = blocks;
    }
    getRedundentBlocks() {
        return this.redundentBlocks;
    }
    calculateHash() {
        const blockData = prvProps.get(this);
        // const val = blockData.timestamp + blockData.prevHash + JSON.stringify(blockData.transactions) + blockData.nonce
        // const hmac = crypto.createHmac(CONFIG.HASH_ALGORITHM, CONFIG.HASH_KEY)
        // hmac.update(val)
        // return hmac.digest('hex')
        // return blockData.timestamp.toString() // Reduce calculation cost of hashing
        return blockData.blockUID; // Reduce calculation cost of hashing
    }
    async executeTxns(db) {
        const blockData = prvProps.get(this);
        const results = [];
        for await (const txn of blockData.transactions) {
            try {
                const result = await txn.execute(db);
                results.push(result);
            }
            catch (e) {
                Logger.logError(e);
                // results.push({status: false, message: e.message})
                throw e; // Stops the txn if Exception
            }
        }
        return results;
    }
    toJSON() {
        return prvProps.get(this);
    }
    /**
     * @description Update the hash of the block.
     * @memberof Block
     */
    updateHash() {
        prvProps.get(this).hash = this.calculateHash();
    }
    /**
     * @description Increment the nonce until a valid hash is obtained with enough 0's at the beginning (based on the difficulty).
     * @memberof Block
     */
    proofOfWork() {
        const blockData = prvProps.get(this);
        let diff = blockData.difficulty;
        this.updateHash();
        if (diff > 0) {
            while (blockData.hash.substring(0, diff) !== '0'.repeat(diff)) {
                blockData.nonce++;
                this.updateHash();
            }
        }
    }
    get blockUID() {
        return prvProps.get(this).blockUID;
    }
    /**
     * @description Get the block's transactions.
     * @return {Transaction[]} Transaction
     * @memberof Block
     */
    get transactions() {
        return prvProps.get(this).transactions;
    }
    /**
     * @description Get the timestamp associated to the block.
     * @return {number} Timestamp
     * @memberof Block
     */
    get timestamp() {
        return prvProps.get(this).timestamp;
    }
    /**
     * @description Get the previous hash.
     * @return {string} Previous hash
     * @memberof Block
     */
    get prevHash() {
        return prvProps.get(this).prevHash;
    }
    set prevHash(hash) {
        prvProps.get(this).prevHash = hash;
    }
    /**
     * @description Get the block's hash which also acts as its header.
     * @return {Object} Hash
     * @memberof Block
     */
    get hash() {
        return prvProps.get(this).hash;
    }
    /**
     * @description Get the block's height within a chain.
     * @return {number} Height
     * @memberof Block
     */
    get index() {
        return prvProps.get(this).index;
    }
    set index(idx) {
        prvProps.get(this).index = idx;
    }
    /**
     * @description Check if the block is valid.
     * @return {boolean} Validity
     * @memberof Block
     */
    isValid() {
        let diff = prvProps.get(this).difficulty, actualHash = this.calculateHash(), actualPad = '0'.repeat(diff);
        let correctHash = this.hash === actualHash, correctPadding = this.hash.substring(0, diff) === actualPad;
        // if (log) console.log('correctHash=', correctHash, 'correctPadding=', correctPadding);
        return correctHash && correctPadding; //&& this.hasValidTree;
    }
    /**
     * @description Check if this block is a genesis block.
     * @return {boolean} Genesis block?
     * @memberof Block
     */
    getIsGenesis() {
        return this.prevHash === CONFIG.ROOT_BLOCK_HASH;
    }
}
export { Block };
