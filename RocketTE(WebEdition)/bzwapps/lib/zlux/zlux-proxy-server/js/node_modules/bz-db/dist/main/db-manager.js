import { spawn, Thread, Worker } from 'threads';
import { startWorker } from './db-worker.js';
import { uid, Utils, Logger } from '../services/index.js';
import { eventHandler } from '../event/event-handler.js';
import { CONFIG } from '../constants/config.js';
import { STATUS } from '../constants/status.js';
/**
 * Wrapper of all db functions
 */
class DbManager {
    constructor(metadata) {
        this.metadata = metadata;
        this._times = 0;
        this._regCmd = new Map();
    }
    /**
     * Starts the db worker
     */
    async startWorker() {
        // The observer which listens for msg from DB worker's task sender.
        const observer = async (taskData) => {
            if (taskData !== undefined) {
                const { id, data } = taskData;
                if (id !== undefined && data !== undefined) {
                    const { task, cmd, parames } = data;
                    if (task === 'exec') {
                        const result = await this.exec(cmd, parames);
                        this._worker.replyToWorker(id, result);
                    }
                    else if (task === 'event') {
                        if (cmd === STATUS.DATA_CONFLICT) {
                            if (eventHandler.occuredEventMap[cmd].length === 0 ||
                                (eventHandler.occuredEventMap[cmd].length > 0 &&
                                    eventHandler.occuredEventMap[cmd].filter((e) => (e.parames.dataEntity === parames.dataEntity && e.parames.type === parames.type && e.parames.remotePeerId === parames.remotePeerId)).length === 0)) {
                                if (eventHandler.listenStatusMap[cmd] === true) {
                                    eventHandler.emitter.emit(cmd, parames);
                                }
                                eventHandler.occuredEventMap[cmd].push({ cmd, parames });
                            }
                        }
                    }
                }
            }
        };
        if (this.metadata.isWorkerThreadEnabled()) { // run db-worker in seperate thread
            this._worker = await spawn(new Worker('./db-worker.js'), { timeout: 60000 }); // Wait 60 seconds for the worker creation.
            this._worker.getWorkerObservable().subscribe(observer);
            await this._worker.start(this.metadata.getMetaData());
            this.listenToStdin();
        }
        else { // Currently only used in auto-test
            this._worker = await startWorker(this.metadata.getMetaData());
            this._worker.taskSender.getObservable().subscribe(observer);
        }
    }
    /**
     * Stops the db work. Mainly used by automatical UT code
     */
    async stop() {
        if (this.metadata.isWorkerThreadEnabled()) {
            await Thread.terminate(this._worker);
        }
        else if (this._worker && this._worker.stop) {
            await this._worker.stop();
        }
        // delete this._worker
    }
    async insert(dataEntityName, value, isSilent = false) {
        return await this._worker.insert(dataEntityName, value, isSilent);
    }
    async update(dataEntityName, filter, value, constraints, isSilent = false) {
        return await this._worker.update(dataEntityName, filter, value, constraints, isSilent);
    }
    async delete(dataEntityName, filter, constraints, isSilent = false) {
        return await this._worker.delete(dataEntityName, filter, constraints, isSilent);
    }
    async updateOrInsert(dataEntityName, value, isSilent = false) {
        return await this._worker.updateOrInsert(dataEntityName, value, isSilent);
    }
    async bulkLoad(dataEntityName, values, constraints, isSilent = false) {
        return await this._worker.bulkLoad(dataEntityName, values, constraints, isSilent);
    }
    async introduceNode(nodeInfo) {
        return await this._worker.introduceNode(nodeInfo);
    }
    async checkStatus() {
        return await this._worker.checkStatus();
    }
    async batchTxn(batchTxnData) {
        return await this._worker.batchTxn(batchTxnData);
    }
    async kickNode(nodeInfo) {
        return await this._worker.kickNode(nodeInfo);
    }
    async select(dataEntityName, filter, options) {
        return await this._worker.select(dataEntityName, filter, options);
    }
    async partitions(dataEntityName) {
        return await this._worker.partitions(dataEntityName);
    }
    async writePartitions(parts) {
        return await this._worker.writePartitions(parts);
    }
    async selectNoPKData(dataEntityName) {
        return await this._worker.selectNoPKData(dataEntityName);
    }
    async count(dataEntityName) {
        return await this._worker.count(dataEntityName);
    }
    async waitStatusReady() {
        if (!this._worker) {
            await this.waitLoadReady();
        }
        return await this._worker.waitStatusReady();
    }
    async waitLoadReady() {
        if (this._worker && this._worker.waitLoadReady) {
            return await this._worker.waitLoadReady();
        }
        else { // awaiting for the worker to be instantiated
            return new Promise((resolve, reject) => {
                if (this._times % 5 === 0)
                    console.warn('Awaiting DB worker creation, seconds: ' + this._times);
                if (++this._times > 120)
                    reject('Database loading timeout');
                else {
                    setTimeout(() => {
                        resolve(this.waitLoadReady());
                    }, 1000);
                }
            });
        }
    }
    async getStatus() {
        return await this._worker.getStatus();
    }
    async printClusterStatus() {
        await this._worker.printClusterStatus();
    }
    async refreshDataEntity(dataEntityName) {
        return await this._worker.refreshDataEntity(dataEntityName);
    }
    async checkin() {
        return await this._worker.checkin();
    }
    async checkinAll() {
        return await this._worker.checkinAll();
    }
    async forcePullData(peerId) {
        return await this._worker.forcePull(peerId);
    }
    async pushToPeers(entities, checkInFlag = false) {
        await this._worker.pushToPeers(entities, checkInFlag);
    }
    async resolvePeers(peerId) {
        await this._worker.resolvePeers(peerId);
    }
    onEvent(event, cb) {
        eventHandler.onEvent(event, cb);
    }
    async changeLogger(config) {
        return await this._worker.changeLogger(config);
    }
    async getFileSyncInfo(filePath, isSync4Add = true) {
        return await this._worker.getFileSyncInfo(filePath, isSync4Add);
    }
    /*async syncUpsertArbitraryFile(filePath: string) {  // BZ-15355
        return await this._worker.syncArbitraryFile(filePath, true);
    }

    async syncDelArbitraryFile(filePath: string) {  // BZ-15355
        return await this._worker.syncArbitraryFile(filePath, false);
    }*/
    async getUID(radix, level) {
        return await this._worker.getUID(radix, level);
    }
    getUIDSync(radix, level) {
        return uid.generate(radix, level);
    }
    /**
     * In case you want to execute a function on other peers, you can register the function as a command, then call it with exec(cmd)
     * @param cmd
     * @param execFunction
     * @returns
     */
    async registerCommand(cmd, execFunction) {
        if (this.metadata.isWorkerThreadEnabled()) {
            return this._regCmd.set(cmd, execFunction);
        }
        else {
            return await this._worker.registerCommand(cmd, execFunction);
        }
    }
    async exec(cmd, parames, peerId) {
        if (this.metadata.isWorkerThreadEnabled()) {
            if (peerId) {
                return await this._worker.exec(cmd, parames, peerId);
            }
            switch (cmd) {
                case 'shutdown': {
                    const msg = 'Shutdown command received, will shutdown in 5 seconds';
                    Logger.logSevere(msg);
                    setTimeout(async () => {
                        await Utils.shutdown(this._worker);
                    }, CONFIG.CMD_SHUTDOWN_TIMEOUT);
                    return { status: true, message: msg };
                }
                default: {
                    const fun = this._regCmd.get(cmd);
                    if (fun) { // registered command
                        return await fun(...(parames ? parames : []));
                    }
                    else { // unknown command
                        return { status: false, message: 'Unknown command' };
                    }
                }
            }
        }
        else {
            return await this._worker.exec(cmd, parames, peerId);
        }
    }
    async create(schemType, dMetaDataObj) {
        return await this._worker.create(schemType, dMetaDataObj);
    }
    async drop(schemType, entiryName) {
        return await this._worker.drop(schemType, entiryName);
    }
    async getDbSnapshot() {
        return await this._worker.getDbSnapshot();
    }
    async analyzeDataEntity(de, isIncludeRows, isDoHash) {
        return await this._worker.analyzeDataEntity(de, isIncludeRows, isDoHash);
    }
    async isBusy() {
        return await this._worker.isBusy();
    }
    async isCrazyBusy() {
        return await this._worker.isCrazyBusy();
    }
    async getNodeAddrs() {
        return await this._worker.getNodeAddrs();
    }
    async yamlStrToJson(yamlStr) {
        return await this._worker.yamlStrToJson(yamlStr);
    }
    async jsonToYAMLStr(obj) {
        return await this._worker.jsonToYAMLStr(obj);
    }
    async yamlParse(yamlStr) {
        return await this._worker.yamlParse(yamlStr);
    }
    async yamlStringify(obj) {
        return await this._worker.yamlStringify(obj);
    }
    /**
     * For manually UT only. Take input into terminal, and do the functions.
     * Use TAB to seperate the commands, e.g.:
     * select   testDE
     */
    listenToStdin() {
        const db = this;
        process.stdin.on('data', async (data) => {
            // console.log('Handle console input')
            const cmd = (data.toString().replace('\r\n', ''));
            const tokens = cmd.split('\t');
            console.log(JSON.stringify(tokens));
            const action = tokens[0];
            try {
                if (action === 'select') {
                    const de = tokens[1];
                    const filter = tokens[2];
                    const options = JSON.parse(tokens[3] || '{}');
                    console.log(await db.select(de, filter ? JSON.parse(filter) : undefined, options));
                }
                else if ('getFileSyncInfo' === action) {
                    const abs_path = tokens[1].replace(/['"](.*)['"]/, '$1');
                    // 'fileSync' is defined in test.js
                    console.log(await db.getFileSyncInfo(abs_path));
                }
                else if ('fsadd' === action.toLowerCase()) {
                    const abs_path = tokens[1].replace(/['"](.*)['"]/, '$1');
                    // 'fileSync' is defined in test.js
                    console.log(await db._worker.testSyncArbitraryFile(abs_path, 'fileSync', true));
                }
                else if ('fsdel' === action.toLowerCase()) {
                    const abs_path = tokens[1].replace(/['"](.*)['"]/, '$1');
                    // 'fileSync' is defined in test.js
                    console.log(await db._worker.testSyncArbitraryFile(abs_path, 'fileSync', false));
                }
                else if (action === 'selectJSON') {
                    const de = tokens[1];
                    const filter = tokens[2];
                    console.log(JSON.stringify(await db.select(de, filter ? JSON.parse(filter) : undefined)));
                }
                else if (action === 'partitions') {
                    const de = tokens[1];
                    const partions = await db.partitions(de);
                    console.log('dataEntityName: ' + partions.dataEntityName);
                    console.log('partitionCount: ' + partions.partitionCount);
                    for (const part of partions.partitions) {
                        console.log('Partition: ' + part.fileName + ', length: ' + part.content.length);
                    }
                }
                else if (action === 'uid') {
                    const radix = tokens[1] ? Number.parseInt(tokens[1]) : undefined;
                    const level = tokens[2] ? Number.parseInt(tokens[2]) : undefined;
                    console.log(await db.getUID(radix, level));
                }
                else if (action === 'exec') {
                    const cmd = tokens[1] ? tokens[1] : '';
                    const peerId = tokens[2] ? tokens[2] : undefined;
                    console.log(await db.exec(cmd, [], peerId));
                }
                else if (action === 'count') {
                    const de = tokens[1];
                    console.log(await db.count(de));
                }
                else if (action === 'insert') {
                    const de = tokens[1];
                    const val = JSON.parse(tokens[2]);
                    console.log(await db.insert(de, val));
                }
                else if (action === 'update') {
                    const de = tokens[1];
                    const filter = JSON.parse(tokens[2]);
                    const val = JSON.parse(tokens[3]);
                    const cons = tokens.length >= 5 ? JSON.parse(tokens[4]) : {};
                    console.log(await db.update(de, filter, val, cons));
                }
                else if (action === 'delete') {
                    const de = tokens[1];
                    const filter = tokens.length >= 3 ? JSON.parse(tokens[2]) : {};
                    const cons = tokens.length >= 4 ? JSON.parse(tokens[3]) : {};
                    console.log(await db.delete(de, filter, cons));
                }
                else if (action === 'updateOrInsert') {
                    const de = tokens[1];
                    const val = JSON.parse(tokens[2]);
                    console.log(await db.updateOrInsert(de, val));
                }
                else if (action === 'bulkLoad') {
                    const de = tokens[1];
                    const val = JSON.parse(tokens[2]);
                    const cons = tokens.length >= 4 ? JSON.parse(tokens[3]) : undefined;
                    console.log(await db.bulkLoad(de, val, cons));
                }
                else if (action === 'introduceNode') {
                    const nodeInfo = JSON.parse(tokens[1]);
                    console.log(await this.introduceNode(nodeInfo));
                }
                else if (action === 'kickNode') {
                    const nodeInfo = JSON.parse(tokens[1]);
                    console.log(await this.kickNode(nodeInfo));
                }
                else if (action === 'checkStatus') {
                    console.log(await this.checkStatus());
                }
                else if (action === 'batchTxn') {
                    const btd = JSON.parse(tokens[1]);
                    const result = await this.batchTxn(btd);
                    console.log(result);
                }
                else if (action === 'snapshot') {
                    console.log(await this.getDbSnapshot());
                }
                else if (action === 'forcePull') {
                    const peerId = tokens[1];
                    console.log(await this.forcePullData(peerId));
                }
                else if (action === 'pushToPeers') {
                    let entities = undefined;
                    if (tokens[1])
                        entities = JSON.parse(tokens[1]);
                    await this._worker.pushToPeers(entities);
                }
                else if (action === 'resolvePeers') {
                    const peerId = tokens[1];
                    await this.resolvePeers(peerId);
                }
                else if (action === 'clusterStatus') {
                    await this.printClusterStatus();
                }
                else if (action === 'status') {
                    console.log(await this.getStatus());
                    // }else if (action === 'senderStatus'){
                    // this._msgSender.printSenders()
                    // }else if (action === 'clear'){
                    //     await this.clearChainsHist()
                }
                else if (action === 'checkin') {
                    this.checkin();
                    // }else if (action === 'cancelAutoCheckin'){
                    //     this.cancelAutoCheckin()
                }
                else if (action === 'checkinAll') {
                    this._worker.checkinAll();
                }
                else if (action === 'analyzeDataEntity') {
                    const de = tokens[1];
                    const isIncludeRows = tokens[2] !== undefined;
                    const isDoHash = tokens[3] !== undefined;
                    console.log(await this.analyzeDataEntity(de, isIncludeRows, isDoHash));
                }
                else if (action === 'stop') {
                    this.stop();
                    // } else if (action === 'perf'){
                    //     console.log(db._workflow.getPerfRecords())
                    // } else if (action === 'version'){
                    //     console.log(VERSION)
                }
                else if (action === 'create') {
                    const type = tokens[1];
                    const metaData = JSON.parse(tokens[2] || '{}');
                    const de = metaData;
                    console.log(await this.create(type, de));
                }
                else if (action === 'drop') {
                    const type = tokens[1];
                    const entityName = tokens[2];
                    console.log(await this.drop(type, entityName));
                }
                else if (action === 'isCrazyBusy') {
                    console.log(await this.isCrazyBusy());
                }
                else if (action === 'isBusy') {
                    console.log(await this.isBusy());
                }
                else if (action === 'getNodeAddrs') {
                    console.log(await this.getNodeAddrs());
                }
                else if (action === 'dbtest') { // To support testing purpose. 
                    const testType = tokens[1];
                    if (testType === 'compete') { // Test the block competition
                        const dt1 = new Date();
                        const dt2 = new Date();
                        dt2.setMilliseconds(0);
                        dt2.setSeconds(0);
                        dt2.setMinutes(dt1.getMinutes() + 2); // Starts the setTimeOut at the same time of all peers
                        setTimeout(async () => {
                            const dateStr = dt1.getFullYear() + '' + dt1.getMonth() + '' + dt1.getDate();
                            setInterval(async () => {
                                const batchTxnData1 = [
                                    { dataEntityName: "testCluster", action: "UPDATEORINSERT", value: { sut: '0', date: dateStr, uc: 1, sc: 1 } }
                                ];
                                await this.batchTxn(batchTxnData1);
                                const stat = await this.getStatus();
                                if (stat !== 'ready') {
                                    console.log('!!!!!!!!!!! Status is: ' + stat);
                                }
                            }, 5000);
                            setInterval(async () => {
                                await this.bulkLoad('testCluster', [{ sut: '0', date: dateStr, uc: 0, sc: 0 }, { sut: '1', date: dateStr, uc: 0, sc: 0 }, { sut: '2', date: dateStr, uc: 0, sc: 0 }]);
                                const stat = await this.getStatus();
                                if (stat !== 'ready') {
                                    console.log('!!!!!!!!!!! Status is: ' + stat);
                                }
                            }, 10000);
                            setInterval(async () => {
                                await this.checkin();
                            }, 10000);
                        }, dt2.getTime() - dt1.getTime());
                    }
                    else if (testType === 'enable-duplicated-block' || testType === 'disable-duplicated-block') { // Tell the worker to (start / stop) accept all blocks without validation
                        await this._worker.setTestStatus(testType);
                    }
                    else if (testType === 'hangup') {
                        const peerId = tokens[2];
                        await this._worker.hangup(peerId);
                    }
                }
                else {
                    console.warn('Unknown command, validating commands are [select,insert,update,delete,updateOrInsert,bulkLoad,introduceNode, kickNode, checkStatus,snapshot,forcePull] ');
                }
            }
            catch (e) {
                console.error(e);
            }
        });
    }
}
// below start function requires an await when invoking. it's deprecated
// let db:DbManager
// function start(metadata: DatabaseMetadata): Promise<DbManager> {
//     return new Promise<DbManager>((resolve, reject) => {
//         if (!db){
//             db = new DbManager(metadata.getMetaData());
//             db.startWorker().then(() => {
//                 resolve(db)
//             }).catch((reason) => {
//                 reject(reason)
//             })
//         }
//     })
// }
// function stop(): Promise<any>{
//     return new Promise<any>((resolve) => {
//         if (db){
//             db.stop()
//         }
//         resolve(true)
//     });
// }
export { DbManager };
