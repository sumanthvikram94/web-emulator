/**
 * Sends message to peer
 *
 *
 */
import { PassThrough } from 'stream';
import { NodeMetadata } from './node-metadata.js';
import { loggers } from '../services/index.js';
import { pipe } from 'it-pipe';
const clusterLogger = loggers.cluster;
class MessageSenderWorker {
    constructor(peerInfo, channel, localNode) {
        this.peerInfo = peerInfo;
        this.channel = channel;
        this.localNode = localNode;
    }
    async ensure() {
        await this.ensurePeerInst();
        await this.ensureMuxerStream();
    }
    async ensurePeerInst() {
        if (!this.peerInst) {
            this.peerInst = await NodeMetadata.fromJSON(this.peerInfo);
        }
    }
    getActiveConnection() {
        const conns = this.localNode.getConnections(this.peerInst.peerIdInst);
        return (conns && conns.length > 0 && conns[0].id === this.connectionId) ? conns[0] : undefined;
    }
    async ensureMuxerStream() {
        let isShouldCreate = false;
        if (!this.muxerStreamId) { // first time to send message to the channel
            isShouldCreate = true;
        }
        else if (!this.inputStream || !this.inputStream.writable || !this.inputStream.readable) { // input stream not in correct status
            isShouldCreate = true;
        }
        else {
            const conn = this.getActiveConnection();
            if (conn) { // the connection id found
                const csarr = conn.streams ? conn.streams.filter((str) => { return str.id === this.muxerStreamId; }) : false;
                if (!csarr || csarr.length === 0) { // the muxer stream id not exists
                    isShouldCreate = true;
                }
                else {
                    // clusterLogger.logDebug('Both connection and stream are not changed.')
                }
            }
            else { // the connection is re-created (connection id is changed)
                isShouldCreate = true;
            }
        }
        if (isShouldCreate === true) {
            await this.reCreateInputStream();
        }
        else {
            clusterLogger.logDebug('Input stream exists for peer: ' + this.peerInfo.id + ', channel: ' + this.channel + ', stream id: ' + this.muxerStreamId);
        }
    }
    async createMuxerStream() {
        const ma = (await this.localNode.peerStore.addressBook.get(this.peerInst.peerIdInst));
        if (!ma || ma.length === 0) {
            await this.localNode.peerStore.addressBook.set(this.peerInst.peerIdInst, this.peerInst.multiaddrs);
        }
        try {
            const stream = await this.localNode.dialProtocol(this.peerInst.peerIdInst, this.channel);
            return stream;
        }
        catch (e) {
            if (e.message.endsWith('Muxer already closed') || e.message.endsWith('The operation was aborted')) {
                clusterLogger.logWarn('Muxer already closed. Trying to re-establish the connection.');
                clusterLogger.logWarn('Hangup the connection');
                await this.localNode.hangUp(this.peerInst.peerIdInst);
                clusterLogger.logWarn('Establish the connection');
                await this.localNode.dial(this.peerInst.peerIdInst);
                clusterLogger.logWarn('Get the stream for protocol');
                const stream = await this.localNode.dialProtocol(this.peerInst.peerIdInst, this.channel);
                return stream;
            }
            throw e;
        }
    }
    createInputStream() {
        const oldStream = this.inputStream;
        const inputStream = new PassThrough();
        inputStream.on('error', async (err) => {
            clusterLogger.logSevere('Error encountered on MessageSender input steam for peer: ' + this.peerInfo.id + ', channel: ' + this.channel);
            clusterLogger.logError(err);
            await this.reCreateInputStream(); // await works here???
        });
        inputStream.on('close', () => {
            clusterLogger.logWarn('MessageSender Input steam closed for peer: ' + this.peerInfo.id + ', channel: ' + this.channel);
        });
        this.inputStream = inputStream;
        if (oldStream) {
            oldStream.removeAllListeners();
            oldStream.end(() => {
                clusterLogger.logDebug('Old send stream ended for peer: ' + this.peerInfo.id + ', channel: ' + this.channel);
            });
        }
        return inputStream;
    }
    getInputStream() {
        // await this.ensure() // This function is sometimes invoked in synch mode, so it's not awaiting for this.ensure(). Move this line to ensureSender()
        return this.inputStream;
    }
    async reCreateInputStream() {
        clusterLogger.logDebug('Creating input steam for peer: ' + this.peerInfo.id + ', channel: ' + this.channel);
        const muxerStream = await this.createMuxerStream();
        this.muxerStreamId = muxerStream.id;
        const activeConn = this.localNode.getConnections(this.peerInst.peerIdInst);
        this.connectionId = activeConn && activeConn.length > 0 ? activeConn[0].id : ''; // When re-connect, the connection id is changed.
        const inputStream = this.createInputStream();
        pipe(inputStream, muxerStream.sink);
    }
    async sendString(msg) {
        if (msg.length > 0) {
            const inStream = this.getInputStream();
            inStream.write(msg);
        }
    }
}
class MessageSender {
    constructor(localNode) {
        this.workers = new Map();
        this.localNode = localNode;
    }
    getWorkerId(peerId, channel) {
        return peerId + '|' + channel;
    }
    async ensureSender(peerInfo, channel) {
        const id = this.getWorkerId(peerInfo.id, channel);
        let sendWorker = this.workers.get(id);
        if (!sendWorker) {
            sendWorker = new MessageSenderWorker(peerInfo, channel, this.localNode);
            this.workers.set(this.getWorkerId(peerInfo.id, channel), sendWorker);
        }
        await sendWorker.ensure();
        return sendWorker;
    }
    async getInputStream(peerInfo, channel) {
        const sendWorker = await this.ensureSender(peerInfo, channel);
        return sendWorker.getInputStream();
    }
    async send(peerInfo, channel, msg) {
        const sendWorker = await this.ensureSender(peerInfo, channel);
        sendWorker.sendString(msg);
    }
    printSenders() {
        this.workers.forEach((worker) => {
            const activeConn = this.localNode.getConnections(worker.peerInst.peerIdInst);
            const csarr = (activeConn && activeConn.length > 0 && activeConn[0].streams) ? activeConn[0].streams.filter((str) => { return str.id === worker.muxerStreamId; }) : [];
            clusterLogger.logInfo('Sender Status: ' + worker.peerInfo.id + ', ' + worker.channel + ':' +
                '\nConnection id recorded: ' + worker.connectionId +
                '\nConneciton id active for peer: ' + (activeConn ? activeConn[0].id : '') +
                '\nMuxer stream id recorded: ' + worker.muxerStreamId +
                '\nMuxer stream id exists?: ' + (csarr.length > 0) +
                '\n------------------------------------------------------------');
        });
    }
}
export { MessageSender };
