import { symbol } from '@libp2p/interface-peer-discovery';
import { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';
import { logger } from '@libp2p/logger';
import multicastDNS from 'multicast-dns';
import * as query from './query.js';
import { stringGen } from './utils.js';
const log = logger('libp2p:mdns');
class MulticastDNS extends EventEmitter {
    mdns;
    broadcast;
    interval;
    serviceTag;
    peerName;
    port;
    ip;
    _queryInterval;
    components;
    constructor(components, init = {}) {
        super();
        this.broadcast = init.broadcast !== false;
        this.interval = init.interval ?? (1e3 * 10);
        this.serviceTag = init.serviceTag ?? '_p2p._udp.local';
        this.ip = init.ip ?? '224.0.0.251';
        this.peerName = init.peerName ?? stringGen(63);
        // 63 is dns label limit
        if (this.peerName.length >= 64) {
            throw new Error('Peer name should be less than 64 chars long');
        }
        this.port = init.port ?? 5353;
        this.components = components;
        this._queryInterval = null;
        this._onPeer = this._onPeer.bind(this);
        this._onMdnsQuery = this._onMdnsQuery.bind(this);
        this._onMdnsResponse = this._onMdnsResponse.bind(this);
    }
    [symbol] = true;
    [Symbol.toStringTag] = '@libp2p/mdns';
    isStarted() {
        return Boolean(this.mdns);
    }
    /**
     * Start sending queries to the LAN.
     *
     * @returns {void}
     */
    async start() {
        if (this.mdns != null) {
            return;
        }
        this.mdns = multicastDNS({ port: this.port, ip: this.ip });
        this.mdns.on('query', this._onMdnsQuery);
        this.mdns.on('response', this._onMdnsResponse);
        this._queryInterval = query.queryLAN(this.mdns, this.serviceTag, this.interval);
    }
    _onMdnsQuery(event) {
        if (this.mdns == null) {
            return;
        }
        log.trace('received incoming mDNS query');
        query.gotQuery(event, this.mdns, this.peerName, this.components.addressManager.getAddresses(), this.serviceTag, this.broadcast);
    }
    _onMdnsResponse(event) {
        log.trace('received mDNS query response');
        try {
            const foundPeer = query.gotResponse(event, this.peerName, this.serviceTag);
            if (foundPeer != null) {
                log('discovered peer in mDNS query response %p', foundPeer.id);
                this.dispatchEvent(new CustomEvent('peer', {
                    detail: foundPeer
                }));
            }
        }
        catch (err) {
            log.error('Error processing peer response', err);
        }
    }
    _onPeer(evt) {
        if (this.mdns == null) {
            return;
        }
        this.dispatchEvent(new CustomEvent('peer', {
            detail: evt.detail
        }));
    }
    /**
     * Stop sending queries to the LAN.
     *
     * @returns {Promise}
     */
    async stop() {
        if (this.mdns == null) {
            return;
        }
        this.mdns.removeListener('query', this._onMdnsQuery);
        this.mdns.removeListener('response', this._onMdnsResponse);
        if (this._queryInterval != null) {
            clearInterval(this._queryInterval);
            this._queryInterval = null;
        }
        await new Promise((resolve) => {
            if (this.mdns != null) {
                this.mdns.destroy(resolve);
            }
            else {
                resolve();
            }
        });
        this.mdns = undefined;
    }
}
export function mdns(init = {}) {
    return (components) => new MulticastDNS(components, init);
}
/* for reference

   [ { name: '_p2p._udp.local',
       type: 'PTR',
       class: 1,
       ttl: 120,
       data: 'XQxZeAH6MX2n4255fzYmyUCUdhQ0DAWv.p2p._udp.local' },

     { name: 'XQxZeAH6MX2n4255fzYmyUCUdhQ0DAWv.p2p._udp.local',
       type: 'TXT',
       class: 1,
       ttl: 120,
       data: 'dnsaddr=/ip4/127.0.0.1/tcp/80/p2p/QmbBHw1Xx9pUpAbrVZUKTPL5Rsph5Q9GQhRvcWVBPFgGtC' },
]

*/
//# sourceMappingURL=index.js.map