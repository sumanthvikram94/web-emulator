"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Counter = void 0;
var _ = require("underscore");
var Counter = /** @class */ (function () {
    function Counter(name) {
        // counts: Map<number, number> = new Map();
        this.keys = [];
        this.values = [];
        this.lastCount = 0;
        this.recording = true;
        this.name = name;
        this.bornAt = new Date().getTime();
        // this.trigger();
    }
    Counter.prototype.destroy = function () {
        // clearInterval(this.sumaryLoop);
        delete this.keys;
        delete this.values;
        delete this.lastCount;
        delete this.firstAt;
        delete this.lastAt;
        // delete this.sumaryLoop;
        // delete this.summary;
    };
    Counter.prototype.has = function (key) {
        return this.keys.includes(key);
    };
    Counter.prototype.get = function (key) {
        return this.values[this.keys.indexOf(key)];
    };
    Counter.prototype.set = function (key, value) {
        this.keys.push(key);
        this.values.push(value);
    };
    /**
     * increase the count number
     * @param pace : number to increase. can be positive or nagetive number.
     */
    Counter.prototype.increase = function (pace) {
        if (!this.recording)
            return false;
        this.lastCount = this.lastCount + (pace || 1);
        this.lastAt = new Date().getTime();
        if (!this.firstAt)
            this.firstAt = this.lastAt;
        this.set(this.lastAt, this.lastCount);
        return true;
    };
    Counter.prototype.getName = function () {
        return this.name;
    };
    /**
     * Gets the count number at the given ts, or get the last count
     * @param ts
     */
    Counter.prototype.getCountAt = function (ts) {
        if (!ts || ts >= this.lastAt)
            return this.lastCount;
        if (ts < this.firstAt)
            return 0;
        var idx = -1;
        for (var _i = 0, _a = this.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            if (key > ts) {
                break;
            }
            idx++;
        }
        return idx > -1 ? this.values[idx] : 0;
    };
    /**
     * Get the peak count during a time period
     * @param beginAt : timestamp
     * @param endAt : timestamp
     */
    Counter.prototype.getPeak = function (beginAt, endAt) {
        if (!this.firstAt)
            return 0; // No record yet
        if (beginAt !== undefined && beginAt === endAt)
            return this.getCountAt(beginAt);
        if (beginAt !== undefined && endAt !== undefined && beginAt > endAt)
            return NaN;
        var calSince = beginAt || 0;
        var calTill = endAt || this.lastAt + 1;
        if (calSince >= this.lastAt) {
            return this.lastCount; // if the expected period is later than the last record, the peek value should be the last count
        }
        else if (calTill < this.firstAt) {
            return 0;
        }
        var findSince = -1;
        var findTill = -1;
        for (var _i = 0, _a = this.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            if (key <= calSince) {
                findSince++;
                findTill++;
            }
            else if (key <= calTill) {
                findTill++;
            }
            else if (key > calTill) {
                break;
            }
        }
        if (findSince === -1)
            findSince = 0; // in case endAt is larger than the last record
        if (findTill === -1)
            findTill = this.keys.length - 1; // in case endAt is larger than the last record
        var values = this.values.slice(findSince, findTill + 1);
        if (values.length === 0)
            return 0;
        return _.max(values);
    };
    /**
     * Calculate the average count during given period.
     * @param beginAt : Timestamp, defaults to 0
     * @param endAt : Timestamp, defaults to current timestamp
     *
     * Description:
     * Formula: y = (Î£ (record * duration)) / total_duration
     * Where:
     *  "record" stands for each count recorded.
     *  "duration" stands for milliseconds a count kept
     *  "total_duration" stands for millisecounds between the timestamp of calculation start and endAt./
     *  The "the timestamp of calculation start" is the max(beginAt, The 1st record timestamp). /
     *  In other words, the time before the 1st record is ignored.
     */
    Counter.prototype.getAvg = function (beginAt, endAt) {
        if (!this.firstAt)
            return 0; // No record yet
        if (beginAt !== undefined && beginAt === endAt)
            return this.getCountAt(beginAt);
        if (beginAt !== undefined && endAt !== undefined && beginAt > endAt)
            return NaN; // Invalid parameters
        var calSince = beginAt || 0; // MS since
        var calTill = endAt || new Date().getTime(); // MS till
        if (calSince >= this.lastAt) {
            return this.lastCount; // if the expected period is later than the last record, the peek value should be the last count
        }
        else if (calTill < this.firstAt) {
            return 0;
        }
        var findSince = -1; // Index since
        var findTill = -1; // Index till
        for (var _i = 0, _a = this.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            if (key <= calSince) {
                findSince++;
                findTill++;
            }
            else if (key <= calTill) {
                findTill++;
            }
            else if (key > calTill) {
                break;
            }
        }
        if (findSince === -1)
            findSince = 0; // in case endAt is larger than the last record
        if (findTill === -1)
            findTill = this.keys.length - 1; // in case endAt is larger than the last record
        var values = this.values.slice(findSince, findTill + 1);
        if (values.length === 0)
            return 0; // should never happen
        var firstKey = Math.max(calSince, this.keys[findSince], this.firstAt); // handle the case where beginAt is early than firstAt
        var restKeys = this.keys.slice(findSince + 1, findTill + 1);
        if (restKeys.length === 0)
            return values[0];
        var totalTs = calTill - firstKey;
        var totalCount = 0;
        var lastKey = firstKey;
        var idx = 0;
        for (var _b = 0, restKeys_1 = restKeys; _b < restKeys_1.length; _b++) {
            var key = restKeys_1[_b];
            totalCount += (key - lastKey) * values[idx++];
            lastKey = key;
        }
        totalCount += (calTill - lastKey) * values[idx];
        var result = totalCount / totalTs;
        return result;
    };
    /**
     * Cut the records with a given timestamp
     * @param cutAt : number
     */
    Counter.prototype.cut = function (cutAt) {
        var cutKeys;
        var cutValues;
        var doAppend = true;
        var cms = cutAt || new Date().getTime();
        if (!this.firstAt)
            return { cutAt: cms }; // No record yet
        if (cms <= this.firstAt)
            return { cutAt: cms }; // Nothing happens
        if (cms >= this.lastAt) {
            cutKeys = this.keys;
            cutValues = this.values;
            this.keys = [];
            this.values = [];
            this.keys.push(cms);
            this.values.push(this.lastCount);
            this.firstAt = cms;
            this.lastAt = cms;
        }
        else {
            // cutAt is between this.firstAt and this.lastAt
            var cutIdx = -1; // Last index to cut
            for (var _i = 0, _a = this.keys; _i < _a.length; _i++) {
                var key = _a[_i];
                if (key < cms) {
                    cutIdx++;
                }
                else if (key === cms) {
                    doAppend = false;
                    break;
                }
                else {
                    break;
                }
            }
            if (cutIdx === -1)
                return { cutAt: cms }; // Nothing happens
            // const values = this.values.slice(findSince, findTill + 1);
            var oldKeys = this.keys;
            var oldValues = this.values;
            cutKeys = oldKeys.slice(0, cutIdx + 1);
            cutValues = oldValues.slice(0, cutIdx + 1);
            this.keys = [];
            this.values = [];
            if (doAppend) {
                this.keys.push(cms); // what if cms === next index?
                this.values.push(oldValues[cutIdx]);
            }
            this.keys = this.keys.concat(oldKeys.slice(cutIdx + 1));
            this.values = this.values.concat(oldValues.slice(cutIdx + 1));
            this.firstAt = cms;
            // this.firstAt = cms;
        }
        return {
            cutAt: cms,
            cutKeys: cutKeys,
            cutValues: cutValues,
        };
    };
    Counter.prototype.length = function () {
        return this.keys.length;
    };
    return Counter;
}());
exports.Counter = Counter;
//# sourceMappingURL=counter.js.map