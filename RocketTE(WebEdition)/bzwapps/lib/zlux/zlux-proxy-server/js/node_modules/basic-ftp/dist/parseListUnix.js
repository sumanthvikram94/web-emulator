"use strict";
//import { FileInfo, FileType } from "./FileInfo"
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformList = exports.parseLine = exports.testLine = void 0;
const JA_MONTH = "\u6708";
const JA_DAY = "\u65e5";
const JA_YEAR = "\u5e74";
/**
 * This parser is based on the FTP client library source code in Apache Commons Net provided
 * under the Apache 2.0 license. It has been simplified and rewritten to better fit the Javascript language.
 *
 * https://github.com/apache/commons-net/blob/master/src/main/java/org/apache/commons/net/ftp/parser/UnixFTPEntryParser.java
 *
 * Below is the regular expression used by this parser.
 *
 * Permissions:
 *    r   the file is readable
 *    w   the file is writable
 *    x   the file is executable
 *    -   the indicated permission is not granted
 *    L   mandatory locking occurs during access (the set-group-ID bit is
 *        on and the group execution bit is off)
 *    s   the set-user-ID or set-group-ID bit is on, and the corresponding
 *        user or group execution bit is also on
 *    S   undefined bit-state (the set-user-ID bit is on and the user
 *        execution bit is off)
 *    t   the 1000 (octal) bit, or sticky bit, is on [see chmod(1)], and
 *        execution is on
 *    T   the 1000 bit is turned on, and execution is off (undefined bit-
 *        state)
 *    e   z/OS external link bit
 *    Final letter may be appended:
 *    +   file has extended security attributes (e.g. ACL)
 *    Note: local listings on MacOSX also use '@'
 *    this is not allowed for here as does not appear to be shown by FTP servers
 *    {@code @}   file has extended attributes
 */
const RE_LINE = new RegExp("([bcdelfmpSs-])" // file type
    //+"(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-])))\\+?" // permissions
    + "(\\S+)" // permissions
    + "\\s+" // separator TODO why allow it to be omitted??
    //+ "(\\d+)"                                      // link count
    + "(?:(\\d+(?:\\s\\d+)*?)\\s+)?" // link count
    + "(?:(\\S+(?:\\s\\S+)*?)\\s+)?" // owner name (optional spaces)
    + "(?:(\\S+(?:\\s\\S+)*)\\s+)?" // group name (optional spaces)
    + "(\\d+(?:,\\s*\\d+)?)" // size or n,m
    + "\\s+" // separator
    /**
     * numeric or standard format date:
     *   yyyy-mm-dd (expecting hh:mm to follow)
     *   MMM [d]d
     *   [d]d MMM
     *   N.B. use non-space for MMM to allow for languages such as German which use
     *   diacritics (e.g. umlaut) in some abbreviations.
     *   Japanese uses numeric day and month with suffixes to distinguish them
     *   [d]dXX [d]dZZ
     */
    + "(" +
    "(?:\\d+[-/]\\d+[-/]\\d+)" + // yyyy-mm-dd
    "|(?:\\S{3}\\s+\\d{1,2})" + // MMM [d]d
    "|(?:\\d{1,2}\\s+\\S{3})" + // [d]d MMM
    "|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + ")" +
    ")"
    + "\\s+" // separator
    /**
     * year (for non-recent standard format) - yyyy
     * or time (for numeric or recent standard format) [h]h:mm
     * or Japanese year - yyyyXX
     */
    + "((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))"
    + "\\s+" // separator
    + "(.*)" // the rest
);
const RE_LINE2 = new RegExp("(total)"
    + "\\s+" // separator
    + "(\\d+)");
/**
 * Returns true if a given line might be a Unix-style listing.
 *
 * - Example: `-rw-r--r--+   1 patrick  staff   1057 Dec 11 14:35 test.txt`
 */
function testLine(line, ftp) {
    ftp.log("testLine: " + line);
    ftp.log("result: " + RE_LINE.test(line));
    if ((line == "") || (RE_LINE.test(line)))
        return true;
    return RE_LINE2.test(line);
}
exports.testLine = testLine;
/**
 * Parse a single line of a Unix-style directory listing.
 */
function parseLine(line, ftp) {
    let obj = {};
    ftp.log("parseLine: " + line);
    const groups = line.match(RE_LINE);
    ftp.log(groups);
    if (groups === null) {
        if ((line == "") || (line.match(RE_LINE2))) {
            obj.Name = "";
            obj.Size = "";
            obj.Date = "";
            obj.Permissions = "";
            obj.Owner = "";
            obj.Group = "";
            obj.type = "";
            return obj;
        }
        return undefined;
    }
    /*
    const name = groups[21]
    if (name === "." || name === "..") { // Ignore parent directory links
        return undefined
    }
    const file = new FileInfo(name)
    file.size = parseInt(groups[18], 10)
    file.user = groups[16]
    file.group = groups[17]
    file.hardLinkCount = parseInt(groups[15], 10)
    file.rawModifiedAt = groups[19] + " " + groups[20]
    file.permissions = {
        user: parseMode(groups[4], groups[5], groups[6]),
        group: parseMode(groups[8], groups[9], groups[10]),
        world: parseMode(groups[12], groups[13], groups[14]),
    }
    // Set file type
    switch (groups[1].charAt(0)) {
        case "d":
            file.type = FileType.Directory
            break
        case "e": // NET-39 => z/OS external link
            file.type = FileType.SymbolicLink
            break
        case "l":
            file.type = FileType.SymbolicLink
            break
        case "b":
        case "c":
            file.type = FileType.File // TODO change this if DEVICE_TYPE implemented
            break
        case "f":
        case "-":
            file.type = FileType.File
            break
        default:
            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.
            file.type = FileType.Unknown
    }
    // Separate out the link name for symbolic links
    if (file.isSymbolicLink) {
        const end = name.indexOf(" -> ")
        if (end !== -1) {
            file.name = name.substring(0, end)
            file.link = name.substring(end + 4)
        }
    }
    return file
    */
    //Perms  #links	owner	group	size	datetime	filename
    obj.Name = groups[9];
    if (obj.Name === "." || obj.Name === "..") { // Ignore parent directory links
        return undefined;
    }
    obj.Size = groups[6];
    obj.Date = groups[7] + " " + groups[8];
    obj.Permissions = groups[2];
    obj.Owner = groups[4];
    obj.Group = groups[5];
    //obj.Link = "";
    switch (groups[1].charAt(0)) {
        case "d":
            obj.type = "folder";
            break;
        case "e": // NET-39 => z/OS external link
            obj.type = "link";
            break;
        case "l":
            obj.type = "link";
            break;
        case "b":
        case "c":
            obj.type = "file"; // TODO change this if DEVICE_TYPE implemented
            break;
        case "f":
        case "-":
            obj.type = "file";
            break;
        default:
            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of
            // 'translucent' filesystems, of which a 'union' filesystem is one.
            obj.type = "unknown";
    }
    // Separate out the link name for symbolic links
    if (obj.type == "link") {
        let name = obj.Name;
        const end = name.indexOf(" -> ");
        if (end !== -1) {
            obj.Name = name.substring(0, end);
            //obj.Link = name.substring(end + 4) 
        }
    }
    return obj;
}
exports.parseLine = parseLine;
function transformList(files) {
    return files;
}
exports.transformList = transformList;
/*
function parseMode(r: string, w: string, x: string): number {
    let value = 0
    if (r !== "-") {
        value += FileInfo.UnixPermission.Read
    }
    if (w !== "-") {
        value += FileInfo.UnixPermission.Write
    }
    const execToken = x.charAt(0)
    if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
        value += FileInfo.UnixPermission.Execute
    }
    return value
}
*/ 
