"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadTo = exports.uploadFrom = exports.connectForPassiveTransfer = exports.parsePasvResponse = exports.enterPassiveModeIPv4 = exports.parseEpsvResponse = exports.enterPassiveModeIPv6 = exports.enterActiveModeIPv4 = exports.awaitPort = void 0;
//import { describeAddress, describeTLS, ipIsPrivateV4Address } from "./netUtils"
const netUtils_1 = require("./netUtils");
const tls_1 = require("tls");
const FtpContext_1 = require("./FtpContext");
const parseControlResponse_1 = require("./parseControlResponse");
const net = __importStar(require("net"));
async function awaitPort(ftp, port = 80, maxPort = 65535) {
    return new Promise((resolve, reject) => {
        //ftp.log("local: " + ftp.socket.localAddress);
        //ftp.log("remote: " + ftp.socket.remoteAddress);
        if (ftp.activeServer === undefined) {
            throw new Error("Data listening socket is not valid.");
        }
        ftp.activeServer.once('error', (error) => {
            if (error.code !== 'EADDRINUSE' || ++port > maxPort)
                reject(error);
            else {
                if (ftp.activeServer)
                    ftp.activeServer.listen(port);
            }
        });
        ftp.activeServer.once('listening', () => {
            resolve(port);
        })
            .listen(port, ftp.socket.localAddress);
    });
}
exports.awaitPort = awaitPort;
/**
 * Prepare a data socket using active mode over IPv4.
 */
async function enterActiveModeIPv4(ftp) {
    ftp.portActive = false;
    ftp.activeServer = net.createServer(function (socket) {
        //ftp.log('The FTP Server has connected...');
        if (ftp.socket instanceof tls_1.TLSSocket) {
            socket = tls_1.connect(Object.assign({}, ftp.tlsOptions, {
                socket,
            }));
            // It's the responsibility of the transfer task to wait until the
            // TLS socket issued the event 'secureConnect'. We can't do this
            // here because some servers will start upgrading after the
            // specific transfer request has been made. List and download don't
            // have to wait for this event because the server sends whenever it
            // is ready. But for upload this has to be taken into account,
            // see the details in the upload() function below.
        }
        // Let the FTPContext listen to errors from now on, remove local handler.
        //socket.removeListener("error", handleConnErr)
        ftp.dataSocket = socket;
        ftp.portActive = true;
        ftp._passToHandler({ code: 399, message: "Test" });
    });
    await awaitPort(ftp, 0);
    //ftp.log(ftp.activeServer.address());
    let address;
    address = ftp.activeServer.address();
    let iPort = Number(address.port);
    let cPort = address.address + "," + ((iPort >> 8) & 0xff) + "," + (iPort & 0xff);
    //ftp.log(cPort);
    cPort = cPort.replace(/\./g, ",");
    //ftp.log(cPort);
    const res = await ftp.request("PORT " + cPort);
    if (res.code === 200) {
        //ftp.log("200 received");
    }
    else if (res.code === 399) {
        //Super fast connect before 200 is received
        return await ftp.request(""); //wait for 200
    }
    else {
        //most likely failure
        //ftp.log("something else received");
    }
    return res;
}
exports.enterActiveModeIPv4 = enterActiveModeIPv4;
/**
 * Prepare a data socket using passive mode over IPv6.
 */
async function enterPassiveModeIPv6(ftp) {
    const res = await ftp.request("EPSV");
    const port = parseEpsvResponse(res.message);
    if (!port) {
        throw new Error("Can't parse EPSV response: " + res.message);
    }
    const controlHost = ftp.socket.remoteAddress;
    if (controlHost === undefined) {
        throw new Error("Control socket is disconnected, can't get remote address.");
    }
    await connectForPassiveTransfer(controlHost, port, ftp);
    return res;
}
exports.enterPassiveModeIPv6 = enterPassiveModeIPv6;
/**
 * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.
 */
function parseEpsvResponse(message) {
    // Get port from EPSV response, e.g. "229 Entering Extended Passive Mode (|||6446|)"
    // Some FTP Servers such as the one on IBM i (OS/400) use ! instead of | in their EPSV response.
    const groups = message.match(/[|!]{3}(.+)[|!]/);
    if (groups === null || groups[1] === undefined) {
        throw new Error(`Can't parse response to 'EPSV': ${message}`);
    }
    const port = parseInt(groups[1], 10);
    if (Number.isNaN(port)) {
        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);
    }
    return port;
}
exports.parseEpsvResponse = parseEpsvResponse;
/**
 * Prepare a data socket using passive mode over IPv4.
 */
async function enterPassiveModeIPv4(ftp) {
    const res = await ftp.request("PASV");
    const target = parsePasvResponse(res.message);
    if (!target) {
        throw new Error("Can't parse PASV response: " + res.message);
    }
    // If the host in the PASV response has a local address while the control connection hasn't,
    // we assume a NAT issue and use the IP of the control connection as the target for the data connection.
    // We can't always perform this replacement because it's possible (although unlikely) that the FTP server
    // indeed uses a different host for data connections.
    const controlHost = ftp.socket.remoteAddress;
    if (netUtils_1.ipIsPrivateV4Address(target.host) && controlHost && !netUtils_1.ipIsPrivateV4Address(controlHost)) {
        target.host = controlHost;
    }
    await connectForPassiveTransfer(target.host, target.port, ftp);
    return res;
}
exports.enterPassiveModeIPv4 = enterPassiveModeIPv4;
/**
 * Parse a PASV response.
 */
function parsePasvResponse(message) {
    // Get host and port from PASV response, e.g. "227 Entering Passive Mode (192,168,1,100,10,229)"
    const groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
    if (groups === null || groups.length !== 4) {
        throw new Error(`Can't parse response to 'PASV': ${message}`);
    }
    return {
        host: groups[1].replace(/,/g, "."),
        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
    };
}
exports.parsePasvResponse = parsePasvResponse;
function connectForPassiveTransfer(host, port, ftp) {
    return new Promise((resolve, reject) => {
        const handleConnErr = function (err) {
            err.message = "Can't open data connection in passive mode: " + err.message;
            reject(err);
        };
        let socket = ftp._newSocket();
        socket.on("error", handleConnErr);
        socket.connect({ port, host, family: ftp.ipFamily }, () => {
            if (ftp.socket instanceof tls_1.TLSSocket) {
                socket = tls_1.connect(Object.assign({}, ftp.tlsOptions, {
                    socket,
                }));
                // It's the responsibility of the transfer task to wait until the
                // TLS socket issued the event 'secureConnect'. We can't do this
                // here because some servers will start upgrading after the
                // specific transfer request has been made. List and download don't
                // have to wait for this event because the server sends whenever it
                // is ready. But for upload this has to be taken into account,
                // see the details in the upload() function below.
            }
            // Let the FTPContext listen to errors from now on, remove local handler.
            socket.removeListener("error", handleConnErr);
            ftp.dataSocket = socket;
            resolve();
        });
    });
}
exports.connectForPassiveTransfer = connectForPassiveTransfer;
/**
 * Helps resolving/rejecting transfers.
 *
 * This is used internally for all FTP transfers. For example when downloading, the server might confirm
 * with "226 Transfer complete" when in fact the download on the data connection has not finished
 * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by
 * e.g. the control connection. We just don't know in which order this will happen.
 */
class TransferResolver {
    /**
     * Instantiate a TransferResolver
     */
    constructor(ftp, progress) {
        this.ftp = ftp;
        this.progress = progress;
        this.response = undefined;
        this.dataTransferDone = false;
        this.timer = undefined;
    }
    /**
     * Mark the beginning of a transfer.
     *
     * @param name - Name of the transfer, usually the filename.
     * @param type - Type of transfer, usually "upload" or "download".
     */
    onDataStart(name, type) {
        // Let the data socket be in charge of tracking timeouts during transfer.
        // The control socket sits idle during this time anyway and might provoke
        // a timeout unnecessarily. The control connection will take care
        // of timeouts again once data transfer is complete or failed.
        if (this.ftp.dataSocket === undefined) {
            throw new Error("Data transfer should start but there is no data connection.");
        }
        this.ftp.socket.setTimeout(0);
        this.ftp.dataSocket.setTimeout(this.ftp.timeout);
        this.progress.start(this.ftp.dataSocket, name, type);
        /*
        if ( this.ftp.keepalive == undefined ) {
            this.ftp.log("create temp timer");
            this.timer = setInterval(() => {
                this.ftp.log("send temp noop");
                this.ftp.send("NOOP");
            }, 60000);
        }
        */
    }
    /**
     * The data connection has finished the transfer.
     */
    onDataDone(task) {
        this.progress.updateAndStop();
        // Hand-over timeout tracking back to the control connection. It's possible that
        // we don't receive the response over the control connection that the transfer is
        // done. In this case, we want to correctly associate the resulting timeout with
        // the control connection.
        this.ftp.socket.setTimeout(this.ftp.timeout);
        if (this.ftp.dataSocket) {
            this.ftp.dataSocket.setTimeout(0);
        }
        this.dataTransferDone = true;
        this.tryResolve(task);
    }
    /**
     * The control connection reports the transfer as finished.
     */
    onControlDone(task, response) {
        this.response = response;
        this.tryResolve(task);
    }
    /**
     * An error has been reported and the task should be rejected.
     */
    onError(task, err) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        this.ftp.dataSocket = undefined;
        task.reject(err);
    }
    /**
     * Control connection sent an unexpected request requiring a response from our part. We
     * can't provide that (because unknown) and have to close the contrext with an error because
     * the FTP server is now caught up in a state we can't resolve.
     */
    onUnexpectedRequest(response) {
        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);
        this.ftp.closeWithError(err);
    }
    tryResolve(task) {
        // To resolve, we need both control and data connection to report that the transfer is done.
        const canResolve = this.dataTransferDone && this.response !== undefined;
        if (canResolve) {
            /*
            if (this.timer != undefined) {
                clearInterval(this.timer);
                this.timer = undefined;
            }
            */
            this.ftp.dataSocket = undefined;
            task.resolve(this.response);
        }
    }
}
function uploadFrom(source, config) {
    let initTrans = false;
    const resolver = new TransferResolver(config.ftp, config.tracker);
    const fullCommand = `${config.command} ${config.remotePath}`;
    return config.ftp.handle(fullCommand, (res, task) => {
        if (res instanceof Error) {
            resolver.onError(task, res);
        }
        else if (res.code === 150 || res.code === 125) { // Ready to upload
            const dataSocket = config.ftp.dataSocket;
            if (!dataSocket) {
                if (config.ftp.activeServer) {
                    //config.ftp.log("dont return error yet");
                }
                else {
                    resolver.onError(task, new Error("Upload should begin but no data connection is available."));
                }
                return;
            }
            if (!initTrans) {
                initTrans = true;
                // If we are using TLS, we have to wait until the dataSocket issued
                // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.
                const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== undefined : true;
                onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
                    //config.ftp.log(`Uploading to ${describeAddress(dataSocket)} (${describeTLS(dataSocket)})`)
                    config.ftp.log(`Uploading to ${netUtils_1.describeAddress(dataSocket)}`); //describeTLS is buggy, seems to incorrectly report TLS1.3
                    resolver.onDataStart(config.remotePath, config.type);
                    source.on('error', function (err) { console.warn('source.error: ' + err); });
                    source.on('finish', function () { config.ftp.log('source.finish'); });
                    source.on('end', function () { config.ftp.log('source.end'); });
                    source.on('close', function () { config.ftp.log('source.close'); });
                    dataSocket.on('error', function (err) { console.warn('destination.error: ' + err); });
                    dataSocket.on('finish', function () { config.ftp.log('destination.finish'); });
                    dataSocket.on('end', function () { config.ftp.log('destination.end'); });
                    dataSocket.on('close', function () { config.ftp.log('destination.close'); });
                    source.pipe(dataSocket).once("finish", () => {
                        //dataSocket.destroy() // Explicitly close/destroy the socket to signal the end.
                        resolver.onDataDone(task);
                    });
                });
            }
        }
        else if (res.code === 399) {
            //config.ftp.log("399...");
            const dataSocket = config.ftp.dataSocket;
            if (!dataSocket) {
                resolver.onError(task, new Error("Upload should begin but no data connection is available."));
                return;
            }
            if (!initTrans) {
                initTrans = true;
                const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== undefined : true;
                onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
                    //config.ftp.log(`Uploading to ${describeAddress(dataSocket)} (${describeTLS(dataSocket)})`)
                    config.ftp.log(`Uploading to ${netUtils_1.describeAddress(dataSocket)}`); //describeTLS is buggy, seems to incorrectly report TLS1.3
                    resolver.onDataStart(config.remotePath, config.type);
                    source.on('error', function () { console.log('source.error'); });
                    source.on('finish', function () { console.log('source.finish'); });
                    source.on('end', function () { console.log('source.end'); });
                    source.on('close', function () { console.log('source.close'); });
                    dataSocket.on('error', function () { console.log('destination.error'); });
                    dataSocket.on('finish', function () { console.log('destination.finish'); });
                    dataSocket.on('end', function () { console.log('destination.end'); });
                    dataSocket.on('close', function () { console.log('destination.close'); });
                    source.pipe(dataSocket).once("finish", () => {
                        //dataSocket.destroy() // Explicitly close/destroy the socket to signal the end.
                        resolver.onDataDone(task);
                    });
                });
            }
        }
        else if (parseControlResponse_1.positiveCompletion(res.code)) { // Transfer complete
            resolver.onControlDone(task, res);
        }
        else if (parseControlResponse_1.positiveIntermediate(res.code)) {
            resolver.onUnexpectedRequest(res);
        }
        // Ignore all other positive preliminary response codes (< 200)
    });
}
exports.uploadFrom = uploadFrom;
function downloadTo(destination, config) {
    let allDataReceived = false;
    let initSocket = false;
    let initTrans = false;
    if (!config.ftp.activeServer) //If Passive
     {
        if (!config.ftp.dataSocket) {
            throw new Error("Download will be initiated but no data connection is available.");
        }
        // It's possible that data transmission begins before the control socket
        // receives the announcement. Start listening for data immediately.
        //config.ftp.dataSocket.pipe(destination)
        config.ftp.dataSocket.on("data", function (d) {
            //config.ftp.log("data socket data: ", d);
            let canContinue = destination.write(d);
            if (!canContinue) { //downstream is slower
                if (config.ftp.dataSocket)
                    config.ftp.dataSocket.pause();
                destination.once('drain', () => {
                    if (config.ftp.dataSocket)
                        config.ftp.dataSocket.resume();
                });
            }
        });
        config.ftp.dataSocket.on("end", function () {
            //config.ftp.log("data socket ended");
            //destination.end();
            allDataReceived = true;
        });
    }
    const resolver = new TransferResolver(config.ftp, config.tracker);
    return config.ftp.handle(config.command, (res, task) => {
        if (res instanceof FtpContext_1.FTPError) {
            task.resolve({ code: res.code, message: res.message });
            //resolver.onError(task, res)
        }
        else if (res instanceof Error) {
            resolver.onError(task, res);
        }
        else if (res.code === 150 || res.code === 125) { // Ready to download
            //config.ftp"125/150...");
            initTrans = true;
            const dataSocket = config.ftp.dataSocket;
            if (!dataSocket) {
                if (config.ftp.activeServer) {
                    //config.ftp.log("dont return error yet");
                }
                else {
                    resolver.onError(task, new Error("Download should begin but no data connection is available."));
                }
                return;
            }
            else {
                if ((config.ftp.portActive) && (!initSocket)) {
                    //The port connected super early and 399 fired too early
                    dataSocket.on("data", function (d) {
                        //config.ftp.log("data socket data: ", d);
                        let canContinue = destination.write(d);
                        if (!canContinue) { //downstream is slower
                            if (dataSocket)
                                dataSocket.pause();
                            destination.once('drain', () => {
                                if (dataSocket)
                                    dataSocket.resume();
                            });
                        }
                    });
                    dataSocket.on("end", function () {
                        //console.log("data socket ended");
                        //destination.end();
                        allDataReceived = true;
                        resolver.onDataDone(task);
                    });
                }
            }
            //config.ftp.log(`Downloading from ${describeAddress(dataSocket)} (${describeTLS(dataSocket)})`)
            config.ftp.log(`Downloading from ${netUtils_1.describeAddress(dataSocket)}`); //describeTLS is buggy, seems to incorrectly report TLS1.3
            resolver.onDataStart(config.remotePath, config.type);
            //onConditionOrEvent(isWritableFinished(destination), destination, "finish", () => resolver.onDataDone(task))
            if (allDataReceived) {
                resolver.onDataDone(task);
            }
            else {
                if (config.ftp.dataSocket) { //Handle socket close coming after begin/end control message
                    config.ftp.dataSocket.once("end", () => resolver.onDataDone(task));
                }
            }
        }
        else if (res.code === 350) { // Restarting at startAt.
            config.ftp.send("RETR " + config.remotePath);
        }
        else if (res.code === 399) {
            //config.ftp.log("399...");
            initSocket = true;
            const dataSocket = config.ftp.dataSocket;
            if (!dataSocket) {
                resolver.onError(task, new Error("Download should begin but no data connection is available."));
                return;
            }
            dataSocket.on("data", function (d) {
                //config.ftp.log("data socket data: ", d);
                let canContinue = destination.write(d);
                if (!canContinue) { //downstream is slower
                    if (dataSocket)
                        dataSocket.pause();
                    destination.once('drain', () => {
                        if (dataSocket)
                            dataSocket.resume();
                    });
                }
            });
            dataSocket.on("end", function () {
                //config.ftp.log("data socket ended");
                //destination.end();
                allDataReceived = true;
                resolver.onDataDone(task);
            });
            if (!initTrans) {
                config.ftp.log(`Downloading from ${netUtils_1.describeAddress(dataSocket)}`); //describeTLS is buggy, seems to incorrectly report TLS1.3
                resolver.onDataStart(config.remotePath, config.type);
                //onConditionOrEvent(isWritableFinished(destination), destination, "finish", () => resolver.onDataDone(task))
                if (allDataReceived) {
                    resolver.onDataDone(task);
                }
                else {
                    if (config.ftp.dataSocket) { //Handle socket close coming after begin/end control message
                        config.ftp.dataSocket.once("end", () => resolver.onDataDone(task));
                    }
                }
            }
        }
        else if (parseControlResponse_1.positiveCompletion(res.code)) { // Transfer complete
            if (allDataReceived)
                resolver.onDataDone(task);
            resolver.onControlDone(task, res);
        }
        else if (parseControlResponse_1.positiveIntermediate(res.code)) {
            resolver.onUnexpectedRequest(res);
        }
        // Ignore all other positive preliminary response codes (< 200)
    });
}
exports.downloadTo = downloadTo;
/**
 * Calls a function immediately if a condition is met or subscribes to an event and calls
 * it once the event is emitted.
 *
 * @param condition  The condition to test.
 * @param emitter  The emitter to use if the condition is not met.
 * @param eventName  The event to subscribe to if the condition is not met.
 * @param action  The function to call.
 */
function onConditionOrEvent(condition, emitter, eventName, action) {
    if (condition === true) {
        action();
    }
    else {
        emitter.once(eventName, () => action());
    }
}
/**
 * Detect whether a writable stream is finished, supporting Node 8.
 * From https://github.com/nodejs/node/blob/3e2a3007107b7a100794f4e4adbde19263fc7464/lib/internal/streams/end-of-stream.js#L28-L33
 */
/*
function isWritableFinished(stream: any) {
    if (stream.writableFinished) return true
    const wState = stream._writableState
    if (!wState || wState.errored) return false
    return wState.finished || (wState.ended && wState.length === 0)
}
*/
